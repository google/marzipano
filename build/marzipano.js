(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Marzipano = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.bowser=t():e.bowser=t()}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=90)}({17:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n=r(18),i=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||""},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||""},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case"NT":return"NT";case"XP":return"XP";case"NT 5.0":return"2000";case"NT 5.1":return"XP";case"NT 5.2":return"2003";case"NT 6.0":return"Vista";case"NT 6.1":return"7";case"NT 6.2":return"8";case"NT 6.3":return"8.1";case"NT 10.0":return"10";default:return}},e.getMacOSVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return"Leopard";case 6:return"Snow Leopard";case 7:return"Lion";case 8:return"Mountain Lion";case 9:return"Mavericks";case 10:return"Yosemite";case 11:return"El Capitan";case 12:return"Sierra";case 13:return"High Sierra";case 14:return"Mojave";case 15:return"Catalina";default:return}},e.getAndroidVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?"Cupcake":1===t[0]&&t[1]>=6?"Donut":2===t[0]&&t[1]<2?"Eclair":2===t[0]&&2===t[1]?"Froyo":2===t[0]&&t[1]>2?"Gingerbread":3===t[0]?"Honeycomb":4===t[0]&&t[1]<1?"Ice Cream Sandwich":4===t[0]&&t[1]<4?"Jelly Bean":4===t[0]&&t[1]>=4?"KitKat":5===t[0]?"Lollipop":6===t[0]?"Marshmallow":7===t[0]?"Nougat":8===t[0]?"Oreo":9===t[0]?"Pie":void 0},e.getVersionPrecision=function(e){return e.split(".").length},e.compareVersions=function(t,r,n){void 0===n&&(n=!1);var i=e.getVersionPrecision(t),s=e.getVersionPrecision(r),a=Math.max(i,s),o=0,u=e.map([t,r],(function(t){var r=a-e.getVersionPrecision(t),n=t+new Array(r+1).join(".0");return e.map(n.split("."),(function(e){return new Array(20-e.length).join("0")+e})).reverse()}));for(n&&(o=a-Math.min(i,s)),a-=1;a>=o;){if(u[0][a]>u[1][a])return 1;if(u[0][a]===u[1][a]){if(a===o)return 0;a-=1}else if(u[0][a]<u[1][a])return-1}},e.map=function(e,t){var r,n=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)n.push(t(e[r]));return n},e.find=function(e,t){var r,n;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,n=e.length;r<n;r+=1){var i=e[r];if(t(i,r))return i}},e.assign=function(e){for(var t,r,n=e,i=arguments.length,s=new Array(i>1?i-1:0),a=1;a<i;a++)s[a-1]=arguments[a];if(Object.assign)return Object.assign.apply(Object,[e].concat(s));var o=function(){var e=s[t];"object"==typeof e&&null!==e&&Object.keys(e).forEach((function(t){n[t]=e[t]}))};for(t=0,r=s.length;t<r;t+=1)o();return e},e.getBrowserAlias=function(e){return n.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return n.BROWSER_MAP[e]||""},e}();t.default=i,e.exports=t.default},18:function(e,t,r){"use strict";t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={"Amazon Silk":"amazon_silk","Android Browser":"android",Bada:"bada",BlackBerry:"blackberry",Chrome:"chrome",Chromium:"chromium",Electron:"electron",Epiphany:"epiphany",Firefox:"firefox",Focus:"focus",Generic:"generic","Google Search":"google_search",Googlebot:"googlebot","Internet Explorer":"ie","K-Meleon":"k_meleon",Maxthon:"maxthon","Microsoft Edge":"edge","MZ Browser":"mz","NAVER Whale Browser":"naver",Opera:"opera","Opera Coast":"opera_coast",PhantomJS:"phantomjs",Puffin:"puffin",QupZilla:"qupzilla",QQ:"qq",QQLite:"qqlite",Safari:"safari",Sailfish:"sailfish","Samsung Internet for Android":"samsung_internet",SeaMonkey:"seamonkey",Sleipnir:"sleipnir",Swing:"swing",Tizen:"tizen","UC Browser":"uc",Vivaldi:"vivaldi","WebOS Browser":"webos",WeChat:"wechat","Yandex Browser":"yandex",Roku:"roku"};t.BROWSER_MAP={amazon_silk:"Amazon Silk",android:"Android Browser",bada:"Bada",blackberry:"BlackBerry",chrome:"Chrome",chromium:"Chromium",electron:"Electron",epiphany:"Epiphany",firefox:"Firefox",focus:"Focus",generic:"Generic",googlebot:"Googlebot",google_search:"Google Search",ie:"Internet Explorer",k_meleon:"K-Meleon",maxthon:"Maxthon",edge:"Microsoft Edge",mz:"MZ Browser",naver:"NAVER Whale Browser",opera:"Opera",opera_coast:"Opera Coast",phantomjs:"PhantomJS",puffin:"Puffin",qupzilla:"QupZilla",qq:"QQ Browser",qqlite:"QQ Browser Lite",safari:"Safari",sailfish:"Sailfish",samsung_internet:"Samsung Internet for Android",seamonkey:"SeaMonkey",sleipnir:"Sleipnir",swing:"Swing",tizen:"Tizen",uc:"UC Browser",vivaldi:"Vivaldi",webos:"WebOS Browser",wechat:"WeChat",yandex:"Yandex Browser"};t.PLATFORMS_MAP={tablet:"tablet",mobile:"mobile",desktop:"desktop",tv:"tv"};t.OS_MAP={WindowsPhone:"Windows Phone",Windows:"Windows",MacOS:"macOS",iOS:"iOS",Android:"Android",WebOS:"WebOS",BlackBerry:"BlackBerry",Bada:"Bada",Tizen:"Tizen",Linux:"Linux",ChromeOS:"Chrome OS",PlayStation4:"PlayStation 4",Roku:"Roku"};t.ENGINE_MAP={EdgeHTML:"EdgeHTML",Blink:"Blink",Trident:"Trident",Presto:"Presto",Gecko:"Gecko",WebKit:"WebKit"}},90:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n,i=(n=r(91))&&n.__esModule?n:{default:n},s=r(18);function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var o=function(){function e(){}var t,r,n;return e.getParser=function(e,t){if(void 0===t&&(t=!1),"string"!=typeof e)throw new Error("UserAgent should be a string");return new i.default(e,t)},e.parse=function(e){return new i.default(e).getResult()},t=e,n=[{key:"BROWSER_MAP",get:function(){return s.BROWSER_MAP}},{key:"ENGINE_MAP",get:function(){return s.ENGINE_MAP}},{key:"OS_MAP",get:function(){return s.OS_MAP}},{key:"PLATFORMS_MAP",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&a(t.prototype,r),n&&a(t,n),e}();t.default=o,e.exports=t.default},91:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n=u(r(92)),i=u(r(93)),s=u(r(94)),a=u(r(95)),o=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||""===e)throw new Error("UserAgent parameter can't be empty");this._ua=e,this.parsedResult={},!0!==t&&this.parse()}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=o.default.find(n.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||"":this.getBrowser().name||""},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=o.default.find(i.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||"":t||""},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||"":t||""},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=o.default.find(s.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||"":this.getEngine().name||""},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=o.default.find(a.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return o.default.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},n=0,i={},s=0;if(Object.keys(e).forEach((function(t){var a=e[t];"string"==typeof a?(i[t]=a,s+=1):"object"==typeof a&&(r[t]=a,n+=1)})),n>0){var a=Object.keys(r),u=o.default.find(a,(function(e){return t.isOS(e)}));if(u){var d=this.satisfies(r[u]);if(void 0!==d)return d}var c=o.default.find(a,(function(e){return t.isPlatform(e)}));if(c){var f=this.satisfies(r[c]);if(void 0!==f)return f}}if(s>0){var l=Object.keys(i),h=o.default.find(l,(function(e){return t.isBrowser(e,!0)}));if(void 0!==h)return this.compareVersion(i[h])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),n=e.toLowerCase(),i=o.default.getBrowserTypeByAlias(n);return t&&i&&(n=i.toLowerCase()),n===r},t.compareVersion=function(e){var t=[0],r=e,n=!1,i=this.getBrowserVersion();if("string"==typeof i)return">"===e[0]||"<"===e[0]?(r=e.substr(1),"="===e[1]?(n=!0,r=e.substr(2)):t=[],">"===e[0]?t.push(1):t.push(-1)):"="===e[0]?r=e.substr(1):"~"===e[0]&&(n=!0,r=e.substr(1)),t.indexOf(o.default.compareVersions(i,r,n))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e,t){return void 0===t&&(t=!1),this.isBrowser(e,t)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default},92:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n};var s=/version\/(\d+(\.?_?\d+)+)/i,a=[{test:[/googlebot/i],describe:function(e){var t={name:"Googlebot"},r=i.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:"Opera"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\/|opios/i],describe:function(e){var t={name:"Opera"},r=i.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:"Samsung Internet for Android"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:"NAVER Whale Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:"MZ Browser"},r=i.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:"Focus"},r=i.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:"Swing"},r=i.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:"Opera Coast"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opt\/\d+(?:.?_?\d+)+/i],describe:function(e){var t={name:"Opera Touch"},r=i.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:"Yandex Browser"},r=i.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:"UC Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:"Maxthon"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:"Epiphany"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:"Puffin"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:"Sleipnir"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:"K-Meleon"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:"WeChat"},r=i.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?"QQ Browser Lite":"QQ Browser"},r=i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:"Internet Explorer"},r=i.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\sedg\//i],describe:function(e){var t={name:"Microsoft Edge"},r=i.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:"Microsoft Edge"},r=i.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:"Vivaldi"},r=i.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:"SeaMonkey"},r=i.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:"Sailfish"},r=i.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:"Amazon Silk"},r=i.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:"PhantomJS"},r=i.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:"SlimerJS"},r=i.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t={name:"BlackBerry"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:"WebOS Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:"Bada"},r=i.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:"Tizen"},r=i.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:"QupZilla"},r=i.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:"Firefox"},r=i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe:function(e){var t={name:"Electron"},r=i.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MiuiBrowser/i],describe:function(e){var t={name:"Miui"},r=i.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:"Chromium"},r=i.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:"Chrome"},r=i.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:"Google Search"},r=i.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:"Android Browser"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:"PlayStation 4"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:"Safari"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search("\\(")?/^(.*)\/(.*)[ \t]\((.*)/:/^(.*)\/(.*) /;return{name:i.default.getFirstMatch(t,e),version:i.default.getSecondMatch(t,e)}}}];t.default=a,e.exports=t.default},93:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/Roku\/DVP/],describe:function(e){var t=i.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i,e);return{name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=i.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows /i],describe:function(e){var t=i.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i,e),r=i.default.getWindowsVersionName(t);return{name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe:function(e){var t={name:s.OS_MAP.iOS},r=i.default.getSecondMatch(/(Version\/)(\d[\d.]+)/,e);return r&&(t.version=r),t}},{test:[/macintosh/i],describe:function(e){var t=i.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i,e).replace(/[_\s]/g,"."),r=i.default.getMacOSVersionName(t),n={name:s.OS_MAP.MacOS,version:t};return r&&(n.versionName=r),n}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=i.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i,e).replace(/[_\s]/g,".");return{name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=i.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i,e),r=i.default.getAndroidVersionName(t),n={name:s.OS_MAP.Android,version:t};return r&&(n.versionName=r),n}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=i.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t=i.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i,e)||i.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i,e)||i.default.getFirstMatch(/\bbb(\d+)/i,e);return{name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=i.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=i.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return{name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return{name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=i.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.PlayStation4,version:t}}}];t.default=a,e.exports=t.default},94:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/googlebot/i],describe:function(){return{type:"bot",vendor:"Google"}}},{test:[/huawei/i],describe:function(e){var t=i.default.getFirstMatch(/(can-l01)/i,e)&&"Nova",r={type:s.PLATFORMS_MAP.mobile,vendor:"Huawei"};return t&&(r.model=t),r}},{test:[/nexus\s*(?:7|8|9|10).*/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Nexus"}}},{test:[/ipad/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/kftt build/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Amazon",model:"Kindle Fire HD 7"}}},{test:[/silk/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Amazon"}}},{test:[/tablet(?! pc)/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=i.default.getFirstMatch(/(ipod|iphone)/i,e);return{type:s.PLATFORMS_MAP.mobile,vendor:"Apple",model:t}}},{test:[/nexus\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"Nexus"}}},{test:[/[^-]mobi/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"blackberry"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"BlackBerry"}}},{test:function(e){return"bada"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"windows phone"===e.getBrowserName()},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"Microsoft"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(".")[0]);return"android"===e.getOSName(!0)&&t>=3},describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return"android"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"macos"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop,vendor:"Apple"}}},{test:function(e){return"windows"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return"linux"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return"playstation 4"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}},{test:function(e){return"roku"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}}];t.default=a,e.exports=t.default},95:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:function(e){return"microsoft edge"===e.getBrowserName(!0)},describe:function(e){if(/\sedg\//i.test(e))return{name:s.ENGINE_MAP.Blink};var t=i.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i,e);return{name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=i.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=i.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=i.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\/537\.36/i],describe:function(){return{name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=i.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=a,e.exports=t.default}})}));
},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
exports.equals = equals;
exports.RANDOM = exports.ARRAY_TYPE = exports.EPSILON = void 0;

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
exports.EPSILON = EPSILON;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
exports.ARRAY_TYPE = ARRAY_TYPE;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

exports.RANDOM = RANDOM;

function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */


function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};
},{}],3:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec4 = exports.vec3 = exports.vec2 = exports.quat2 = exports.quat = exports.mat4 = exports.mat3 = exports.mat2d = exports.mat2 = exports.glMatrix = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

exports.glMatrix = glMatrix;

var mat2 = _interopRequireWildcard(require("./mat2.js"));

exports.mat2 = mat2;

var mat2d = _interopRequireWildcard(require("./mat2d.js"));

exports.mat2d = mat2d;

var mat3 = _interopRequireWildcard(require("./mat3.js"));

exports.mat3 = mat3;

var mat4 = _interopRequireWildcard(require("./mat4.js"));

exports.mat4 = mat4;

var quat = _interopRequireWildcard(require("./quat.js"));

exports.quat = quat;

var quat2 = _interopRequireWildcard(require("./quat2.js"));

exports.quat2 = quat2;

var vec2 = _interopRequireWildcard(require("./vec2.js"));

exports.vec2 = vec2;

var vec3 = _interopRequireWildcard(require("./vec3.js"));

exports.vec3 = vec3;

var vec4 = _interopRequireWildcard(require("./vec4.js"));

exports.vec4 = vec4;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./common.js":2,"./mat2.js":4,"./mat2d.js":5,"./mat3.js":6,"./mat4.js":7,"./quat.js":8,"./quat2.js":9,"./vec2.js":10,"./vec3.js":11,"./vec4.js":12}],4:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.identity = identity;
exports.fromValues = fromValues;
exports.set = set;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.rotate = rotate;
exports.scale = scale;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.str = str;
exports.frob = frob;
exports.LDU = LDU;
exports.add = add;
exports.subtract = subtract;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */


function fromValues(m00, m01, m10, m11) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */


function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */


function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */


function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/


function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */


function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],5:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.identity = identity;
exports.fromValues = fromValues;
exports.set = set;
exports.invert = invert;
exports.determinant = determinant;
exports.multiply = multiply;
exports.rotate = rotate;
exports.scale = scale;
exports.translate = translate;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 2x3 Matrix
 * @module mat2d
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b,
 *  c, d,
 *  tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(6);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */


function fromValues(a, b, c, d, tx, ty) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */


function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */


function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */


function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */


function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/


function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/


function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2d} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat2d} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {ReadonlyMat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],6:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.fromMat4 = fromMat4;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromMat2d = fromMat2d;
exports.fromQuat = fromQuat;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(9);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */


function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */


function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */


function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */


function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/


function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */


function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */


function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],7:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.scale = scale;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.fromTranslation = fromTranslation;
exports.fromScaling = fromScaling;
exports.fromRotation = fromRotation;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromQuat2 = fromQuat2;
exports.getTranslation = getTranslation;
exports.getScaling = getScaling;
exports.getRotation = getRotation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromQuat = fromQuat;
exports.frustum = frustum;
exports.perspective = perspective;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.ortho = ortho;
exports.lookAt = lookAt;
exports.targetTo = targetTo;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(16);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */


function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */


function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */


function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */


function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */


function fromQuat2(out, a) {
  var translation = new glMatrix.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */


function getRotation(out, mat) {
  var scaling = new glMatrix.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */


function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */


function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */


function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */


function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */


function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */


function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],8:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.identity = identity;
exports.setAxisAngle = setAxisAngle;
exports.getAxisAngle = getAxisAngle;
exports.getAngle = getAngle;
exports.multiply = multiply;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.calculateW = calculateW;
exports.exp = exp;
exports.ln = ln;
exports.pow = pow;
exports.slerp = slerp;
exports.random = random;
exports.invert = invert;
exports.conjugate = conjugate;
exports.fromMat3 = fromMat3;
exports.fromEuler = fromEuler;
exports.str = str;
exports.setAxes = exports.sqlerp = exports.rotationTo = exports.equals = exports.exactEquals = exports.normalize = exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.lerp = exports.dot = exports.scale = exports.mul = exports.add = exports.set = exports.copy = exports.fromValues = exports.clone = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

var mat3 = _interopRequireWildcard(require("./mat3.js"));

var vec3 = _interopRequireWildcard(require("./vec3.js"));

var vec4 = _interopRequireWildcard(require("./vec4.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/


function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */


function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > glMatrix.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */


function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */


function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */


function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */


function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */


function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */


function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > glMatrix.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = glMatrix.RANDOM();
  var u2 = glMatrix.RANDOM();
  var u3 = glMatrix.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */


function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */


function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */


function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */


function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */


var clone = vec4.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

exports.clone = clone;
var fromValues = vec4.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

exports.fromValues = fromValues;
var copy = vec4.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

exports.copy = copy;
var set = vec4.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

exports.set = set;
var add = vec4.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */

exports.add = add;
var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

exports.mul = mul;
var scale = vec4.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

exports.scale = scale;
var dot = vec4.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

exports.dot = dot;
var lerp = vec4.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

exports.lerp = lerp;
var length = vec4.length;
/**
 * Alias for {@link quat.length}
 * @function
 */

exports.length = length;
var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

exports.len = len;
var squaredLength = vec4.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

exports.sqrLen = sqrLen;
var normalize = vec4.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.normalize = normalize;
var exactEquals = vec4.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.exactEquals = exactEquals;
var equals = vec4.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

exports.equals = equals;

var rotationTo = function () {
  var tmpvec3 = vec3.create();
  var xUnitVec3 = vec3.fromValues(1, 0, 0);
  var yUnitVec3 = vec3.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = vec3.dot(a, b);

    if (dot < -0.999999) {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
      vec3.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      vec3.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


exports.rotationTo = rotationTo;

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */


exports.sqlerp = sqlerp;

var setAxes = function () {
  var matr = mat3.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

exports.setAxes = setAxes;
},{"./common.js":2,"./mat3.js":6,"./vec3.js":11,"./vec4.js":12}],9:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.fromRotationTranslationValues = fromRotationTranslationValues;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromMat4 = fromMat4;
exports.copy = copy;
exports.identity = identity;
exports.set = set;
exports.getDual = getDual;
exports.setDual = setDual;
exports.getTranslation = getTranslation;
exports.translate = translate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.rotateByQuatAppend = rotateByQuatAppend;
exports.rotateByQuatPrepend = rotateByQuatPrepend;
exports.rotateAroundAxis = rotateAroundAxis;
exports.add = add;
exports.multiply = multiply;
exports.scale = scale;
exports.lerp = lerp;
exports.invert = invert;
exports.conjugate = conjugate;
exports.normalize = normalize;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.dot = exports.mul = exports.setReal = exports.getReal = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

var quat = _interopRequireWildcard(require("./quat.js"));

var mat4 = _interopRequireWildcard(require("./mat4.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */
function create() {
  var dq = new glMatrix.ARRAY_TYPE(8);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */


function clone(a) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */


function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */


function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q a normalized quaternion
 * @param {ReadonlyVec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */


function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyVec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */


function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */


function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {ReadonlyMat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */


function fromMat4(out, a) {
  //TODO Optimize this
  var outer = quat.create();
  mat4.getRotation(outer, a);
  var t = new glMatrix.ARRAY_TYPE(3);
  mat4.getTranslation(t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */


function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */


function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} real part
 */


var getReal = quat.copy;
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} dual part
 */

exports.getReal = getReal;

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */


var setReal = quat.copy;
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

exports.setReal = setReal;

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */


function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {quat2} out
 */


function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */


function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateX(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */


function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateY(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */


function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateZ(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @returns {quat2} out
 */


function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */


function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */


function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < glMatrix.EPSILON) {
    return copy(out, a);
  }

  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 * @function
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 */


function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */


var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

exports.mul = mul;

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */


var dot = quat.dot;
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

exports.dot = dot;

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */


function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */


function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */


var length = quat.length;
/**
 * Alias for {@link quat2.length}
 * @function
 */

exports.length = length;
var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

exports.len = len;
var squaredLength = quat.squaredLength;
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

exports.sqrLen = sqrLen;

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {ReadonlyQuat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */


function str(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat2} a the first dual quaternion.
 * @param {ReadonlyQuat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat2} a the first dual quat.
 * @param {ReadonlyQuat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}
},{"./common.js":2,"./mat4.js":7,"./quat.js":8}],10:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.rotate = rotate;
exports.angle = angle;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = exports.len = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(2);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */


function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */


function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */


function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */


function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */


function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */


var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

exports.len = len;
var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

exports.sqrDist = sqrDist;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":2}],11:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.length = length;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.hermite = hermite;
exports.bezier = bezier;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformMat3 = transformMat3;
exports.transformQuat = transformQuat;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.angle = angle;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(3);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */


function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */


function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */


function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":2}],12:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */


function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */


function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */


function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */


function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = glMatrix.RANDOM() * 2 - 1;
    v2 = glMatrix.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = glMatrix.RANDOM() * 2 - 1;
    v4 = glMatrix.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */


function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":2}],13:[function(require,module,exports){
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge]
 * @returns {Object} dest
 */
function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
function merge(dest, src) {
    return extend(dest, src, true);
}

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        extend(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument;
    return (doc.defaultView || doc.parentWindow);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = last.deltaX - input.deltaX;
        var deltaY = last.deltaY - input.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.allow = true; // used by Input.TouchMouse to disable mouse events
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
        if (!this.pressed || !this.allow) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        // when we're in a touch event, so  block all upcoming mouse events
        // most mobile browser also emit mouseevents, right after touchstart
        if (isTouch) {
            this.mouse.allow = false;
        } else if (isMouse && !this.mouse.allow) {
            return;
        }

        // reset the allowMouse when we're done
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // pan-x and pan-y can be combined
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.id = uniqueId();

    this.manager = null;
    this.options = merge(options || {}, this.defaults);

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        extend(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(withState) {
            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(true);
        }

        emit(); // simple 'eventName' events

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(true);
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = extend({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        this._super.emit.call(this, input);
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            this.manager.emit(this.options.event + inOut, input);
        }
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 500, // minimal time of the pointer to be pressed
        threshold: 5 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.65,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.velocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.velocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.velocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.direction &&
            input.distance > this.options.threshold &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 2, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED ) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create an manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.4';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, { enable: false }],
        [PinchRecognizer, { enable: false }, ['rotate']],
        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    options = options || {};

    this.options = merge(options, Hammer.defaults);
    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        extend(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        var recognizers = this.recognizers;
        recognizer = this.get(recognizer);
        recognizers.splice(inArray(recognizers, recognizer), 1);

        this.touchAction.update();
        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    each(manager.options.cssProps, function(value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

extend(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

if (typeof define == TYPE_FUNCTION && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],14:[function(require,module,exports){
'use strict';

/**
 * @class
 * @classdesc Minimalistic event emitter mixin.
 */
function EventEmitter() {}

/**
 * Registers an event listener for the specified event. If the listener has
 * already been registered for the event, this is a no-op.
 *
 * @param {string} name The event name.
 * @param {function} fn The listener function.
 */
EventEmitter.prototype.addEventListener = function(name, fn) {
  var eventMap = this.__events = this.__events || {};
  var handlerList = eventMap[name] = eventMap[name] || [];
  if (handlerList.indexOf(fn) < 0) {
    handlerList.push(fn);
  }
};

/**
 * Unregisters an event listener from the specified event. If the listener
 * hasn't been registered for the event, this is a no-op.
 *
 * @param {string} name The event name.
 * @param {function} fn The listener function.
 */
EventEmitter.prototype.removeEventListener = function(name, fn) {
  var eventMap = this.__events = this.__events || {};
  var handlerList = eventMap[name];
  if (handlerList) {
    var index = handlerList.indexOf(fn);
    if (index >= 0) {
      handlerList.splice(index, 1);
    }
  }
};

/**
 * Emits an event, causing all registered event listeners for that event to be
 * called in registration order.
 *
 * @param {string} name The event name.
 * @param {...*} var_args Arguments to call listeners with.
 */
EventEmitter.prototype.emit = function(name, var_args) {
  var eventMap = this.__events = this.__events || {};
  var handlerList = eventMap[name];
  var args = Array.prototype.slice.call(arguments, 1);
  if (handlerList) {
    for (var i = 0; i < handlerList.length; i++) {
      var fn = handlerList[i];
      fn.apply(this, args);
    }
  }
};

/**
 * Mixes in {@link EventEmitter} into a constructor function.
 *
 * @param {function} ctor The constructor function.
 */
function eventEmitter(ctor) {
  for (var prop in EventEmitter.prototype) {
    if (EventEmitter.prototype.hasOwnProperty(prop)) {
      ctor.prototype[prop] = EventEmitter.prototype[prop];
    }
  }
}

module.exports = eventEmitter;

},{}],15:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var positionAbsolutely = require('./util/positionAbsolutely');
var setTransform = require('./util/dom').setTransform;
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * @class Hotspot
 * @classdesc
 *
 * A Hotspot allows a DOM element to be placed at a fixed position in the
 * image. The position is updated automatically when the {@link View view}
 * changes.
 *
 * Positioning is performed with the `transform` CSS property when available,
 * falling back to the `position`, `left` and `top` properties when not.
 * In both cases, the top left corner of the element is placed in the requested
 * position; clients are expected to use additional children elements or other
 * CSS properties to achieve more sophisticated layouts.
 *
 * There are two kinds of hotspots: regular and embedded. A regular hotspot
 * does not change size depending on the zoom level. An embedded hotspot is
 * displayed at a fixed size relative to the panorama, always covering the
 * same portion of the image.
 *
 * Clients should call {@link HotspotContainer#createHotspot} instead of
 * invoking the constructor directly.
 *
 * @param {Element} domElement The DOM element.
 * @param {View} view The view.
 * @param {Object} coords The hotspot coordinates.
 *     Use {@link RectilinearViewCoords} for a {@link RectilinearView} or
 *     {@link FlatViewCoords} for a {@link FlatView}.
 * @param {Object} opts Additional options.
 * @param {Object} opts.perspective Perspective options for embedded hotspots.
 * @param {number} [opts.perspective.radius=null] If set, embed the hotspot
 *     into the image by transforming it into the surface of a sphere with this
 *     radius.
 * @param {string} [opts.perspective.extraTransforms=null] If set, append this
 *     value to the CSS `transform` property used to position the hotspot. This
 *     may be used to rotate an embedded hotspot.
 */
function Hotspot(domElement, parentDomElement, view, coords, opts) {

  opts = opts || {};
  opts.perspective = opts.perspective || {};
  opts.perspective.extraTransforms =
      opts.perspective.extraTransforms != null ? opts.perspective.extraTransforms : "";

  this._domElement = domElement;
  this._parentDomElement = parentDomElement;
  this._view = view;
  this._coords = {};
  this._perspective = {};

  this.setPosition(coords);

  // Add hotspot into the DOM.
  this._parentDomElement.appendChild(this._domElement);

  this.setPerspective(opts.perspective);

  // Whether the hotspot is visible.
  // The hotspot may still be hidden if it's inside a hidden HotspotContainer.
  this._visible = true;

  // The current calculated screen position.
  this._position = { x: 0, y: 0 };
}

eventEmitter(Hotspot);


/**
 * Destructor.
 * Clients should call {@link HotspotContainer#destroyHotspot} instead.
 */
Hotspot.prototype.destroy = function() {
  this._parentDomElement.removeChild(this._domElement);
  clearOwnProperties(this);
};


/**
 * @return {Element}
 */
Hotspot.prototype.domElement = function() {
  return this._domElement;
};


/**
 * @return {Object}
 */
Hotspot.prototype.position = function() {
  return this._coords;
};


/**
 * @param {Object} coords
 */
Hotspot.prototype.setPosition = function(coords) {
  for (var key in coords) {
    this._coords[key] = coords[key];
  }
  this._update();
  // TODO: We should probably emit a hotspotsChange event on the parent
  // HotspotContainer. What's the best way to do so?
};


/**
 * @return {Object}
 */
Hotspot.prototype.perspective = function() {
  return this._perspective;
};


/**
 * @param {Object}
 */
Hotspot.prototype.setPerspective = function(perspective) {
  for (var key in perspective) {
    this._perspective[key] = perspective[key];
  }
  this._update();
};


/**
 * Show the hotspot
 */
Hotspot.prototype.show = function() {
  if (!this._visible) {
    this._visible = true;
    this._update();
  }
};


/**
 * Hide the hotspot
 */
Hotspot.prototype.hide = function() {
  if (this._visible) {
    this._visible = false;
    this._update();
  }
};


Hotspot.prototype._update = function() {
  var element = this._domElement;

  var params = this._coords;
  var position = this._position;
  var x, y;

  var isVisible = false;

  if (this._visible) {
    var view = this._view;

    if (this._perspective.radius) {
      // Hotspots that are embedded in the panorama may be visible even when
      // positioned behind the camera.
      isVisible = true;
      this._setEmbeddedPosition(view, params);
    } else {
      // Regular hotspots are only visible when positioned in front of the
      // camera. Note that they may be partially visible when positioned outside
      // the viewport.
      view.coordinatesToScreen(params, position);
      x = position.x;
      y = position.y;

      if (x != null && y != null) {
        isVisible = true;
        this._setPosition(x, y);
      }
    }
  }

  // Show if visible, hide if not.
  if (isVisible) {
    element.style.display = 'block';
    element.style.position = 'absolute';
  }
  else {
    element.style.display = 'none';
    element.style.position = '';
  }

};


Hotspot.prototype._setEmbeddedPosition = function(view, params) {
  var transform = view.coordinatesToPerspectiveTransform(
      params, this._perspective.radius, this._perspective.extraTransforms);
  setTransform(this._domElement, transform);
};


Hotspot.prototype._setPosition = function(x, y) {
  positionAbsolutely(this._domElement, x, y, this._perspective.extraTransforms);
};


module.exports = Hotspot;

},{"./util/clearOwnProperties":76,"./util/dom":85,"./util/positionAbsolutely":96,"minimal-event-emitter":14}],16:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Hotspot = require('./Hotspot');
var calcRect = require('./util/calcRect');
var positionAbsolutely = require('./util/positionAbsolutely');
var setAbsolute = require('./util/dom').setAbsolute;
var setOverflowHidden = require('./util/dom').setOverflowHidden;
var setOverflowVisible = require('./util/dom').setOverflowVisible;
var setNullSize = require('./util/dom').setNullSize;
var setPixelSize = require('./util/dom').setPixelSize;
var setPointerEvents = require('./util/dom').setWithVendorPrefix('pointer-events');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that a hotspot has been created or destroyed on the container.
 * @event HotspotContainer#hotspotsChange
 */

/**
 * @class HotspotContainer
 * @classdesc
 *
 * Creates a DOM element to hold {@link Hotspot hotspots} and updates their
 * position when necessary.
 *
 * @param {Element} parentDomElement The DOM element inside which the container
 *     should be created.
 * @param {Stage} stage The underlying stage.
 * @param {View} view The view according to which the hotspots are positioned.
 * @param {RenderLoop} renderLoop The render loop indicating when the hotspots
 *     must be rendered.
 * @param {Object} opts
 * @param {RectSpec} opts.rect Rectangular region covered by the container. See
 *    {@link Effects#rect}.
 */
function HotspotContainer(parentDomElement, stage, view, renderLoop, opts) {
  opts = opts || {};

  this._parentDomElement = parentDomElement;
  this._stage = stage;
  this._view = view;
  this._renderLoop = renderLoop;

  // Hotspot list.
  this._hotspots = [];

  // Whether the hotspot container should be visible.
  this._visible = true;

  // The current rect.
  this._rect = opts.rect;

  // Whether the visibility or the rect have changed since the last DOM update.
  this._visibilityOrRectChanged = true;

  // The last seen stage dimensions.
  this._stageWidth = null;
  this._stageHeight = null;

  // Temporary variable to hold the calculated position and size.
  this._tmpRect = {};

  // Wrapper element. When the rect effect is set, the wrapper will have nonzero
  // dimensions and `pointer-events: none` so that hotspots outside the rect are
  // hidden, but no mouse events are hijacked.
  this._hotspotContainerWrapper = document.createElement('div');
  setAbsolute(this._hotspotContainerWrapper);
  setPointerEvents(this._hotspotContainerWrapper, 'none');
  this._parentDomElement.appendChild(this._hotspotContainerWrapper);

  // Hotspot container element. It has zero dimensions and `pointer-events: all`
  // to override the `pointer-events: none` on the wrapper and allow hotspots to
  // be interacted with.
  this._hotspotContainer = document.createElement('div');
  setAbsolute(this._hotspotContainer);
  setPointerEvents(this._hotspotContainer, 'all');
  this._hotspotContainerWrapper.appendChild(this._hotspotContainer);

  // Update when the hotspots change or scene is re-rendered.
  this._updateHandler = this._update.bind(this);
  this._renderLoop.addEventListener('afterRender', this._updateHandler);
}

eventEmitter(HotspotContainer);


/**
 * Destructor.
 */
HotspotContainer.prototype.destroy = function() {
  while (this._hotspots.length) {
    this.destroyHotspot(this._hotspots[0]);
  }

  this._parentDomElement.removeChild(this._hotspotContainerWrapper);

  this._renderLoop.removeEventListener('afterRender', this._updateHandler);

  clearOwnProperties(this);
};


/**
 * @return {Element}
 */
HotspotContainer.prototype.domElement = function() {
  return this._hotspotContainer;
};


/**
 * @param {Rect} rect
 */
HotspotContainer.prototype.setRect = function(rect) {
  this._rect = rect;
  this._visibilityOrRectChanged = true;
};


/**
 * @return {Rect}
 */
HotspotContainer.prototype.rect = function() {
  return this._rect;
};


/**
 * Creates a new hotspot in this container.
 *
 * @param {Element} domElement DOM element to use for the hotspot
 * @param {Object} coords The hotspot coordinates.
 *     Use {@link RectilinearViewCoords}` for a {@link RectilinearView} or
 *     {@link FlatViewCoords} for a {@link FlatView}.
 * @param {Object} opts Options in the same format as the `opts` argument to
 *     the {@link Hotspot} constructor.
 * @return {Hotspot}
 */
HotspotContainer.prototype.createHotspot = function(domElement, coords, opts) {
  coords = coords || {};

  var hotspot = new Hotspot(
      domElement, this._hotspotContainer, this._view, coords, opts);
  this._hotspots.push(hotspot);
  hotspot._update();

  this.emit('hotspotsChange');

  return hotspot;
};


/**
 * @param {Hotspot} hotspot
 * @return {boolean}
 */
HotspotContainer.prototype.hasHotspot = function(hotspot) {
  return this._hotspots.indexOf(hotspot) >= 0;
};


/**
 * @return {Hotspot[]}
 */
HotspotContainer.prototype.listHotspots = function() {
  return [].concat(this._hotspots);
};


/**
 * Removes a hotspot from the container.
 *
 * @param {Hotspot} hotspot
 */
HotspotContainer.prototype.destroyHotspot = function(hotspot) {
  var i = this._hotspots.indexOf(hotspot);
  if (i < 0) {
    throw new Error('No such hotspot');
  }
  this._hotspots.splice(i, 1);

  hotspot.destroy();
  this.emit('hotspotsChange');
};


/**
 * Hide the container's DOM element, causing every contained {@link Hotspot} to
 * be hidden.
 */
HotspotContainer.prototype.hide = function() {
  if (this._visible) {
    this._visible = false;
    this._visibilityOrRectChanged = true;
    this._update();
  }
};


/**
 * Show the container's DOM element, causing every contained {@link Hotspot} to
 * be shown.
 */
HotspotContainer.prototype.show = function() {
  if (!this._visible) {
    this._visible = true;
    this._visibilityOrRectChanged = true;
    this._update();
  }
};


HotspotContainer.prototype._update = function() {
  var wrapper = this._hotspotContainerWrapper;
  var width = this._stage.width();
  var height = this._stage.height();
  var tmpRect = this._tmpRect;

  // Avoid updating the wrapper DOM unless necessary.
  if (this._visibilityOrRectChanged ||
      (this._rect && (width !== this._stageWidth || height !== this._stageHeight))) {
    var visible = this._visible;
    wrapper.style.display = visible ? 'block' : 'none';

    if (visible) {
      if (this._rect) {
        calcRect(width, height, this._rect, tmpRect);
        positionAbsolutely(wrapper, width * tmpRect.x, height * tmpRect.y);
        setPixelSize(wrapper, width * tmpRect.width, height * tmpRect.height);
        setOverflowHidden(wrapper);
      } else {
        positionAbsolutely(wrapper, 0, 0);
        setNullSize(wrapper);
        setOverflowVisible(wrapper);
      }
    }

    this._stageWidth = width;
    this._stageHeight = height;
    this._visibilityOrRectChanged = false;
  }

  // Update hotspots unconditionally, as the view parameters may have changed.
  for (var i = 0; i < this._hotspots.length; i++) {
    this._hotspots[i]._update();
  }
};


module.exports = HotspotContainer;

},{"./Hotspot":15,"./util/calcRect":72,"./util/clearOwnProperties":76,"./util/dom":85,"./util/positionAbsolutely":96,"minimal-event-emitter":14}],17:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';


var eventEmitter = require('minimal-event-emitter');
var extend = require('./util/extend');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that the layer has been rendered.
 *
 * @param {boolean} stable Whether all tiles were successfully rendered without
 *     missing textures or resorting to fallbacks.
 * @event Layer#renderComplete
 */

/**
 * @class Layer
 * @classdesc
 *
 * A Layer is a combination of {@link Source}, {@link Geometry}, {@link View}
 * and {@link TextureStore} that may be added into a {@link Stage} and rendered
 * with {@link Effects}.
 *
 * @param {Source} source
 * @param {Geometry} geometry
 * @param {View} view
 * @param {TextureStore} textureStore
 * @param {Object} opts
 * @param {Effects} opts.effects
*/
function Layer(source, geometry, view, textureStore, opts) {
  opts = opts || {};

  var self = this;

  this._source = source;
  this._geometry = geometry;
  this._view = view;
  this._textureStore = textureStore;

  this._effects = opts.effects || {};

  this._fixedLevelIndex = null;

  this._viewChangeHandler = function() {
    self.emit('viewChange', self.view());
  };

  this._view.addEventListener('change', this._viewChangeHandler);

  this._textureStoreChangeHandler = function() {
    self.emit('textureStoreChange', self.textureStore());
  };

  this._textureStore.addEventListener('textureLoad',
    this._textureStoreChangeHandler);
  this._textureStore.addEventListener('textureError',
    this._textureStoreChangeHandler);
  this._textureStore.addEventListener('textureInvalid',
    this._textureStoreChangeHandler);
}

eventEmitter(Layer);


/**
 * Destructor.
 */
Layer.prototype.destroy = function() {
  this._view.removeEventListener('change', this._viewChangeHandler);
  this._textureStore.removeEventListener('textureLoad',
    this._textureStoreChangeHandler);
  this._textureStore.removeEventListener('textureError',
    this._textureStoreChangeHandler);
  this._textureStore.removeEventListener('textureInvalid',
    this._textureStoreChangeHandler);
  clearOwnProperties(this);
};


/**
 * Returns the underlying {@link Source source}.
 * @return {Source}
 */
Layer.prototype.source = function() {
  return this._source;
};


/**
 * Returns the underlying {@link Geometry geometry}.
 * @return {Geometry}
 */
Layer.prototype.geometry = function() {
  return this._geometry;
};


/**
 * Returns the underlying {@link View view}.
 * @return {View}
 */
Layer.prototype.view = function() {
  return this._view;
};


/**
 * Returns the underlying {@link TextureStore texture store}.
 * @return {TextureStore}
 */
Layer.prototype.textureStore = function() {
  return this._textureStore;
};


/**
 * Returns the currently set {@link Effects effects}.
 * @return {Effects}
 */
Layer.prototype.effects = function() {
  return this._effects;
};


/**
 * Sets the {@link Effects effects}.
 * @param {Effects} effects
 */
Layer.prototype.setEffects = function(effects) {
  this._effects = effects;
  this.emit('effectsChange', this._effects);
};


/**
 * Merges effects into the currently set ones. The merge is non-recursive; for
 * instance, if current effects are `{ rect: { relativeWidth: 0.5 } }`,
 * calling this method with `{ rect: { relativeX: 0.5 }}` will reset
 * `rect.relativeWidth`.
 *
 * @param {Effects} effects
 */
Layer.prototype.mergeEffects = function(effects) {
  extend(this._effects, effects);
  this.emit('effectsChange', this._effects);
};


/**
 * Returns the fixed level index.
 * @return {(number|null)}
 */
Layer.prototype.fixedLevel = function() {
  return this._fixedLevelIndex;
};


/**
 * Sets the fixed level index. When set, the corresponding level will be
 * used regardless of the view parameters. Unset with a null argument.
 *
 * @param {(number|null)} levelIndex
 * @throws An error if the level index is out of range.
 */
Layer.prototype.setFixedLevel = function(levelIndex) {
  if (levelIndex !== this._fixedLevelIndex) {
    if (levelIndex != null && (levelIndex >= this._geometry.levelList.length ||
        levelIndex < 0)) {
      throw new Error("Level index out of range: " + levelIndex);
    }
    this._fixedLevelIndex = levelIndex;
    this.emit('fixedLevelChange', this._fixedLevelIndex);
  }
};


Layer.prototype._selectLevel = function() {
  var level;
  if (this._fixedLevelIndex != null) {
    level = this._geometry.levelList[this._fixedLevelIndex];
  } else {
    level = this._view.selectLevel(this._geometry.selectableLevelList);
  }
  return level;
};


Layer.prototype.visibleTiles = function(result) {
  var level = this._selectLevel();
  return this._geometry.visibleTiles(this._view, level, result);
};


/**
 * Pin a whole level into the texture store.
 * @param {Number} levelIndex
 */
Layer.prototype.pinLevel = function(levelIndex) {
  var level = this._geometry.levelList[levelIndex];
  var tiles = this._geometry.levelTiles(level);
  for (var i = 0; i < tiles.length; i++) {
    this._textureStore.pin(tiles[i]);
  }
};


/**
 * Unpin a whole level from the texture store.
 * @param {Number} levelIndex
 */
Layer.prototype.unpinLevel = function(levelIndex) {
  var level = this._geometry.levelList[levelIndex];
  var tiles = this._geometry.levelTiles(level);
  for (var i = 0; i < tiles.length; i++) {
    this._textureStore.unpin(tiles[i]);
  }
};


/**
 * Pin the first level. Equivalent to `pinLevel(0)`.
 */
Layer.prototype.pinFirstLevel = function() {
  return this.pinLevel(0);
};


/**
 * Unpin the first level. Equivalent to `unpinLevel(0)`.
 */
Layer.prototype.unpinFirstLevel = function() {
  return this.unpinLevel(0);
};


module.exports = Layer;

},{"./util/clearOwnProperties":76,"./util/extend":86,"minimal-event-emitter":14}],18:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('./util/inherits');

/**
 * @class NetworkError
 * @extends {Error}
 * @classdesc
 *
 * Signals an error that occurred while fetching a URL. This is used by
 * {@link Loader loaders} to distinguish network failures from other errors.
 */
function NetworkError(message) {
  // See: https://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript
  this.constructor.super_.apply(this, arguments);
  this.message = message;
}

inherits(NetworkError, Error);

module.exports = NetworkError;

},{"./util/inherits":89}],19:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that {@link Stage#render} is about to be called.
 * @event RenderLoop#beforeRender
 */

/**
 * Signals that {@link Stage#render} has just been called.
 * @event RenderLoop#afterRender
 */

/**
 * @class RenderLoop
 * @classdesc
 *
 * A RenderLoop wraps a {@link Stage} and calls {@link Stage#render} on the next
 * frame whenever it fires {@link Stage#renderInvalid}. It may be started and
 * stopped, and is initially in the stopped state, in which no call to
 * {@link Stage#render} occurs.
 *
 * @listens Stage#renderInvalid
 *
 * @param {Stage} stage
 */
function RenderLoop(stage) {

  var self = this;

  // The stage wrapped by the loop.
  this._stage = stage;

  // Whether the loop is running.
  this._running = false;

  // Whether the loop is currently rendering.
  this._rendering = false;

  // The current requestAnimationFrame handle.
  this._requestHandle = null;

  // The callback passed into requestAnimationFrame.
  this._boundLoop = this._loop.bind(this);

  // Handler for renderInvalid events emitted by the stage.
  this._renderInvalidHandler = function() {
    // If we are already rendering, there's no need to schedule a new render
    // on the next frame.
    if (!self._rendering) {
      self.renderOnNextFrame();
    }
  };

  // Handle renderInvalid events emitted by the stage.
  this._stage.addEventListener('renderInvalid', this._renderInvalidHandler);

}

eventEmitter(RenderLoop);


/**
 * Destructor.
 */
RenderLoop.prototype.destroy = function() {
  this.stop();
  this._stage.removeEventListener('renderInvalid', this._renderInvalidHandler);
  clearOwnProperties(this);
};


/**
 * Returns the underlying stage.
 * @return {Stage}
 */
RenderLoop.prototype.stage = function() {
  return this._stage;
};


/**
 * Starts the render loop.
 */
RenderLoop.prototype.start = function() {
  this._running = true;
  this.renderOnNextFrame();
};


/**
 * Stops the render loop.
 */
RenderLoop.prototype.stop = function() {
  if (this._requestHandle) {
    window.cancelAnimationFrame(this._requestHandle);
    this._requestHandle = null;
  }
  this._running = false;
};


/**
 * Forces the stage to render on the next frame, even if its contents remain
 * valid. Does nothing if the loop is stopped.
 */
RenderLoop.prototype.renderOnNextFrame = function() {
  if (this._running && !this._requestHandle) {
    this._requestHandle = window.requestAnimationFrame(this._boundLoop);
  }
};


RenderLoop.prototype._loop = function() {
  if (!this._running) {
    throw new Error('Render loop running while in stopped state');
  }
  this._requestHandle = null;
  this._rendering = true;
  this.emit('beforeRender');
  this._rendering = false;
  this._stage.render();
  this.emit('afterRender');
};


module.exports = RenderLoop;

},{"./util/clearOwnProperties":76,"minimal-event-emitter":14}],20:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Layer = require('./Layer');
var TextureStore = require('./TextureStore');
var HotspotContainer = require('./HotspotContainer');
var eventEmitter = require('minimal-event-emitter');
var now = require('./util/now');
var noop = require('./util/noop');
var type = require('./util/type');
var defaults = require('./util/defaults');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that the scene's view has changed. See {@link View#event:change}.
 * @event Scene#viewChange
 */

/**
 * Signals that the scene's layers have changed.
 * @event Scene#layerChange
 */

/**
 * @class Scene
 * @classdesc
 *
 * A Scene is a stack of {@link Layer layers} sharing the same {@link View view}
 * and {@link HotspotContainer hotspot container}. It belongs to the
 * {@link Viewer viewer} inside which it is displayed.
 *
 * Clients should call {@link Viewer#createScene} instead of invoking the
 * constructor directly.
 *
 * @param {Viewer} viewer The viewer this scene belongs to.
 * @param {View} view The scene's underlying view.
 */
function Scene(viewer, view) {
  this._viewer = viewer;
  this._view = view;
  this._layers = [];

  // Hotspot container. Assume it occupies a full rect.
  this._hotspotContainer = new HotspotContainer(
    viewer._controlContainer,
    viewer.stage(),
    this._view,
    viewer.renderLoop());

  // The current movement.
  this._movement = null;
  this._movementStartTime = null;
  this._movementStep = null;
  this._movementParams = null;
  this._movementCallback = null;

  // Event listener for updating the view according to the current movement.
  // The listener is set/unset on the render loop when a movement starts/stops.
  this._updateMovementHandler = this._updateMovement.bind(this);

  // Show or hide hotspots when scene changes.
  this._updateHotspotContainerHandler = this._updateHotspotContainer.bind(this);
  this._viewer.addEventListener('sceneChange', this._updateHotspotContainerHandler);

  // Emit event when view changes.
  this._viewChangeHandler = this.emit.bind(this, 'viewChange');
  this._view.addEventListener('change', this._viewChangeHandler);

  // Update the hotspot container.
  this._updateHotspotContainer();
}

eventEmitter(Scene);


/**
 * Destructor. Clients should call {@link Viewer#destroyScene} instead.
 */
Scene.prototype.destroy = function() {
  this._view.removeEventListener('change', this._viewChangeHandler);
  this._viewer.removeEventListener('sceneChange', this._updateHotspotContainerHandler);

  if (this._movement) {
    this.stopMovement();
  }

  this._hotspotContainer.destroy();

  this.destroyAllLayers();

  clearOwnProperties(this);
};



/**
 * Returns the {@link HotspotContainer hotspot container} for the scene.
 * @return {Layer}
 */
Scene.prototype.hotspotContainer = function() {
  return this._hotspotContainer;
};

/**
 * Returns the first of the {@link Layer layers} belonging to the scene, or
 * null if the scene has no layers.
 *
 * This method is equivalent to `Scene#listLayers[0]`. It may be removed in the
 * future.
 *
 * @return {Layer}
 */
Scene.prototype.layer = function() {
  return this._layers[0];
};

/**
* Returns a list of all {@link Layer layers} belonging to the scene. The
* returned list is in display order, background to foreground.
* @return {Layer[]}
 */
Scene.prototype.listLayers = function() {
  return [].concat(this._layers);
};


/**
 * Returns the scene's underlying {@link View view}.
 * @return {View}
 */
Scene.prototype.view = function() {
  return this._view;
};


/**
 * Returns the {@link Viewer viewer} the scene belongs to.
 * @return {Viewer}
 */
Scene.prototype.viewer = function() {
  return this._viewer;
};


/**
 * Returns whether the scene is currently visible.
 * @return {boolean}
 */
Scene.prototype.visible = function() {
  return this._viewer.scene() === this;
};


/**
 * Creates a new {@link Layer layer} and adds it into the scene in the
 * foreground position.
 *
 * @param {Object} opts Layer creation options.
 * @param {Source} opts.source The layer's underlying {@link Source}.
 * @param {Source} opts.geometry The layer's underlying {@link Geometry}.
 * @param {boolean} [opts.pinFirstLevel=false] Whether to pin the first level to
 *     provide a fallback of last resort, at the cost of memory consumption.
 * @param {Object} [opts.textureStoreOpts={}] Options to pass to the
 *     {@link TextureStore} constructor.
 * @param {Object} [opts.layerOpts={}] Options to pass to the {@link Layer}
 *     constructor.
 * @return {Layer}
 */
Scene.prototype.createLayer = function(opts) {
  opts = opts || {};

  var textureStoreOpts = opts.textureStoreOpts || {};
  var layerOpts = opts.layerOpts || {};

  var source = opts.source;
  var geometry = opts.geometry;
  var view = this._view;
  var stage = this._viewer.stage();
  var textureStore = new TextureStore(source, stage, textureStoreOpts);
  var layer = new Layer(source, geometry, view, textureStore, layerOpts);

  this._layers.push(layer);

  if (opts.pinFirstLevel) {
    layer.pinFirstLevel();
  }

  // Signal that the layers have changed.
  this.emit('layerChange');

  return layer;
};


/**
 * Destroys a {@link Layer layer} and removes it from the scene.
 * @param {Layer} layer
 * @throws An error if the layer does not belong to the scene.
 */
Scene.prototype.destroyLayer = function(layer) {
  var i = this._layers.indexOf(layer);
  if (i < 0) {
    throw new Error('No such layer in scene');
  }

  this._layers.splice(i, 1);

  // Signal that the layers have changed.
  this.emit('layerChange');

  layer.textureStore().destroy();
  layer.destroy();
};


/**
 * Destroys all {@link Layer layers} and removes them from the scene.
 */
Scene.prototype.destroyAllLayers = function() {
  while (this._layers.length > 0) {
    this.destroyLayer(this._layers[0]);
  }
};


/**
 * Switches to the scene.
 *
 * This is equivalent to calling {@link Viewer#switchScene} on this scene.
 *
 * @param {Object} opts Options to pass into {@link Viewer#switchScene}.
 * @param {function} done Function to call when the switch is complete.
 */
Scene.prototype.switchTo = function(opts, done) {
  return this._viewer.switchScene(this, opts, done);
};


/**
 * Tweens the scene's underlying {@link View view}.
 *
 * @param {Object} params Target view parameters.
 * @param {Object} opts Transition options.
 * @param {function} [opts.ease=easeInOutQuad] Tween easing function
 * @param {number} [opts.controlsInterrupt=false] allow controls to interrupt
 *     an ongoing tween.
 * @param {number} [opts.transitionDuration=1000] Tween duration, in
 *     milliseconds.
 * @param {number} [opts.closest=true] Whether to tween through the shortest
 *    path between the initial and final view parameters. This requires
 *    {@link View#normalizeToClosest} to be implemented, and does nothing
 *    otherwise.
 * @param {function} done Function to call when the tween finishes or is
 *    interrupted.
 */
Scene.prototype.lookTo = function(params, opts, done) {
  opts = opts || {};
  done = done || noop;

  if (type(params) !== 'object') {
    throw new Error("Target view parameters must be an object");
  }

  // Quadratic in/out easing.
  var easeInOutQuad = function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k;
    }
    return -0.5 * (--k * (k - 2) - 1);
  };

  var ease = opts.ease != null ? opts.ease : easeInOutQuad;
  var controlsInterrupt = opts.controlsInterrupt != null ? opts.controlsInterrupt : false;
  var duration = opts.transitionDuration != null ? opts.transitionDuration : 1000;
  var shortest = opts.shortest != null ? opts.shortest : true;

  var view = this._view;

  var initialParams = view.parameters();

  var finalParams = {};
  defaults(finalParams, params);
  defaults(finalParams, initialParams);

  // Tween through the shortest path if requested.
  // The view must implement the normalizeToClosest() method.
  if (shortest && view.normalizeToClosest) {
    view.normalizeToClosest(finalParams, finalParams);
  }

  var movement = function() {

    var finalUpdate = false;

    return function(params, elapsed) {

      if (elapsed >= duration && finalUpdate) {
        return null;
      }

      var delta = Math.min(elapsed / duration, 1);

      for (var param in params) {
        var start = initialParams[param];
        var end = finalParams[param];
        params[param] = start + ease(delta) * (end - start);
      }

      finalUpdate = elapsed >= duration;

      return params;

    };
  };

  var reenableControls = this._viewer.controls().enabled();

  if (!controlsInterrupt) {
    this._viewer.controls().disable();
  }

  this.startMovement(movement, function() {
    if (reenableControls) {
      this._viewer.controls().enable();
    }
    done();
  });

};


/**
 * Starts a movement, possibly replacing the current movement.
 *
 * @param {function} fn The movement function.
 * @param {function} done Function to be called when the movement finishes or is
 *     interrupted.
 */
Scene.prototype.startMovement = function(fn, done) {

  var renderLoop = this._viewer.renderLoop();

  if (this._movement) {
    this.stopMovement();
  }

  var step = fn();
  if (typeof step !== 'function') {
    throw new Error('Bad movement');
  }

  this._movement = fn;
  this._movementStep = step;
  this._movementStartTime = now();
  this._movementParams = {};
  this._movementCallback = done;

  renderLoop.addEventListener('beforeRender', this._updateMovementHandler);
  renderLoop.renderOnNextFrame();
};


/**
 * Stops the current movement.
 */
Scene.prototype.stopMovement = function() {

  var renderLoop = this._viewer.renderLoop();

  if (!this._movement) {
    return;
  }

  if (this._movementCallback) {
    this._movementCallback();
  }

  renderLoop.removeEventListener('beforeRender', this._updateMovementHandler);

  this._movement = null;
  this._movementStep = null;
  this._movementStartTime = null;
  this._movementParams = null;
  this._movementCallback = null;
};


/**
 * Returns the current movement.
 * @return {function}
 */
Scene.prototype.movement = function() {
  return this._movement;
};


Scene.prototype._updateMovement = function() {

  if (!this._movement) {
    throw new Error('Should not call update');
  }

  var renderLoop = this._viewer.renderLoop();
  var view = this._view;

  var elapsed = now() - this._movementStartTime;
  var step = this._movementStep;
  var params = this._movementParams;

  params = view.parameters(params);
  params = step(params, elapsed);
  if (params == null) {
    this.stopMovement();
  } else {
    view.setParameters(params);
    renderLoop.renderOnNextFrame();
  }

};


Scene.prototype._updateHotspotContainer = function() {
  if (this.visible()) {
    this._hotspotContainer.show();
  } else {
    this._hotspotContainer.hide();
  }
};


module.exports = Scene;

},{"./HotspotContainer":16,"./Layer":17,"./TextureStore":21,"./util/clearOwnProperties":76,"./util/defaults":81,"./util/noop":92,"./util/now":93,"./util/type":101,"minimal-event-emitter":14}],21:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Map = require('./collections/Map');
var Set = require('./collections/Set');
var LruSet = require('./collections/LruSet');
var eventEmitter = require('minimal-event-emitter');
var defaults = require('./util/defaults');
var retry = require('./util/retry');
var chain = require('./util/chain');
var inherits = require('./util/inherits');
var clearOwnProperties = require('./util/clearOwnProperties');

var debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.textureStore;


// A Stage informs the TextureStore about the set of visible tiles during a
// frame by calling startFrame, markTile and endFrame. In a particular frame,
// TextureStore expects one or more calls to startFrame, followed by zero or
// more calls to markTile, followed by one or more calls to endFrame. The
// number of calls to startFrame and endFrame must match. Calls to other
// TextureStore methods may be freely interleaved with this sequence.
//
// At any given time, TextureStore is in one of four states. The START state
// corresponds to the interval between the first startFrame and the first
// markTile of a frame. The MARK state corresponds to the interval between the
// first markTile and the first endFrame. The END state corresponds to the
// interval between the first and the last endFrame. At any other time, the
// TextureStore is in the IDLE state.
var State = {
  IDLE: 0,
  START: 1,
  MARK: 2,
  END: 3
};


var defaultOptions = {
  // Maximum number of cached textures for previously visible tiles.
  previouslyVisibleCacheSize: 512
};


// Assign an id to each operation so we can track its state.
// We actually only need this in debug mode, but the code is less convoluted
// if we track unconditionally, and the performance hit is minimal anyway.
var nextId = 0;


// Distinguishes a cancellation from other kinds of errors.
function CancelError() {}
inherits(CancelError, Error);


/**
 * @class TextureStoreItem
 * @classdesc
 *
 * An item saved in a {@link TextureStore}.
 *
 * Clients do not need to instantiate this. It is automatically instantiated by
 * a {@link TextureStore} to manage the lifetime of a stored item: loading,
 * refreshing, unloading and emitting associated events.
 *
 * @param {TextureStore} store The underlying {@link TextureStore}.
 * @param {Tile} tile The underlying tile.
 */
function TextureStoreItem(store, tile) {

  var self = this;

  var id = nextId++;

  self._id = id;
  self._store = store;
  self._tile = tile;

  self._asset = null;
  self._texture = null;

  self._changeHandler = function() {
    store.emit('textureInvalid', tile);
  };

  var source = store.source();
  var stage = store.stage();

  var loadAsset = source.loadAsset.bind(source);
  var createTexture = stage.createTexture.bind(stage);

  // Retry loading the asset until it succeeds, then create the texture from it.
  // This process may be canceled at any point by calling the destroy() method.
  var fn = chain(retry(loadAsset), createTexture);

  store.emit('textureStartLoad', tile);
  if (debug) {
    console.log('loading', id, tile);
  }

  self._cancel = fn(stage, tile, function(err, _tile, asset, texture) {

    // Make sure we do not call cancel after the operation is complete.
    self._cancel = null;

    if (err) {
      // The loading process was interrupted by an error.
      // This could either be because the texture creation failed, or because
      // the operation was canceled before the loading was complete.

      // Destroy the asset and texture, if they exist.
      if (asset) {
        asset.destroy();
      }
      if (texture) {
        texture.destroy();
      }

      // Emit events.
      if (err instanceof CancelError) {
        store.emit('textureCancel', tile);
        if (debug) {
          console.log('cancel', id, tile);
        }
      } else {
        store.emit('textureError', tile, err);
        if (debug) {
          console.log('error', id, tile);
        }
      }

      return;
    }

    // Save a local reference to the texture.
    self._texture = texture;

    // If the asset is dynamic, save a local reference to it and set up a
    // handler to be called whenever it changes. Otherwise, destroy the asset
    // as we won't be needing it any longer.
    if (asset.isDynamic()) {
      self._asset = asset;
      asset.addEventListener('change', self._changeHandler);
    } else {
      asset.destroy();
    }

    // Emit event.
    store.emit('textureLoad', tile);
    if (debug) {
      console.log('load', id, tile);
    }
  });

}


TextureStoreItem.prototype.asset = function() {
  return this._asset;
};


TextureStoreItem.prototype.texture = function() {
  return this._texture;
};


TextureStoreItem.prototype.destroy = function() {
  var id = this._id;
  var store = this._store;
  var tile = this._tile;
  var asset = this._asset;
  var texture = this._texture;
  var cancel = this._cancel;

  if (cancel) {
    // The texture is still loading, so cancel it.
    cancel(new CancelError('Texture load cancelled'));
    return;
  }

  // Destroy asset.
  if (asset) {
    asset.removeEventListener('change', this._changeHandler);
    asset.destroy();
  }

  // Destroy texture.
  if (texture) {
    texture.destroy();
  }

  // Emit event.
  store.emit('textureUnload', tile);
  if (debug) {
    console.log('unload', id, tile);
  }

  clearOwnProperties(this);
};

eventEmitter(TextureStoreItem);

/**
 * Signals that a texture has started to load.
 *
 * This event is followed by either {@link TextureStore#textureLoad},
 * {@link TextureStore#textureError} or {@link TextureStore#textureCancel}.
 *
 * @event TextureStore#textureStartLoad
 * @param {Tile} tile The tile for which the texture has started to load.
 */

/**
 * Signals that a texture has been loaded.
 *
 * @event TextureStore#textureLoad
 * @param {Tile} tile The tile for which the texture was loaded.
 */

/**
 * Signals that a texture has been unloaded.
 *
 * @event TextureStore#textureUnload
 * @param {Tile} tile The tile for which the texture was unloaded.
 */

/**
 * Signals that a texture has been invalidated.
 *
 * This event may be raised for a texture with an underlying dynamic asset. It
 * may only occur while the texture is loaded, i.e., in between
 * {@link TextureStore#textureLoad} and {@link TextureStore#textureUnload}.
 *
 * @event TextureStore#textureInvalid
 * @param {Tile} tile The tile for which the texture was invalidated.
 */

/**
 * Signals that loading a texture has been cancelled.
 *
 * This event may follow {@link TextureStore#textureStartLoad} if the texture
 * becomes unnecessary before it finishes loading.
 *
 * @event TextureStore#textureCancel
 * @param {Tile} tile The tile for which the texture loading was cancelled.
 */

/**
 * Signals that loading a texture has failed.
 *
 * This event may follow {@link TextureStore#textureStartLoad} if the texture
 * fails to load.
 *
 * @event TextureStore#textureError
 * @param {Tile} tile The tile for which the texture loading has failed.
 */

/**
 * @class TextureStore
 * @classdesc
 *
 * A TextureStore maintains a cache of textures used to render a {@link Layer}.
 *
 * A {@link Stage} communicates with the TextureStore through the startFrame(),
 * markTile() and endFrame() methods, which indicate the tiles that are visible
 * in the current frame. Textures for visible tiles are loaded and retained
 * as long as the tiles remain visible. A limited amount of textures whose
 * tiles were previously visible are cached according to an LRU policy. Tiles
 * may be pinned to keep their respective textures cached even when they are
 * invisible; these textures do not count towards the previously visible limit.
 *
 * Multiple layers belonging to the same underlying {@link WebGlStage} may
 * share the same TextureStore. Layers belonging to distinct {@link WebGlStage}
 * instances may not do so due to restrictions on the use of textures across
 * stages.
 *
 * @param {Source} source The underlying source.
 * @param {Stage} stage The underlying stage.
 * @param {Object} opts Options.
 * @param {Number} [opts.previouslyVisibleCacheSize=32] The maximum number of
 *     previously visible textures to cache according to an LRU policy.
 */
function TextureStore(source, stage, opts) {
  opts = defaults(opts || {}, defaultOptions);

  this._source = source;
  this._stage = stage;

  // The current state.
  this._state = State.IDLE;

  // The number of startFrame calls yet to be matched by endFrame calls during
  // the current frame.
  this._delimCount = 0;

  // The cache proper: map cached tiles to their respective textures/assets.
  this._itemMap = new Map();

  // The subset of cached tiles that are currently visible.
  this._visible = new Set();

  // The subset of cached tiles that were visible recently, but are not
  // visible right now. Newly inserted tiles replace older ones.
  this._previouslyVisible = new LruSet(opts.previouslyVisibleCacheSize);

  // The subset of cached tiles that should never be evicted from the cache.
  // A tile may be pinned more than once; map each tile into a reference count.
  this._pinMap = new Map();

  // Temporary variables.
  this._newVisible = new Set();
  this._noLongerVisible = [];
  this._visibleAgain = [];
  this._evicted = [];
}

eventEmitter(TextureStore);


/**
 * Destructor.
 */
TextureStore.prototype.destroy = function() {
  this.clear();
  clearOwnProperties(this);
};


/**
 * Return the underlying {@link Stage}.
 * @return {Stage}
 */
TextureStore.prototype.stage = function() {
  return this._stage;
};


/**
 * Return the underlying {@link Source}.
 * @return {Source}
 */
TextureStore.prototype.source = function() {
  return this._source;
};


/**
 * Remove all textures from the TextureStore, including pinned textures.
 */
TextureStore.prototype.clear = function() {
  var self = this;

  // Collect list of tiles to be evicted.
  self._evicted.length = 0;
  self._itemMap.forEach(function(tile) {
    self._evicted.push(tile);
  });

  // Evict tiles.
  self._evicted.forEach(function(tile) {
    self._unloadTile(tile);
  });

  // Clear all internal state.
  self._itemMap.clear();
  self._visible.clear();
  self._previouslyVisible.clear();
  self._pinMap.clear();
  self._newVisible.clear();
  self._noLongerVisible.length = 0;
  self._visibleAgain.length = 0;
  self._evicted.length = 0;
};


/**
 * Remove all textures in the TextureStore, excluding unpinned textures.
 */
TextureStore.prototype.clearNotPinned = function() {
  var self = this;

  // Collect list of tiles to be evicted.
  self._evicted.length = 0;
  self._itemMap.forEach(function(tile) {
    if (!self._pinMap.has(tile)) {
      self._evicted.push(tile);
    }
  });

  // Evict tiles.
  self._evicted.forEach(function(tile) {
    self._unloadTile(tile);
  });

  // Clear all caches except the pinned set.
  self._visible.clear();
  self._previouslyVisible.clear();

  // Clear temporary variables.
  self._evicted.length = 0;
};


/**
 * Signal the beginning of a frame. Called from {@link Stage}.
 */
TextureStore.prototype.startFrame = function() {
  // Check that we are in an appropriate state.
  if (this._state !== State.IDLE && this._state !== State.START) {
    throw new Error('TextureStore: startFrame called out of sequence');
  }

  // Enter the START state, if not already there.
  this._state = State.START;

  // Expect one more endFrame call.
  this._delimCount++;
};


/**
 * Mark a tile as visible within the current frame. Called from {@link Stage}.
 * @param {Tile} tile The tile to mark.
 */
TextureStore.prototype.markTile = function(tile) {
  // Check that we are in an appropriate state.
  if (this._state !== State.START && this._state !== State.MARK) {
    throw new Error('TextureStore: markTile called out of sequence');
  }

  // Enter the MARK state, if not already there.
  this._state = State.MARK;

  // Refresh texture for dynamic assets.
  var item = this._itemMap.get(tile);
  var texture = item && item.texture();
  var asset = item && item.asset();
  if (texture && asset) {
    texture.refresh(tile, asset);
  }

  // Add tile to the visible set.
  this._newVisible.add(tile);
};


/**
 * Signal the end of a frame. Called from {@link Stage}.
 */
TextureStore.prototype.endFrame = function() {
  // Check that we are in an appropriate state.
  if (this._state !== State.START && this._state !== State.MARK && this._state !== State.END) {
    throw new Error('TextureStore: endFrame called out of sequence');
  }

  // Enter the END state, if not already there.
  this._state = State.END;

  // Expect one less call to endFrame.
  this._delimCount--;

  // If no further calls are expected, process frame and enter the IDLE state.
  if (!this._delimCount) {
    this._update();
    this._state = State.IDLE;
  }
};


TextureStore.prototype._update = function() {
  var self = this;

  // Calculate the set of tiles that used to be visible but no longer are.
  self._noLongerVisible.length = 0;
  self._visible.forEach(function(tile) {
    if (!self._newVisible.has(tile)) {
      self._noLongerVisible.push(tile);
    }
  });

  // Calculate the set of tiles that were visible recently and have become
  // visible again.
  self._visibleAgain.length = 0;
  self._newVisible.forEach(function(tile) {
    if (self._previouslyVisible.has(tile)) {
      self._visibleAgain.push(tile);
    }
  });

  // Remove tiles that have become visible again from the list of previously
  // visible tiles.
  self._visibleAgain.forEach(function(tile) {
    self._previouslyVisible.remove(tile);
  });

  // Cancel loading of tiles that are no longer visible.
  // Move no longer visible tiles with a loaded texture into the previously
  // visible set, and collect the tiles evicted from the latter.
  self._evicted.length = 0;
  self._noLongerVisible.forEach(function(tile) {
    var item = self._itemMap.get(tile);
    var texture = item && item.texture();
    if (texture) {
      var otherTile = self._previouslyVisible.add(tile);
      if (otherTile != null) {
        self._evicted.push(otherTile);
      }
    } else if (item) {
      self._unloadTile(tile);
    }
  });

  // Unload evicted tiles, unless they are pinned.
  self._evicted.forEach(function(tile) {
    if (!self._pinMap.has(tile)) {
      self._unloadTile(tile);
    }
  });

  // Load visible tiles that are not already in the store.
  // Refresh texture on visible tiles for dynamic assets.
  self._newVisible.forEach(function(tile) {
    var item = self._itemMap.get(tile);
    if (!item) {
      self._loadTile(tile);
    }
  });

  // Swap the old visible set with the new one.
  var tmp = self._visible;
  self._visible = self._newVisible;
  self._newVisible = tmp;

  // Clear the new visible set.
  self._newVisible.clear();

  // Clear temporary variables.
  self._noLongerVisible.length = 0;
  self._visibleAgain.length = 0;
  self._evicted.length = 0;
};


TextureStore.prototype._loadTile = function(tile) {
  if (this._itemMap.has(tile)) {
    throw new Error('TextureStore: loading texture already in cache');
  }
  var item = new TextureStoreItem(this, tile);
  this._itemMap.set(tile, item);
};


TextureStore.prototype._unloadTile = function(tile) {
  var item = this._itemMap.del(tile);
  if (!item) {
    throw new Error('TextureStore: unloading texture not in cache');
  }
  item.destroy();
};


TextureStore.prototype.asset = function(tile) {
  var item = this._itemMap.get(tile);
  if (item) {
    return item.asset();
  }
  return null;
};


TextureStore.prototype.texture = function(tile) {
  var item = this._itemMap.get(tile);
  if (item) {
    return item.texture();
  }
  return null;
};


/**
 * Pin a tile. Textures for pinned tiles are never evicted from the store.
 * Upon pinning, the texture is created if not already present. Pins are
 * reference-counted; a tile may be pinned multiple times and must be unpinned
 * the corresponding number of times. Pinning is useful e.g. to ensure that
 * the lowest-resolution level of an image is always available to fall back
 * onto.
 * @param {Tile} tile the tile to pin
 * @returns {number} the pin reference count.
 */
TextureStore.prototype.pin = function(tile) {
  // Increment reference count.
  var count = (this._pinMap.get(tile) || 0) + 1;
  this._pinMap.set(tile, count);
  // If the texture for the tile is not present, load it now.
  if (!this._itemMap.has(tile)) {
    this._loadTile(tile);
  }
  return count;
};


/**
 * Unpin a tile. Pins are reference-counted; a tile may be pinned multiple
 * times and must be unpinned the corresponding number of times.
 * @param {Tile} tile the tile to unpin
 * @returns {number} the pin reference count.
 */
TextureStore.prototype.unpin = function(tile) {
  var count = this._pinMap.get(tile);
  // Consistency check.
  if (!count) {
    throw new Error('TextureStore: unpin when not pinned');
  } else {
    // Decrement reference count.
    count--;
    if (count > 0) {
      this._pinMap.set(tile, count);
    } else {
      this._pinMap.del(tile);
      // If the tile does not belong to either the visible or previously
      // visible sets, evict it from the cache.
      if (!this._visible.has(tile) && !this._previouslyVisible.has(tile)) {
        this._unloadTile(tile);
      }
    }
  }
  return count;
};


/**
 * Return type for {@link TextureStore#query}.
 * @typedef {Object} TileState
 * @property {boolean} visible Whether the tile is in the visible set.
 * @property {boolean} previouslyVisible Whether the tile is in the previously
 *     visible set.
 * @property {boolean} hasAsset Whether the asset for the tile is present.
 * @property {boolean} hasTexture Whether the texture for the tile is present.
 * @property {boolean} pinned Whether the tile is in the pinned set.
 * @property {number} pinCount The pin reference count for the tile.
 */


/**
 * Return the state of a tile.
 * @param {Tile} tile The tile to query.
 * @return {TileState}
 */
TextureStore.prototype.query = function(tile) {
  var item = this._itemMap.get(tile);
  var pinCount = this._pinMap.get(tile) || 0;
  return {
    visible: this._visible.has(tile),
    previouslyVisible: this._previouslyVisible.has(tile),
    hasAsset: item != null && item.asset() != null,
    hasTexture: item != null && item.texture() != null,
    pinned: pinCount !== 0,
    pinCount: pinCount
  };
};


module.exports = TextureStore;

},{"./collections/LruSet":29,"./collections/Map":30,"./collections/Set":31,"./util/chain":74,"./util/clearOwnProperties":76,"./util/defaults":81,"./util/inherits":89,"./util/retry":99,"minimal-event-emitter":14}],22:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Set = require('./collections/Set');

/**
 * @class TileSearcher
 * @classdesc
 *
 * A TileSearcher performs searches for visible tiles.
 */
function TileSearcher() {
  // Stack of tiles to be explored.
  this._stack = [];

  // Set of already explored tiles.
  this._visited = new Set();

  // Tile vertices. Allocated by Tile#vertices on first use.
  this._vertices = null;
}

/**
 * Performs a search for visible tiles by starting at a given tile and
 * recursively exploring neighbors until no more visible tiles are found.
 *
 * @param {View} view The view used to deem whether a tile is visible.
 * @param {Tile} tile The starting tile.
 * @param {Tile[]} result An array to append the visible tiles to, including the
 *     starting tile when visible. Existing array members are preserved.
 * @return {number} The number of visible tiles found.
 */
TileSearcher.prototype.search = function(view, startingTile, result) {
  var stack = this._stack;
  var visited = this._visited;
  var vertices = this._vertices;

  var count = 0;

  // Clear internal state.
  this._clear();

  stack.push(startingTile);

  while (stack.length > 0) {
    var tile = stack.pop();

    if (visited.has(tile)) {
      // Skip already visited tile.
      continue;
    }

    if (!view.intersects(tile.vertices(vertices))) {
      // Skip non-visible tile.
      continue;
    }

    // Mark tile as visited.
    visited.add(tile);

    // Add neighbors to the stack of tiles to explore.
    var neighbors = tile.neighbors();
    for (var i = 0; i < neighbors.length; i++) {
      stack.push(neighbors[i]);
    }

    // Add to result.
    result.push(tile);

    count++;
  }

  // Reuse the vertices array in future searches.
  this._vertices = vertices;

  // Clear internal state.
  this._clear();

  return count;
};

TileSearcher.prototype._clear = function() {
  this._stack.length = 0;
  this._visited.clear();
};

module.exports = TileSearcher;

},{"./collections/Set":31}],23:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var defaults = require('./util/defaults');
var now = require('./util/now');

var defaultOptions = {
  duration: Infinity
};


/**
 * Signals a timeout.
 * @event Timer#timeout
 */


/**
 * @class Timer
 * @classdesc
 *
 * A Timer provides a mechanism to receive an event after a timeout.
 *
 * A timer has a set duration, and is either started or stopped at a given time.
 * The timer is initially stopped. When the timer is started, a timeout event is
 * scheduled to fire once the set duration elapses. When the timer is stopped,
 * the scheduled timeout event is cancelled. When a timeout event fires, the
 * timer returns to the stopped state.
 *
 * @param {number} [opts.duration=Infinity] Timeout in milliseconds.
 */
function Timer(opts) {

  opts = defaults(opts || {}, defaultOptions);

  this._duration = opts.duration;

  this._startTime = null;

  this._handle = null;

  this._check = this._check.bind(this);

}

eventEmitter(Timer);


/**
 * Starts the timer. If the timer is already started, this has the effect of
 * stopping and starting again (i.e. resetting the timer).
 */
Timer.prototype.start = function() {
  this._startTime = now();
  if (this._handle == null && this._duration < Infinity) {
    this._setup(this._duration);
  }
};


/**
 * Returns whether the timer is in the started state.
 * @return {boolean}
 */
Timer.prototype.started = function() {
  return this._startTime != null;
};


/**
 * Stops the timer.
 */
Timer.prototype.stop = function() {
  this._startTime = null;
  if (this._handle != null) {
    clearTimeout(this._handle);
    this._handle = null;
  }
};


Timer.prototype._setup = function(interval) {
  this._handle = setTimeout(this._check, interval);
};


Timer.prototype._teardown = function() {
  clearTimeout(this._handle);
  this._handle = null;
};


Timer.prototype._check = function() {
  var currentTime = now();
  var elapsed = currentTime - this._startTime;
  var remaining = this._duration - elapsed;

  this._teardown();

  if (remaining <= 0) {
    this.emit('timeout');
    this._startTime = null;
  } else if (remaining < Infinity) {
    this._setup(remaining);
  }
};


/**
 * Returns the currently set duration.
 */
Timer.prototype.duration = function() {
  return this._duration;
};


/**
 * Sets the duration. If the timer is already started, the timeout event is
 * rescheduled to occur once the new duration has elapsed since the last call
 * to start. In particular, if an amount of time larger than the new duration
 * has already elapsed, the timeout event fires immediately.
 * @param {number}
 */
Timer.prototype.setDuration = function(duration) {
  this._duration = duration;
  if (this._startTime != null) {
    this._check();
  }
};


module.exports = Timer;

},{"./util/defaults":81,"./util/now":93,"minimal-event-emitter":14}],24:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var browser = require('bowser');
var eventEmitter = require('minimal-event-emitter');

var RenderLoop = require('./RenderLoop');
var Controls = require('./controls/Controls');
var Scene = require('./Scene');
var Timer = require('./Timer');

var WebGlStage = require('./stages/WebGl');

var ControlCursor = require('./controls/ControlCursor');
var HammerGestures = require('./controls/HammerGestures');

var registerDefaultControls = require('./controls/registerDefaultControls');
var registerDefaultRenderers = require('./renderers/registerDefaultRenderers');

var setOverflowHidden = require('./util/dom').setOverflowHidden;
var setAbsolute = require('./util/dom').setAbsolute;
var setFullSize = require('./util/dom').setFullSize;
var setBlocking = require('./util/dom').setBlocking;

var tween = require('./util/tween');
var noop = require('./util/noop');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that the current scene has changed.
 * @event Viewer#sceneChange
 */

/**
 * Signals that the view of the current scene has changed. See
 * {@link View#event:change}.
 * @event Viewer#viewChange
 */

/**
 * @class Viewer
 * @classdesc
 *
 * A Viewer is a container for multiple {@link Scene scenes} to be displayed
 * inside a {@link Stage stage} contained in the DOM.
 *
 * Scenes may be created by calling {@link Viewer#createScene}. Except during a
 * scene switch, a single one of them, called the current scene, is visible.
 * Calling {@link Viewer#switchScene} sets the current scene and switches to it.
 *
 * @param {Element} domElement The DOM element to contain the stage.
 * @param {Object} opts Viewer creation options.
 * @param {Object} opts.controls Options to be passed to
 *     {@link registerDefaultControls}.
 * @param {Object} opts.stage Options to be passed to the {@link Stage}
 *     constructor.
 * @param {Object} opts.cursors Cursor options.
 * @param {Object} opts.cursors.drag Drag cursor options to be passed to the
 *     {@link ControlCursor} constructor.
 */
function Viewer(domElement, opts) {
  opts = opts || {};

  this._domElement = domElement;

  // Add `overflow: hidden` to the domElement.
  setOverflowHidden(domElement);

  // Create stage.
  this._stage = new WebGlStage(opts.stage);

  // Register the default renderers for the selected stage.
  registerDefaultRenderers(this._stage);

  // Add the stage element into the DOM.
  this._domElement.appendChild(this._stage.domElement());

  // Create control container.
  // Controls cannot be placed directly on the root DOM element because
  // Hammer.js will prevent click events from reaching the elements beneath.

  // The hotspot containers will be added inside the controls container.
  this._controlContainer = document.createElement('div');
  setAbsolute(this._controlContainer);
  setFullSize(this._controlContainer);

  // Prevent bounce scroll effect on iOS.
  // Applied only for iOS, as Android's events must have the default action to allow interaction with hotspots.
  if (browser.ios) {
    this._controlContainer.addEventListener('touchmove', function(event) {
      event.preventDefault();
    });
  }


  // Old IE does not detect mouse events on elements without background
  // Add a child element to the controls with full width, a background color
  // and opacity 0
  var controlCapture = document.createElement('div');
  setAbsolute(controlCapture);
  setFullSize(controlCapture);
  setBlocking(controlCapture);

  this._controlContainer.appendChild(controlCapture);
  domElement.appendChild(this._controlContainer);

  // Respond to window size changes.
  this._size = {};
  this.updateSize();
  this._updateSizeListener = this.updateSize.bind(this);
  window.addEventListener('resize', this._updateSizeListener);

  // Create render loop.
  this._renderLoop = new RenderLoop(this._stage);

  // Create the controls and register them with the render loop.
  this._controls = new Controls();
  this._controlMethods = registerDefaultControls(this._controls, this._controlContainer, opts.controls);
  this._controls.attach(this._renderLoop);

  // Expose HammerJS.
  this._hammerManagerTouch = HammerGestures.get(this._controlContainer, 'touch');
  this._hammerManagerMouse = HammerGestures.get(this._controlContainer, 'mouse');

  // Initialize drag cursor.
  this._dragCursor = new ControlCursor(this._controls, 'mouseViewDrag', domElement, opts.cursors && opts.cursors.drag || {});

  // Start the render loop.
  this._renderLoop.start();

  // Scene list.
  this._scenes = [];

  // The currently visible scene.
  // During a scene transition, this is the scene being switched to.
  this._currentScene = null;

  // The scene being switched from during a scene transition.
  // This is necessary to update the layers correctly when they are added or
  // removed during a transition.
  this._replacedScene = null;

  // The current transition.
  this._cancelCurrentTween = null;

  // The event listener fired when the current scene layers change.
  // This is attached to the correct scene whenever the current scene changes.
  this._layerChangeHandler = this._updateSceneLayers.bind(this);

  // The event listener fired when the current scene view changes.
  // This is attached to the correct scene whenever the current scene changes.
  this._viewChangeHandler = this.emit.bind(this, 'viewChange');

  // Setup the idle timer.
  // By default, the timer has an infinite duration so it does nothing.
  this._idleTimer = new Timer();
  this._idleTimer.start();

  // Reset the timer whenever the view changes.
  this._resetIdleTimerHandler = this._resetIdleTimer.bind(this);
  this.addEventListener('viewChange', this._resetIdleTimerHandler);

  // Start the idle movement when the idle timer fires.
  this._triggerIdleTimerHandler = this._triggerIdleTimer.bind(this);
  this._idleTimer.addEventListener('timeout', this._triggerIdleTimerHandler);

  // Stop an ongoing movement when the controls are activated or when the
  // scene changes.
  this._stopMovementHandler = this.stopMovement.bind(this);
  this._controls.addEventListener('active', this._stopMovementHandler);
  this.addEventListener('sceneChange', this._stopMovementHandler);

  // The currently programmed idle movement.
  this._idleMovement = null;
}

eventEmitter(Viewer);


/**
 * Destructor.
 */
Viewer.prototype.destroy = function() {

  window.removeEventListener('resize', this._updateSizeListener);

  if (this._currentScene) {
    this._removeSceneEventListeners(this._currentScene);
  }

  if (this._replacedScene) {
    this._removeSceneEventListeners(this._replacedScene);
  }

  this._dragCursor.destroy();

  for (var methodName in this._controlMethods) {
    this._controlMethods[methodName].destroy();
  }

  while (this._scenes.length) {
    this.destroyScene(this._scenes[0]);
  }

  this._domElement.removeChild(this._stage.domElement());

  this._stage.destroy();
  this._renderLoop.destroy();
  this._controls.destroy();
  this._controls = null;

  if (this._cancelCurrentTween) {
    this._cancelCurrentTween();
  }

  clearOwnProperties(this);
};


/**
 * Updates the stage size to fill the containing element.
 *
 * This method is automatically called when the browser window is resized.
 * Most clients won't need to explicitly call it to keep the size up to date.
 */
Viewer.prototype.updateSize = function() {
  var size = this._size;
  size.width = this._domElement.clientWidth;
  size.height = this._domElement.clientHeight;
  this._stage.setSize(size);
};


/**
 * Returns the underlying {@link Stage stage}.
 * @return {Stage}
 */
Viewer.prototype.stage = function() {
  return this._stage;
};


/**
 * Returns the underlying {@link RenderLoop render loop}.
 * @return {RenderLoop}
 */
Viewer.prototype.renderLoop = function() {
  return this._renderLoop;
};


/**
 * Returns the underlying {@link Controls controls}.
 * @return {Controls}
 */
Viewer.prototype.controls = function() {
  return this._controls;
};


/**
 * Returns the underlying DOM element.
 * @return {Element}
 */
Viewer.prototype.domElement = function() {
  return this._domElement;
};


/**
 * Creates a new {@link Scene scene} with a single layer and adds it to the
 * viewer.
 *
 * The current scene does not change. To switch to the scene, call
 * {@link Viewer#switchScene}.
 *
 * @param {Object} opts Scene creation options.
 * @param {View} opts.view The scene's underlying {@link View}.
 * @param {Source} opts.source The layer's underlying {@link Source}.
 * @param {Geometry} opts.geometry The layer's underlying {@link Geometry}.
 * @param {boolean} [opts.pinFirstLevel=false] Whether to pin the first level to
 *     provide a fallback of last resort, at the cost of memory consumption.
 * @param {Object} [opts.textureStoreOpts={}] Options to pass to the
 *     {@link TextureStore} constructor.
 * @param {Object} [opts.layerOpts={}] Options to pass to the {@link Layer}
 *     constructor.
 * @return {Scene}
 */
Viewer.prototype.createScene = function(opts) {
  opts = opts || {};

  var scene = this.createEmptyScene({ view: opts.view });

  scene.createLayer({
    source: opts.source,
    geometry: opts.geometry,
    pinFirstLevel: opts.pinFirstLevel,
    textureStoreOpts: opts.textureStoreOpts,
    layerOpts: opts.layerOpts
  });

  return scene;
};


/**
 * Creates a new {@link Scene scene} with no layers and adds it to the viewer.
 *
 * Layers may be added to the scene by calling {@link Scene#createLayer}.
 * However, if the scene has a single layer, it is simpler to call
 * {@link Viewer#createScene} instead of this method.
 *
 * The current scene does not change. To switch to the scene, call
 * {@link Viewer#switchScene}.
 *
 * @param {Object} opts Scene creation options.
 * @param {View} opts.view The scene's underlying {@link View}.
 * @return {Scene}
 */
Viewer.prototype.createEmptyScene = function(opts) {
  opts = opts || {};

  var scene = new Scene(this, opts.view);
  this._scenes.push(scene);

  return scene;
};


Viewer.prototype._updateSceneLayers = function() {
  var i;
  var layer;

  var stage = this._stage;
  var currentScene = this._currentScene;
  var replacedScene = this._replacedScene;

  var oldLayers = stage.listLayers();

  // The stage contains layers from at most two scenes: the current one, on top,
  // and the one currently being switched away from, on the bottom.
  var newLayers = [];
  if (replacedScene) {
    newLayers = newLayers.concat(replacedScene.listLayers());
  }
  if (currentScene) {
    newLayers = newLayers.concat(currentScene.listLayers());
  }

  // A single layer can be added or removed from the scene at a time.
  if (Math.abs(oldLayers.length - newLayers.length) !== 1) {
    throw new Error('Stage and scene out of sync');
  }

  if (newLayers.length < oldLayers.length) {
    // A layer was removed.
    for (i = 0; i < oldLayers.length; i++) {
      layer = oldLayers[i];
      if (newLayers.indexOf(layer) < 0) {
        this._removeLayerFromStage(layer);
        break;
      }
    }
  }
  if (newLayers.length > oldLayers.length) {
    // A layer was added.
    for (i = 0; i < newLayers.length; i++) {
      layer = newLayers[i];
      if (oldLayers.indexOf(layer) < 0) {
        this._addLayerToStage(layer, i);
      }
    }
  }

  // TODO: When in the middle of a scene transition, call the transition update
  // function immediately to prevent an added layer from flashing with the wrong
  // opacity.
};


Viewer.prototype._addLayerToStage = function(layer, i) {
  // Pin the first level to ensure a fallback while the layer is visible.
  // Note that this is distinct from the `pinFirstLevel` option passed to
  // createScene(), which pins the layer even when it's not visible.
  layer.pinFirstLevel();
  this._stage.addLayer(layer, i);
};


Viewer.prototype._removeLayerFromStage = function(layer) {
  this._stage.removeLayer(layer);
  layer.unpinFirstLevel();
  layer.textureStore().clearNotPinned();
};


Viewer.prototype._addSceneEventListeners = function(scene) {
  scene.addEventListener('layerChange', this._layerChangeHandler);
  scene.addEventListener('viewChange', this._viewChangeHandler);
};


Viewer.prototype._removeSceneEventListeners = function(scene) {
  scene.removeEventListener('layerChange', this._layerChangeHandler);
  scene.removeEventListener('viewChange', this._viewChangeHandler);
};


/**
 * Destroys a {@link Scene scene} and removes it from the viewer.
 * @param {Scene} scene
 */
Viewer.prototype.destroyScene = function(scene) {
  var i = this._scenes.indexOf(scene);
  if (i < 0) {
    throw new Error('No such scene in viewer');
  }

  var j;
  var layers;

  if (this._currentScene === scene) {
    // The destroyed scene is the current scene.
    // Remove event listeners, remove layers from stage and cancel transition.
    this._removeSceneEventListeners(scene);
    layers = scene.listLayers();
    for (j = 0; j < layers.length; j++) {
      this._removeLayerFromStage(layers[j]);
    }
    if (this._cancelCurrentTween) {
      this._cancelCurrentTween();
      this._cancelCurrentTween = null;
    }
    this._currentScene = null;
    this.emit('sceneChange');
  }

  if (this._replacedScene === scene) {
    // The destroyed scene is being switched away from.
    // Remove event listeners and remove layers from stage.
    this._removeSceneEventListeners(scene);
    layers = scene.listLayers();
    for (j = 0; j < layers.length; j++) {
      this._removeLayerFromStage(layers[j]);
    }
    this._replacedScene = null;
  }

  this._scenes.splice(i, 1);

  scene.destroy();
};


/**
 * Destroys all {@link Scene scenes} and removes them from the viewer.
 */
Viewer.prototype.destroyAllScenes = function() {
  while (this._scenes.length > 0) {
    this.destroyScene(this._scenes[0]);
  }
};


/**
 * Returns whether the viewer contains a {@link Scene scene}.
 * @param {Scene} scene
 * @return {boolean}
 */
Viewer.prototype.hasScene = function(scene) {
  return this._scenes.indexOf(scene) >= 0;
};


/**
 * Returns a list of all {@link Scene scenes}.
 * @return {Scene[]}
 */
Viewer.prototype.listScenes = function() {
  return [].concat(this._scenes);
};


/**
 * Returns the current {@link Scene scene}, or null if there isn't one.
 *
 * To change the current scene, call {@link Viewer#switchScene}.
 *
 * @return {Scene}
 */
Viewer.prototype.scene = function() {
  return this._currentScene;
};


/**
 * Returns the {@link View view} for the current {@link Scene scene}, or null
 * if there isn't one.
 * @return {View}
 */
Viewer.prototype.view = function() {
  var scene = this._currentScene;
  if (scene) {
    return scene.view();
  }
  return null;
};


/**
 * Tweens the {@link View view} for the current {@link Scene scene}.
 *
 * This method is equivalent to calling {@link Scene#lookTo} on the current
 * scene.
 *
 * @param {Object} opts Options to pass into {@link Scene#lookTo}.
 * @param {function} done Function to call when the tween is complete.
 */
Viewer.prototype.lookTo = function(params, opts, done) {
  // TODO: is it an error to call lookTo when no scene is displayed?
  var scene = this._currentScene;
  if (scene) {
    scene.lookTo(params, opts, done);
  }
};


/**
 * Starts a movement, possibly replacing the current movement.
 *
 * This method is equivalent to calling {@link Scene#startMovement} on the
 * current scene. If there is no current scene, this is a no-op.
 *
 * @param {function} fn The movement function.
 * @param {function} done Function to be called when the movement finishes or is
 *     interrupted.
 */
Viewer.prototype.startMovement = function(fn, done) {
  var scene = this._currentScene;
  if (!scene) {
    return;
  }
  scene.startMovement(fn, done);
};


/**
 * Stops the current movement.
 *
 * This method is equivalent to calling {@link Scene#stopMovement} on the
 * current scene. If there is no current scene, this is a no-op.
 */
Viewer.prototype.stopMovement = function() {
  var scene = this._currentScene;
  if (!scene) {
    return;
  }
  scene.stopMovement();
};


/**
 * Returns the current movement.
 *
 * This method is equivalent to calling {@link Scene#movement} on the
 * current scene. If there is no current scene, this is a no-op.
 *
 * @return {function}
 */
Viewer.prototype.movement = function() {
  var scene = this._currentScene;
  if (!scene) {
    return;
  }
  return scene.movement();
};


/**
 * Schedules an idle movement to be automatically started when the view remains
 * unchanged for the given timeout period.
 *
 * Changing the view while the idle movement is active stops the movement and
 * schedules it to start again after the same timeout period. To disable it
 * permanently, call with a null movement or an infinite timeout.
 *
 * @param {number} timeout Timeout period in milliseconds.
 * @param {function} movement Automatic movement function, or null to disable.
 */
Viewer.prototype.setIdleMovement = function(timeout, movement) {
  this._idleTimer.setDuration(timeout);
  this._idleMovement = movement;
};


/**
 * Stops the idle movement. It will be started again after the timeout set by
 * {@link Viewer#setIdleMovement}.
 */
Viewer.prototype.breakIdleMovement = function() {
  this.stopMovement();
  this._resetIdleTimer();
};


Viewer.prototype._resetIdleTimer = function() {
  this._idleTimer.start();
};


Viewer.prototype._triggerIdleTimer = function() {
  var idleMovement = this._idleMovement;
  if (!idleMovement) {
    return;
  }
  this.startMovement(idleMovement);
};


var defaultSwitchDuration = 1000;

function defaultTransitionUpdate(val, newScene, oldScene) {
  var layers = newScene.listLayers();
  layers.forEach(function(layer) {
    layer.mergeEffects({ opacity: val });
  });

  newScene._hotspotContainer.domElement().style.opacity = val;
}


/**
 * Switches to another {@link Scene scene} with a fade transition. This scene
 * becomes the current one.
 *
 * If a transition is already taking place, it is interrupted before the new one
 * starts.
 *
 * @param {Scene} newScene The scene to switch to.
 * @param {Object} opts Transition options.
 * @param {number} [opts.transitionDuration=1000] Transition duration, in
 *     milliseconds.
 * @param {number} [opts.transitionUpdate=defaultTransitionUpdate]
 *     Transition update function, with signature `f(t, newScene, oldScene)`.
 *     This function is called on each frame with `t` increasing from 0 to 1.
 *     An initial call with `t=0` and a final call with `t=1` are guaranteed.
 *     The default function sets the opacity of the new scene to `t`.
 * @param {function} done Function to call when the transition finishes or is
 *     interrupted. If the new scene is equal to the old one, no transition
 *     takes place, but this function is still called.
 */
Viewer.prototype.switchScene = function(newScene, opts, done) {
  var self = this;

  opts = opts || {};
  done = done || noop;

  var stage = this._stage;

  var oldScene = this._currentScene;

  // Do nothing if the target scene is the current one.
  if (oldScene === newScene) {
    done();
    return;
  }

  if (this._scenes.indexOf(newScene) < 0) {
    throw new Error('No such scene in viewer');
  }

  // Cancel an already ongoing transition. This ensures that the stage contains
  // layers from exactly one scene before the transition begins.
  if (this._cancelCurrentTween) {
    this._cancelCurrentTween();
    this._cancelCurrentTween = null;
  }

  var oldSceneLayers = oldScene ? oldScene.listLayers() : [];
  var newSceneLayers = newScene.listLayers();
  var stageLayers = stage.listLayers();

  // Check that the stage contains exactly as many layers as the current scene,
  // and that the top layer is the right one. If this test fails, either there
  // is a bug or the user tried to modify the stage concurrently.
  if (oldScene && ((stageLayers.length !== oldSceneLayers.length) ||
      (stageLayers.length > 1 && stageLayers[0] != oldSceneLayers[0]))) {
    throw new Error('Stage not in sync with viewer');
  }

  // Get the transition parameters.
  var duration = opts.transitionDuration != null ?
      opts.transitionDuration : defaultSwitchDuration;
  var update = opts.transitionUpdate != null ?
      opts.transitionUpdate : defaultTransitionUpdate;

  // Add new scene layers into the stage before starting the transition.
  for (var i = 0; i < newSceneLayers.length; i++) {
    this._addLayerToStage(newSceneLayers[i]);
  }

  // Update function to be called on every frame.
  function tweenUpdate(val) {
    update(val, newScene, oldScene);
  }

  // Once the transition is complete, remove old scene layers from the stage and
  // remove the event listeners. If the old scene was destroyed during the
  // transition, this has already been taken care of. Otherwise, we still need
  // to get a fresh copy of the scene's layers, since they might have changed
  // during the transition.
  function tweenDone() {
    if (self._replacedScene) {
      self._removeSceneEventListeners(self._replacedScene);
      oldSceneLayers = self._replacedScene.listLayers();
      for (var i = 0; i < oldSceneLayers.length; i++) {
        self._removeLayerFromStage(oldSceneLayers[i]);
      }
      self._replacedScene = null;
    }
    self._cancelCurrentTween = null;
    done();
  }

  // Store the cancelable for the transition.
  this._cancelCurrentTween = tween(duration, tweenUpdate, tweenDone);

  // Update the current and replaced scene.
  this._currentScene = newScene;
  this._replacedScene = oldScene;

  // Emit scene and view change events.
  this.emit('sceneChange');
  this.emit('viewChange');

  // Add event listeners to the new scene.
  // Note that event listeners can only be removed from the old scene once the
  // transition is complete, since layers might get added or removed in the
  // interim.
  this._addSceneEventListeners(newScene);
};


module.exports = Viewer;

},{"./RenderLoop":19,"./Scene":20,"./Timer":23,"./controls/ControlCursor":36,"./controls/Controls":37,"./controls/HammerGestures":41,"./controls/registerDefaultControls":47,"./renderers/registerDefaultRenderers":61,"./stages/WebGl":70,"./util/clearOwnProperties":76,"./util/dom":85,"./util/noop":92,"./util/tween":100,"bowser":1,"minimal-event-emitter":14}],25:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var StaticAsset = require('./Static');
var inherits = require('../util/inherits');
var eventEmitter = require('minimal-event-emitter');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class DynamicAsset
 * @implements Asset
 * @extends StaticAsset
 * @classdesc
 *
 * An {@link Asset} whose pixel contents may change.
 *
 * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} element The
 *     underlying pixel source.
 * @throws If the pixel source is unsupported.
 */
function DynamicAsset(element) {
  this.constructor.super_.call(this, element);
  this._timestamp = 0;
}

inherits(DynamicAsset, StaticAsset);
eventEmitter(DynamicAsset);

/**
 * Destructor.
 */
DynamicAsset.prototype.destroy = function() {
  clearOwnProperties(this);
};

DynamicAsset.prototype.timestamp = function() {
  return this._timestamp;
};

DynamicAsset.prototype.isDynamic = function() {
  return true;
};

/**
 * Marks the asset dirty, signaling that the contents of the underlying pixel
 * source have changed.
 *
 * @throws If the asset is not dynamic.
 */
DynamicAsset.prototype.markDirty = function() {
  this._timestamp++;
  this.emit('change');
};

module.exports = DynamicAsset;

},{"../util/clearOwnProperties":76,"../util/inherits":89,"./Static":26,"minimal-event-emitter":14}],26:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var global = require('../util/global');
var eventEmitter = require('minimal-event-emitter');
var clearOwnProperties = require('../util/clearOwnProperties');

var propertyMap = {
  HTMLImageElement: ['naturalWidth', 'naturalHeight'],
  HTMLCanvasElement: ['width', 'height'],
  ImageBitmap: ['width', 'height']
};

/**
 * @class StaticAsset
 * @implements Asset
 * @classdesc
 *
 * An {@link Asset} whose pixel contents never change.
 *
 * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} element The
 *     underlying pixel source.
 * @throws If the pixel source is unsupported.
 */
function StaticAsset(element) {
  var supported = false;
  for (var type in propertyMap) {
    if (global[type] && element instanceof global[type]) {
      supported = true;
      this._widthProp = propertyMap[type][0];
      this._heightProp = propertyMap[type][1];
      break;
    }
  }
  if (!supported) {
    throw new Error('Unsupported pixel source');
  }

  this._element = element;
}

eventEmitter(StaticAsset);

/**
 * Destructor.
 */
StaticAsset.prototype.destroy = function() {
  clearOwnProperties(this);
};

StaticAsset.prototype.element = function() {
  return this._element;
};

StaticAsset.prototype.width = function() {
  return this._element[this._widthProp];
};

StaticAsset.prototype.height = function() {
  return this._element[this._heightProp];
};

StaticAsset.prototype.timestamp = function() {
  return 0;
};

StaticAsset.prototype.isDynamic = function() {
  return false;
};

module.exports = StaticAsset;

},{"../util/clearOwnProperties":76,"../util/global":87,"minimal-event-emitter":14}],27:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaults = require('./util/defaults');

var defaultSpeed = 0.1;
var defaultAccel = 0.01;

var defaultOptions = {
  yawSpeed: defaultSpeed,
  pitchSpeed: defaultSpeed,
  fovSpeed: defaultSpeed,
  yawAccel: defaultAccel,
  pitchAccel: defaultAccel,
  fovAccel: defaultAccel,
  targetPitch: 0,
  targetFov: null
};

/**
 * @param {Object} opts
 * @param {Number} [opts.yawSpeed=0.1] Yaw maximum speed
 * @param {Number} [opts.pitchSpeed=0.1] Pitch maximum speed
 * @param {Number} [opts.fovSpeed=0.1] Fov maximum speed
 * @param {Number} [opts.yawAccel=0.01] Yaw acceleration
 * @param {Number} [opts.pitchAccel=0.01] Pitch acceleration
 * @param {Number} [opts.fovAccel=0.01] Fov acceleration
 * @param {Number} [opts.targetPitch=0] Value that pitch converges to. `null` means that the pitch will not change.
 * @param {Number} [opts.targetFov=null] Value that fov converges to. `null` means that the fov will not change.
 * @returns Movement function that can be passed to {@link Viewer#setIdleMovement} or {@link Scene#startMovement}
*/
function autorotate(opts) {

  opts = defaults(opts || {}, defaultOptions);

  var yawSpeed = opts.yawSpeed;
  var pitchSpeed = opts.pitchSpeed;
  var fovSpeed = opts.fovSpeed;
  var yawAccel = opts.yawAccel;
  var pitchAccel = opts.pitchAccel;
  var fovAccel = opts.fovAccel;
  var targetPitch = opts.targetPitch;
  var targetFov = opts.targetFov;

  return function start() {

    var lastTime = 0;
    var lastYawSpeed = 0;
    var lastPitchSpeed = 0;
    var lastFovSpeed = 0;

    var currentYawSpeed = 0;
    var currentPitchSpeed = 0;
    var currentFovSpeed = 0;

    var timeDelta;
    var yawDelta;
    var pitchDelta;
    var fovDelta;

    return function step(params, currentTime) {

      timeDelta = (currentTime - lastTime) / 1000;
      currentYawSpeed = Math.min(lastYawSpeed + timeDelta * yawAccel, yawSpeed);
      yawDelta = currentYawSpeed * timeDelta;
      params.yaw = params.yaw + yawDelta;

      if (targetPitch != null && params.pitch !== targetPitch) {
        var pitchThresh = 0.5 * lastPitchSpeed * lastPitchSpeed / pitchAccel;
        if (Math.abs(targetPitch - params.pitch) > pitchThresh) {
          // Acceleration phase
          currentPitchSpeed = Math.min(lastPitchSpeed + timeDelta * pitchAccel, pitchSpeed);
        } else {
          // Deceleration phase
          currentPitchSpeed = Math.max(lastPitchSpeed - timeDelta * pitchAccel, 0);
        }
        // currentPitchSpeed is the absolute value (>= 0)
        pitchDelta = currentPitchSpeed * timeDelta;
        if (targetPitch < params.pitch) {
          params.pitch = Math.max(targetPitch, params.pitch - pitchDelta);
        }
        if (targetPitch > params.pitch) {
          params.pitch = Math.min(targetPitch, params.pitch + pitchDelta);
        }
      }

      if (targetFov != null && params.fov !== targetPitch) {
        var fovThresh = 0.5 * lastFovSpeed * lastFovSpeed / fovAccel;
        if (Math.abs(targetFov - params.fov) > fovThresh) {
          // Acceleration phase
          currentFovSpeed = Math.min(lastFovSpeed + timeDelta * fovAccel, fovSpeed);
        } else {
          // Deceleration phase
          currentFovSpeed = Math.max(lastFovSpeed - timeDelta * fovAccel, 0);
        }
        // currentFovSpeed is the absolute value (>= 0)
        fovDelta = currentFovSpeed * timeDelta;
        if (targetFov < params.fov) {
          params.fov = Math.max(targetFov, params.fov - fovDelta);
        }
        if (targetFov > params.fov) {
          params.fov = Math.min(targetFov, params.fov + fovDelta);
        }
      }

      lastTime = currentTime;
      lastYawSpeed = currentYawSpeed;
      lastPitchSpeed = currentPitchSpeed;
      lastFovSpeed = currentFovSpeed;

      return params;

    };

  };

}

module.exports = autorotate;
},{"./util/defaults":81}],28:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

// An LruMap holds up to a maximum number of key-value pairs, ordered by their
// time of insertion. When the addition of a key-value pair would cause the
// capacity to be exceeded, the oldest key-value pair in the set is evicted.
// As a special case, an LruMap with zero capacity always rejects the insertion
// of a key-value pair.
//
// Keys must implement hash() and equals(). Note that the implementation doesn't
// currently use hash(), but a future version might.
function LruMap(capacity) {
  if (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 0) {
    throw new Error('LruMap: invalid capacity');
  }
  this._capacity = capacity;

  // Keys and values are stored in circular arrays ordered by decreasing age.
  // Start is the index of the oldest key/value and size is the number of valid
  // key/values; the region containing valid keys/values may wrap around.
  this._keys = new Array(this._capacity);
  this._values = new Array(this._capacity);
  this._start = 0;
  this._size = 0;
}

LruMap.prototype._index = function(i) {
  return mod(this._start + i, this._capacity);
};

// Returns the value associated to the specified key, or null if not found.
LruMap.prototype.get = function(key) {
  for (var i = 0; i < this._size; i++) {
    var existingKey = this._keys[this._index(i)];
    if (key.equals(existingKey)) {
      return this._values[this._index(i)];
    }
  }
  return null;
};

// Associates the specified value with the specified key, possibly replacing the
// currently associated value. The key-value pair becomes the newest. If the map
// is at capacity, the oldest key-value pair is removed. Returns the removed
// key, or null otherwise. If the capacity is zero, does nothing and returns
// the key.
LruMap.prototype.set = function(key, value) {
  if (this._capacity === 0) {
    return key;
  }
  this.del(key);
  var evictedKey =
      this._size === this._capacity ? this._keys[this._index(0)] : null;
  this._keys[this._index(this._size)] = key;
  this._values[this._index(this._size)] = value;
  if (this._size < this._capacity) {
    this._size++;
  } else {
    this._start = this._index(1);
  }
  return evictedKey;
};

// Removes the key-value pair associated with the specified key.
// Returns the removed value, or null if not found.
LruMap.prototype.del = function(key) {
  for (var i = 0; i < this._size; i++) {
    if (key.equals(this._keys[this._index(i)])) {
      var existingValue = this._values[this._index(i)];
      for (var j = i; j < this._size - 1; j++) {
        this._keys[this._index(j)] = this._keys[this._index(j + 1)];
        this._values[this._index(j)] = this._values[this._index(j + 1)];
      }
      this._size--;
      return existingValue;
    }
  }
  return null;
};

// Returns whether there is a value associated with the specified key.
LruMap.prototype.has = function(key) {
  for (var i = 0; i < this._size; i++) {
    if (key.equals(this._keys[this._index(i)])) {
      return true;
    }
  }
  return false;
};

// Returns the number of key-value pairs in the map.
LruMap.prototype.size = function() {
  return this._size;
};

// Removes all key-value pairs from the map.
LruMap.prototype.clear = function() {
  this._keys.length = 0;
  this._values.length = 0;
  this._start = 0;
  this._size = 0;
};

// Calls fn(key, value) for each item in the map, in an unspecified order.
// Returns the number of times fn was called.
// The result is unspecified if the map is mutated during iteration.
LruMap.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._size; i++) {
    fn(this._keys[this._index(i)], this._values[this._index(i)]);
    count += 1;
  }
  return count;
};

module.exports = LruMap;

},{"../util/mod":91}],29:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

// An LruSet holds up to a maximum number of elements, ordered by their time of
// insertion. When the addition of an element would cause the capacity to be
// exceeded, the oldest element in the set is evicted. As a special case, an
// LruSet with zero capacity always rejects the insertion of an element.
//
// Elements must implement hash() and equals(). Note that the implementation
// doesn't currently use hash(), but a future version might.
function LruSet(capacity) {
  if (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 0) {
    throw new Error('LruSet: invalid capacity');
  }
  this._capacity = capacity;

  // Elements are stored in a circular array ordered by decreasing age.
  // Start is the index of the oldest element and size is the number of valid
  // elements; the region containing valid elements may wrap around.
  this._elements = new Array(this._capacity);
  this._start = 0;
  this._size = 0;
}

LruSet.prototype._index = function(i) {
  return mod(this._start + i, this._capacity);
};

// Adds an element into the set, possibly replacing an equal element already in
// the set. The element becomes the newest. If the set is at capacity, the
// oldest element is removed. Returns the removed element if it does not equal
// the inserted element, or null otherwise. If the capacity is zero, does
// nothing and returns the element.
LruSet.prototype.add = function(element) {
  if (this._capacity === 0) {
    return element;
  }
  this.remove(element);
  var evictedElement =
      this._size === this._capacity ? this._elements[this._index(0)] : null;
  this._elements[this._index(this._size)] = element;
  if (this._size < this._capacity) {
    this._size++;
  } else {
    this._start = this._index(1);
  }
  return evictedElement;
};

// Removes an element from the set.
// Returns the removed element, or null if the element was not found.
LruSet.prototype.remove = function(element) {
  for (var i = 0; i < this._size; i++) {
    var existingElement = this._elements[this._index(i)];
    if (element.equals(existingElement)) {
      for (var j = i; j < this._size - 1; j++) {
        this._elements[this._index(j)] = this._elements[this._index(j + 1)];
      }
      this._size--;
      return existingElement;
    }
  }
  return null;
};

// Returns whether an element is in the set.
LruSet.prototype.has = function(element) {
  for (var i = 0; i < this._size; i++) {
    if (element.equals(this._elements[this._index(i)])) {
      return true;
    }
  }
  return false;
};

// Returns the number of elements in the set.
LruSet.prototype.size = function() {
  return this._size;
};

// Removes all elements from the set.
LruSet.prototype.clear = function() {
  this._elements.length = 0;
  this._start = 0;
  this._size = 0;
};

// Calls fn(element) for each element in the set, in an unspecified order.
// Returns the number of times fn was called.
// The result is unspecified if the set is mutated during iteration.
LruSet.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._size; i++) {
    fn(this._elements[this._index(i)]);
    count += 1;
  }
  return count;
};

module.exports = LruSet;

},{"../util/mod":91}],30:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

var defaultCapacity = 64;

// A map data structure for keys implementing hash() and equals() and arbitrary
// values. The capacity, if given, is just a hint; the map is allowed to exceed
// it, but performance may suffer.
function Map(capacity) {
  if (capacity != null &&
      (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 1)) {
    throw new Error('Map: invalid capacity');
  }
  this._capacity = capacity || defaultCapacity;

  this._keyBuckets = [];
  this._valBuckets = [];
  for (var i = 0; i < this._capacity; i++) {
    this._keyBuckets.push([]);
    this._valBuckets.push([]);
  }
  this._size = 0;
}

// Returns the value associated with the specified key, or null if not found.
Map.prototype.get = function(key) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      var valBucket = this._valBuckets[h];
      var existingValue = valBucket[i];
      return existingValue;
    }
  }
  return null;
};

// Associates the specified value with the specified key, possibly replacing the
// currently associated value.
// Returns the replaced value, or null if no value was replaced.
Map.prototype.set = function(key, val) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  var valBucket = this._valBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      var existingValue = valBucket[i];
      keyBucket[i] = key;
      valBucket[i] = val;
      return existingValue;
    }
  }
  keyBucket.push(key);
  valBucket.push(val);
  this._size++;
  return null;
};

// Removes the key-value pair associated with the specified key.
// Returns the removed value, or null if not found.
Map.prototype.del = function(key) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  var valBucket = this._valBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      var existingValue = valBucket[i];
      // Splice manually to avoid Array#splice return value allocation.
      for (var j = i; j < keyBucket.length - 1; j++) {
        keyBucket[j] = keyBucket[j+1];
        valBucket[j] = valBucket[j+1];
      }
      keyBucket.length = keyBucket.length - 1;
      valBucket.length = valBucket.length - 1;
      this._size--;
      return existingValue;
    }
  }
  return null;
};

// Returns whether there is a value associated with the specified key.
Map.prototype.has = function(key) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      return true;
    }
  }
  return false;
};

// Returns the number of key-value pairs in the map.
Map.prototype.size = function() {
  return this._size;
};

// Removes all key-value pairs from the map.
Map.prototype.clear = function() {
  for (var i = 0; i < this._capacity; i++) {
    this._keyBuckets[i].length = 0;
    this._valBuckets[i].length = 0;
  }
  this._size = 0;
};

// Calls fn(key, value) for each key-value pair in the map, in an unspecified
// order. Returns the number of times fn was called.
// The result is unspecified if the map is mutated during iteration.
Map.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._capacity; i++) {
    var keyBucket = this._keyBuckets[i];
    var valBucket = this._valBuckets[i];
    for (var j = 0; j < keyBucket.length; j++) {
      fn(keyBucket[j], valBucket[j]);
      count += 1;
    }
  }
  return count;
};

module.exports = Map;

},{"../util/mod":91}],31:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

var defaultCapacity = 64;

// A set data structure for elements implementing hash() and equals().
// The capacity, if given, is just a hint; the set is allowed to exceed it, but
// performance may suffer.
function Set(capacity) {
  if (capacity != null &&
      (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 1)) {
    throw new Error('Set: invalid capacity');
  }
  this._capacity = this._capacity || defaultCapacity;

  this._buckets = [];
  for (var i = 0; i < this._capacity; i++) {
    this._buckets.push([]);
  }
  this._size = 0;
}

// Adds an element, replacing an existing element.
// Returns the replaced element, or null if no element was replaced.
Set.prototype.add = function(element) {
  var h = mod(element.hash(), this._capacity);
  var bucket = this._buckets[h];
  for (var i = 0; i < bucket.length; i++) {
    var existingElement = bucket[i];
    if (element.equals(existingElement)) {
      bucket[i] = element;
      return existingElement;
    }
  }
  bucket.push(element);
  this._size++;
  return null;
};

// Removes an element.
// Returns the removed element, or null if the element was not found.
Set.prototype.remove = function(element) {
  var h = mod(element.hash(), this._capacity);
  var bucket = this._buckets[h];
  for (var i = 0; i < bucket.length; i++) {
    var existingElement = bucket[i];
    if (element.equals(existingElement)) {
      // Splice manually to avoid Array#splice return value allocation.
      for (var j = i; j < bucket.length - 1; j++) {
        bucket[j] = bucket[j+1];
      }
      bucket.length = bucket.length - 1;
      this._size--;
      return existingElement;
    }
  }
  return null;
};

// Returns whether an element is in the set.
Set.prototype.has = function(element) {
  var h = mod(element.hash(), this._capacity);
  var bucket = this._buckets[h];
  for (var i = 0; i < bucket.length; i++) {
    var existingElement = bucket[i];
    if (element.equals(existingElement)) {
      return true;
    }
  }
  return false;
};

// Returns the number of elements in the set.
Set.prototype.size = function() {
  return this._size;
};

// Removes all elements from the set.
Set.prototype.clear = function() {
  for (var i = 0; i < this._capacity; i++) {
    this._buckets[i].length = 0;
  }
  this._size = 0;
};

// Calls fn(element) for each element in the set, in an unspecified order.
// Returns the number of times fn was called.
// The result is unspecified if the set is mutated during iteration.
Set.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._capacity; i++) {
    var bucket = this._buckets[i];
    for (var j = 0; j < bucket.length; j++) {
      fn(bucket[j]);
      count += 1;
    }
  }
  return count;
};

module.exports = Set;

},{"../util/mod":91}],32:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WorkQueue = require('./WorkQueue');
var mod = require('../util/mod');


function WorkPool(opts) {
  this._concurrency = opts && opts.concurrency || 1;
  this._paused = opts && !!opts.paused || false;

  this._pool = [];
  for (var i = 0; i < this._concurrency; i++) {
    this._pool.push(new WorkQueue(opts));
  }

  this._next = 0;
}


WorkPool.prototype.length = function() {
  var len = 0;
  for (var i = 0; i < this._pool.length; i++) {
    len += this._pool[i].length();
  }
  return len;
};


WorkPool.prototype.push = function(fn, cb) {
  var i = this._next;
  var cancel = this._pool[i].push(fn, cb);
  this._next = mod(this._next + 1, this._concurrency);
  return cancel;
};


WorkPool.prototype.pause = function() {
  if (!this._paused) {
    this._paused = true;
    for (var i = 0; i < this._concurrency; i++) {
      this._pool[i].pause();
    }
  }
};


WorkPool.prototype.resume = function() {
  if (this._paused) {
    this._paused = false;
    for (var i = 0; i < this._concurrency; i++) {
      this._pool[i].resume();
    }
  }
};


module.exports = WorkPool;

},{"../util/mod":91,"./WorkQueue":33}],33:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var now = require('../util/now');


function WorkTask(fn, cb) {
  this.fn = fn;
  this.cb = cb;
  this.cfn = null;
}


function WorkQueue(opts) {
  this._queue = [];
  this._delay = opts && opts.delay || 0;
  this._paused = opts && !!opts.paused || false;
  this._currentTask = null;
  this._lastFinished = null;
}


WorkQueue.prototype.length = function() {
  return this._queue.length;
};


WorkQueue.prototype.push = function(fn, cb) {

  var task = new WorkTask(fn, cb);

  var cancel = this._cancel.bind(this, task);

  // Push the task into the queue.
  this._queue.push(task);

  // Run the task if idle.
  this._next();

  return cancel;

};


WorkQueue.prototype.pause = function() {
  if (!this._paused) {
    this._paused = true;
  }
};


WorkQueue.prototype.resume = function() {
  if (this._paused) {
    this._paused = false;
    this._next();
  }
};


WorkQueue.prototype._start = function(task) {

  // Consistency check.
  if (this._currentTask) {
    throw new Error('WorkQueue: called start while running task');
  }

  // Mark queue as busy, so that concurrent tasks wait.
  this._currentTask = task;

  // Execute the task.
  var finish = this._finish.bind(this, task);
  task.cfn = task.fn(finish);

  // Detect when a non-cancellable function has been queued.
  if (typeof task.cfn !== 'function') {
    throw new Error('WorkQueue: function is not cancellable');
  }

};


WorkQueue.prototype._finish = function(task) {

  var args = Array.prototype.slice.call(arguments, 1);

  // Consistency check.
  if (this._currentTask !== task) {
    throw new Error('WorkQueue: called finish on wrong task');
  }

  // Call the task callback on the return values.
  task.cb.apply(null, args);

  // Mark as not busy and record task finish time, then advance to next task.
  this._currentTask = null;
  this._lastFinished = now();
  this._next();

};


WorkQueue.prototype._cancel = function(task) {

  var args = Array.prototype.slice.call(arguments, 1);

  if (this._currentTask === task) {

    // Cancel running task. Because cancel passes control to the _finish
    // callback we passed into fn, the cleanup logic will be handled there.
    task.cfn.apply(null, args);

  } else {

    // Remove task from queue.
    var pos = this._queue.indexOf(task);
    if (pos >= 0) {
      this._queue.splice(pos, 1);
      task.cb.apply(null, args);
    }

  }

};


WorkQueue.prototype._next = function() {

  if (this._paused) {
    // Do not start tasks while paused.
    return;
  }

  if (!this._queue.length) {
    // No tasks to run.
    return;
  }

  if (this._currentTask) {
    // Will be called again when the current task finishes.
    return;
  }

  if (this._lastFinished != null) {
    var elapsed = now() - this._lastFinished;
    var remaining = this._delay - elapsed;
    if (remaining > 0) {
      // Too soon. Run again after the inter-task delay.
      setTimeout(this._next.bind(this), remaining);
      return;
    }
  }

  // Run the next task.
  var task = this._queue.shift();
  this._start(task);

};


module.exports = WorkQueue;

},{"../util/now":93}],34:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var vec4 = require('gl-matrix').vec4;
var mat4 = require('gl-matrix').mat4;

/**
 * Helper functions for color transformation {@link Effects}.
 *
 * References:
 *
 *   - [ColorMatrix Guide](http://docs.rainmeter.net/tips/colormatrix-guide)
 *   - [Matrix Operations for Image Processing](http://www.graficaobscura.com/matrix/index.html)
 *   - [WebGLImageFilter](https://github.com/phoboslab/WebGLImageFilter)
 *   - [glfx.js](https://github.com/evanw/glfx.js)
 *
 * @namespace colorEffects
 */

/**
 * A vector and matrix corresponding to an identity transformation.
 *
 * @param {Object} result Object to store result
 * @param {vec4} result.colorOffset Array with zeroes.
 * @param {mat4} result.colorMatrix Identity matrix.
 *
 * @memberof colorEffects
 */
function identity(resultArg) {
  var result = resultArg || {};
  result.colorOffset = result.colorOffset || vec4.create();
  result.colorMatrix = result.colorMatrix || mat4.create();
  return result;
}

/**
 * Apply color effects to a single pixel
 *
 * @param {vec4} pixel Values in range [0,1]
 * @param {Object} effect
 * @param {vec4} effect.colorOffset
 * @param {mat4} effect.colorMatrix
 * @param {vec4} result Object to store result
 *
 * @memberof colorEffects
 */
function applyToPixel(pixel, effect, result) {
  vec4TransformMat4Transposed(result, pixel, effect.colorMatrix);
  vec4.add(result, result, effect.colorOffset);
}

// Oddly, the colorTransform matrix needs to be transposed to be used with
// vec4.transformMat4. It is strange that transformMat4 dosn't work the same
// way as multiplying on the shader.
// TODO: investigate this further
function vec4TransformMat4Transposed(out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[1] * y + m[2] * z + m[3] * w;
  out[1] = m[4] * x + m[5] * y + m[6] * z + m[7] * w;
  out[2] = m[8] * x + m[9] * y + m[10] * z + m[11] * w;
  out[3] = m[12] * x + m[13] * y + m[14] * z + m[15] * w;
  return out;
}

/**
 * Apply color effects to an ImageData
 *
 * @param {ImageData} imageData This object will be mutated
 * @param {Object} effect
 * @param {vec4} effect.colorOffset
 * @param {mat4} effect.colorMatrix
 *
 * @memberof colorEffects
 */
var tmpPixel = vec4.create();
function applyToImageData(imageData, effect) {
  var width = imageData.width;
  var height = imageData.height;
  var data = imageData.data;

  for(var i = 0; i < width * height; i++) {
    vec4.set(tmpPixel, data[i*4+0]/255, data[i*4+1]/255, data[i*4+2]/255, data[i*4+3]/255);
    applyToPixel(tmpPixel, effect, tmpPixel);
    data[i*4+0] = tmpPixel[0]*255;
    data[i*4+1] = tmpPixel[1]*255;
    data[i*4+2] = tmpPixel[2]*255;
    data[i*4+3] = tmpPixel[3]*255;
  }
}

module.exports = {
  identity: identity,
  applyToPixel: applyToPixel,
  applyToImageData: applyToImageData
};

},{"gl-matrix":3}],35:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var now = require('../util/now');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class ControlComposer
 * @classdesc
 *
 * Combines changes in parameters triggered by multiple {@link ControlMethod}
 * instances.
 *
 * @listens ControlMethod#parameterDynamics
 */
function ControlComposer(opts) {
  opts = opts || {};

  this._methods = [];

  this._parameters = [ 'x' ,'y', 'axisScaledX', 'axisScaledY', 'zoom', 'yaw', 'pitch', 'roll' ];

  this._now = opts.nowForTesting || now;

  this._composedOffsets = { };

  this._composeReturn = { offsets: this._composedOffsets, changing: null };
}

eventEmitter(ControlComposer);


ControlComposer.prototype.add = function(instance) {
  if (this.has(instance)) {
    return;
  }

  var dynamics = {};
  this._parameters.forEach(function(parameter) {
    dynamics[parameter] = {
      dynamics: new Dynamics(),
      time: null
    };
  });

  var parameterDynamicsHandler = this._updateDynamics.bind(this, dynamics);

  var method = {
    instance: instance,
    dynamics: dynamics,
    parameterDynamicsHandler: parameterDynamicsHandler
  };

  instance.addEventListener('parameterDynamics', parameterDynamicsHandler);

  this._methods.push(method);
};


ControlComposer.prototype.remove = function(instance) {
  var index = this._indexOfInstance(instance);
  if (index >= 0) {
    var method = this._methods.splice(index, 1)[0];
    method.instance.removeEventListener('parameterDynamics', method.parameterDynamicsHandler);
  }
};


ControlComposer.prototype.has = function(instance) {
  return this._indexOfInstance(instance) >= 0;
};


ControlComposer.prototype._indexOfInstance = function(instance) {
  for (var i = 0; i < this._methods.length; i++) {
    if (this._methods[i].instance === instance) {
      return i;
    }
  }
  return -1;
};


ControlComposer.prototype.list = function() {
  var instances = [];
  for (var i = 0; i < this._methods.length; i++) {
    instances.push(this._methods[i].instance);
  }
  return instances;
};


ControlComposer.prototype._updateDynamics = function(storedDynamics, parameter, dynamics) {
  var parameterDynamics = storedDynamics[parameter];

  if (!parameterDynamics) {
    throw new Error("Unknown control parameter " + parameter);
  }

  var newTime = this._now();
  parameterDynamics.dynamics.update(dynamics, (newTime - parameterDynamics.time)/1000);
  parameterDynamics.time = newTime;

  this.emit('change');
};


ControlComposer.prototype._resetComposedOffsets = function() {
  for (var i = 0; i < this._parameters.length; i++) {
    this._composedOffsets[this._parameters[i]] = 0;
  }
};


ControlComposer.prototype.offsets = function() {
  var parameter;
  var changing = false;

  var currentTime = this._now();

  this._resetComposedOffsets();

  for (var i = 0; i < this._methods.length; i++) {
    var methodDynamics = this._methods[i].dynamics;

    for (var p = 0; p < this._parameters.length; p++) {
      parameter = this._parameters[p];
      var parameterDynamics = methodDynamics[parameter];
      var dynamics = parameterDynamics.dynamics;


      // Add offset to composed offset
      if (dynamics.offset != null) {
        this._composedOffsets[parameter] += dynamics.offset;
        // Reset offset
        dynamics.offset = null;
      }

      // Calculate offset from velocity and add it
      var elapsed = (currentTime - parameterDynamics.time)/1000;
      var offsetFromVelocity = dynamics.offsetFromVelocity(elapsed);

      if(offsetFromVelocity) {
        this._composedOffsets[parameter] += offsetFromVelocity;
      }

      // Update velocity on dynamics
      var currentVelocity = dynamics.velocityAfter(elapsed);
      dynamics.velocity = currentVelocity;

      // If there is still a velocity, set changing
      if(currentVelocity) {
        changing = true;
      }

      parameterDynamics.time = currentTime;
    }
  }

  this._composeReturn.changing = changing;
  return this._composeReturn;
};


ControlComposer.prototype.destroy = function() {
  var instances = this.list();
  for (var i = 0; i < instances.length; i++) {
    this.remove(instances[i]);
  }

  clearOwnProperties(this);
};


module.exports = ControlComposer;

},{"../util/clearOwnProperties":76,"../util/now":93,"./Dynamics":39,"minimal-event-emitter":14}],36:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaults = require('../util/defaults');
var clearOwnProperties = require('../util/clearOwnProperties');

var defaultOpts = {
  active: 'move',
  inactive: 'default',
  disabled: 'default'
};

/**
 * @class ControlCursor
 * @classdesc
 *
 * Sets the CSS cursor on a DOM element according to the state of a
 * {@link ControlMethod}.
 *
 * @param {Controls} controls Controls instance containing the control method.
 * @param {string} id ID of the control method.
 * @param {Element} element DOM element where the cursor should be set.
 * @param {Object} opts The control cursors. Each field must be a valid value
 *     for the `cursor` CSS property.
 * @param {string} [opts.active='move'] Cursor to set when the control method
 *     is enabled and active.
 * @param {string} [opts.inactive='default'] Cursor to set when the control
 *     method is enabled and inactive.
 * @param {string} [opts.disabled='default'] Cursor to set when the control
 *     method is disabled.
 */
function ControlCursor(controls, id, element, opts) {
  opts = defaults(opts || {}, defaultOpts);

  // TODO: This class may misbehave if the control method is unregistered and a
  // different control method is registered under the same id.

  this._element = element;
  this._controls = controls;
  this._id = id;

  this._attached = false;

  this._setActiveCursor = this._setCursor.bind(this, opts.active);
  this._setInactiveCursor = this._setCursor.bind(this, opts.inactive);
  this._setDisabledCursor = this._setCursor.bind(this, opts.disabled);
  this._setOriginalCursor = this._setCursor.bind(this, this._element.style.cursor);

  this._updateAttachmentHandler = this._updateAttachment.bind(this);

  controls.addEventListener('methodEnabled', this._updateAttachmentHandler);
  controls.addEventListener('methodDisabled', this._updateAttachmentHandler);
  controls.addEventListener('enabled', this._updateAttachmentHandler);
  controls.addEventListener('disabled', this._updateAttachmentHandler);

  this._updateAttachment();
}

/**
 * Destructor.
 */
ControlCursor.prototype.destroy = function() {
  this._detachFromControlMethod(this._controls.method(this._id));
  this._setOriginalCursor();

  this._controls.removeEventListener('methodEnabled',
      this._updateAttachmentHandler);
  this._controls.removeEventListener('methodDisabled',
      this._updateAttachmentHandler);
  this._controls.removeEventListener('enabled',
      this._updateAttachmentHandler);
  this._controls.removeEventListener('disabled',
      this._updateAttachmentHandler);

  clearOwnProperties(this);
};

ControlCursor.prototype._updateAttachment = function() {
  var controls = this._controls;
  var id = this._id;
  if (controls.enabled() && controls.method(id).enabled) {
    this._attachToControlMethod(controls.method(id));
  } else {
    this._detachFromControlMethod(controls.method(id));
  }
};

ControlCursor.prototype._attachToControlMethod = function(controlMethod) {
  if (!this._attached) {
    controlMethod.instance.addEventListener('active', this._setActiveCursor);
    controlMethod.instance.addEventListener('inactive', this._setInactiveCursor);

    if (controlMethod.active) {
      this._setActiveCursor();
    } else {
      this._setInactiveCursor();
    }

    this._attached = true;
  }
};

ControlCursor.prototype._detachFromControlMethod = function(controlMethod) {
  if (this._attached) {
    controlMethod.instance.removeEventListener('active', this._setActiveCursor);
    controlMethod.instance.removeEventListener('inactive', this._setInactiveCursor);

    this._setDisabledCursor();

    this._attached = false;
  }
};

ControlCursor.prototype._setCursor = function(cursor) {
  this._element.style.cursor = cursor;
}

module.exports = ControlCursor;

},{"../util/clearOwnProperties":76,"../util/defaults":81}],37:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Composer = require('./Composer');
var clearOwnProperties = require('../util/clearOwnProperties');

var debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.controls;

/**
 * @class Controls
 * @classdesc
 *
 * Set of controls which affect a view (e.g. keyboard, touch)
 *
 * {@link ControlMethod} instances can be registered on this class. The methods
 * are then combined to calculate the final parameters to change the {@link View}.
 *
 * Controls is attached to a {@link RenderLoop}. Currently it affects the
 * {@link view} of all {@link Layer} on the {@link Stage} of the
 * {@link RenderLoop} it is attached to. A more flexible API may be provided
 * in the future.
 *
 * The ControlMethod instances are registered with an id and may be enabled,
 * disabled and unregistered using that id. The whole Control can also be
 * enabled or disabled.
 *
 */
function Controls(opts) {
  opts = opts || {};

  this._methods = {};
  this._methodGroups = {};
  this._composer = new Composer();

  // Whether the controls are enabled.
  this._enabled = (opts && opts.enabled) ? !!opts.enabled : true;

  // How many control methods are enabled and in the active state.
  this._activeCount = 0;

  this.updatedViews_ = [];

  this._attachedRenderLoop = null;
}

eventEmitter(Controls);

/**
 * Destructor.
 */
Controls.prototype.destroy = function() {
  this.detach();
  this._composer.destroy();
  clearOwnProperties(this);
};


/**
 * @return {ControlMethod[]} List of registered @{link ControlMethod instances}
 */
Controls.prototype.methods = function() {
  var obj = {};
  for (var id in this._methods) {
    obj[id] = this._methods[id];
  }
  return obj;
};

/**
 * @param {String} id
 * @return {ControlMethod}
 */
Controls.prototype.method = function(id) {
  return this._methods[id];
};

/**
 * @param {String} id
 * @param {ControlMethod} instance
 * @param {Boolean} [enable=false]
 */
Controls.prototype.registerMethod = function(id, instance, enable) {
  if (this._methods[id]) {
    throw new Error('Control method already registered with id ' + id);
  }

  this._methods[id] = {
    instance: instance,
    enabled: false,
    active: false,
    activeHandler: this._handleActive.bind(this, id),
    inactiveHandler: this._handleInactive.bind(this, id)
  };

  if(enable) {
    this.enableMethod(id, instance);
  }
};


/**
 * @param {String} id
 */
Controls.prototype.unregisterMethod = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('No control method registered with id ' + id);
  }
  if (method.enabled) {
    this.disableMethod(id);
  }
  delete this._methods[id];
};

/**
 * @param {String} id
 */
Controls.prototype.enableMethod = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('No control method registered with id ' + id);
  }
  if (method.enabled) {
    return;
  }
  method.enabled = true;
  if (method.active) {
    this._incrementActiveCount();
  }
  this._listen(id);
  this._updateComposer();
  this.emit('methodEnabled', id);
};


/**
 * @param {String} id
 */
Controls.prototype.disableMethod = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('No control method registered with id ' + id);
  }
  if (!method.enabled) {
    return;
  }
  method.enabled = false;
  if (method.active) {
    this._decrementActiveCount();
  }
  this._unlisten(id);
  this._updateComposer();
  this.emit('methodDisabled', id);
};


/**
 * Create a method group, which can be used to more conveniently enable or
 * disable several control methods at once
 * @param {String} groupId
 * @param {String[]} methodIds
 */
Controls.prototype.addMethodGroup = function(groupId, methodIds) {
  this._methodGroups[groupId] = methodIds;
}

/**
 * @param {String} groupId
 */
Controls.prototype.removeMethodGroup = function(id) {
  delete this._methodGroups[id];
}

/**
 * @return {ControlMethodGroup[]} List of control method groups
 */
Controls.prototype.methodGroups = function() {
  var obj = {};
  for (var id in this._methodGroups) {
    obj[id] = this._methodGroups[id];
  }
  return obj;
}

/**
 * Enables all the control methods in the group
 * @param {String} groupId
 */
Controls.prototype.enableMethodGroup = function(id) {
  var self = this;
  self._methodGroups[id].forEach(function(methodId) {
    self.enableMethod(methodId);
  });
}

/**
 * Disables all the control methods in the group
 * @param {String} groupId
 */
Controls.prototype.disableMethodGroup = function(id) {
  var self = this;
  self._methodGroups[id].forEach(function(methodId) {
    self.disableMethod(methodId);
  });
}

/**
 * @returns {Boolean}
 */
Controls.prototype.enabled = function() {
  return this._enabled;
};

/**
 * Enables the controls
 */
Controls.prototype.enable = function() {
  if (this._enabled) {
    return;
  }
  this._enabled = true;
  if (this._activeCount > 0) {
    this.emit('active');
  }
  this.emit('enabled');
  this._updateComposer();
};


/**
 * Disables the controls
 */
Controls.prototype.disable = function() {
  if (!this._enabled) {
    return;
  }
  this._enabled = false;
  if (this._activeCount > 0) {
    this.emit('inactive');
  }
  this.emit('disabled');
  this._updateComposer();
};



/**
 * Attaches the controls to a {@link RenderLoop}. The RenderLoop will be woken
 * up when the controls are activated
 *
 * @param {RenderLoop}
 */
Controls.prototype.attach = function(renderLoop) {
  if (this._attachedRenderLoop) {
    this.detach();
  }

  this._attachedRenderLoop = renderLoop;
  this._beforeRenderHandler = this._updateViewsWithControls.bind(this);
  this._changeHandler = renderLoop.renderOnNextFrame.bind(renderLoop);

  this._attachedRenderLoop.addEventListener('beforeRender', this._beforeRenderHandler);
  this._composer.addEventListener('change', this._changeHandler);
};

/**
 * Detaches the controls
 */
Controls.prototype.detach = function() {
  if (!this._attachedRenderLoop) {
    return;
  }

  this._attachedRenderLoop.removeEventListener('beforeRender', this._beforeRenderHandler);
  this._composer.removeEventListener('change', this._changeHandler);

  this._beforeRenderHandler = null;
  this._changeHandler = null;
  this._attachedRenderLoop = null;
};

/**
 * @param {Boolean}
 */
Controls.prototype.attached = function() {
  return this._attachedRenderLoop != null;
};


Controls.prototype._listen = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  method.instance.addEventListener('active', method.activeHandler);
  method.instance.addEventListener('inactive', method.inactiveHandler);
};


Controls.prototype._unlisten = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  method.instance.removeEventListener('active', method.activeHandler);
  method.instance.removeEventListener('inactive', method.inactiveHandler);
};


Controls.prototype._handleActive = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  if (!method.enabled) {
    throw new Error('Should not receive event from disabled control method');
  }
  if (!method.active) {
    method.active = true;
    this._incrementActiveCount();
  }
};


Controls.prototype._handleInactive = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  if (!method.enabled) {
    throw new Error('Should not receive event from disabled control method');
  }
  if (method.active) {
    method.active = false;
    this._decrementActiveCount();
  }
};


Controls.prototype._incrementActiveCount = function() {
  this._activeCount++;
  if (debug) {
    this._checkActiveCount();
  }
  if (this._enabled && this._activeCount === 1) {
    this.emit('active');
  }
};


Controls.prototype._decrementActiveCount = function() {
  this._activeCount--;
  if (debug) {
    this._checkActiveCount();
  }
  if (this._enabled && this._activeCount === 0) {
    this.emit('inactive');
  }
};


Controls.prototype._checkActiveCount = function() {
  var count = 0;
  for (var id in this._methods) {
    var method = this._methods[id];
    if (method.enabled && method.active) {
      count++;
    }
  }
  if (count != this._activeCount) {
    throw new Error('Bad control state');
  }
};


Controls.prototype._updateComposer = function() {
  var composer = this._composer;

  for (var id in this._methods) {
    var method = this._methods[id];
    var enabled = this._enabled && method.enabled;

    if (enabled && !composer.has(method.instance)) {
      composer.add(method.instance);
    }
    if (!enabled && composer.has(method.instance)) {
      composer.remove(method.instance);
    }
  }
};


Controls.prototype._updateViewsWithControls = function() {
  var controlData = this._composer.offsets();
  if (controlData.changing) {
    this._attachedRenderLoop.renderOnNextFrame();
  }

  // Update each view at most once, even when shared by multiple layers.
  // The number of views is expected to be small, so use an array to keep track.
  this.updatedViews_.length = 0;

  var layers = this._attachedRenderLoop.stage().listLayers();
  for (var i = 0; i < layers.length; i++) {
    var view = layers[i].view();
    if (this.updatedViews_.indexOf(view) < 0) {
      layers[i].view().updateWithControlParameters(controlData.offsets);
      this.updatedViews_.push(view);
    }
  }
};


module.exports = Controls;

},{"../util/clearOwnProperties":76,"./Composer":35,"minimal-event-emitter":14}],38:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var HammerGestures = require('./HammerGestures');
var defaults = require('../util/defaults');
var maxFriction = require('./util').maxFriction;
var clearOwnProperties = require('../util/clearOwnProperties');

var defaultOptions = {
  friction: 6,
  maxFrictionTime: 0.3
};

var debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.controls;

/**
 * @class DragControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Controls the view by clicking/tapping and dragging.
 *
 * @param {Element} element Element to listen for events.
 * @param {string} pointerType Which Hammer.js pointer type to use (e.g.
 * `mouse` or `touch`).
 * @param {Object} opts
 * @param {number} opts.friction
 * @param {number} opts.maxFrictionTime
 */
function DragControlMethod(element, pointerType, opts) {
  this._element = element;

  this._opts = defaults(opts || {}, defaultOptions);

  this._startEvent = null;
  this._lastEvent = null;

  this._active = false;

  this._dynamics = {
    x: new Dynamics(),
    y: new Dynamics()
  };

  this._hammer = HammerGestures.get(element, pointerType);

  this._hammer.on("hammer.input", this._handleHammerEvent.bind(this));

  this._hammer.on('panstart', this._handleStart.bind(this));
  this._hammer.on('panmove', this._handleMove.bind(this));
  this._hammer.on('panend', this._handleEnd.bind(this));
  this._hammer.on('pancancel', this._handleEnd.bind(this));

}

eventEmitter(DragControlMethod);

/**
 * Destructor.
 */
DragControlMethod.prototype.destroy = function() {
  this._hammer.release();
  clearOwnProperties(this);
};

DragControlMethod.prototype._handleHammerEvent = function(e) {
  if (e.isFirst) {
    if (debug && this._active) {
      throw new Error('DragControlMethod active detected when already active');
    }
    this._active = true;
    this.emit('active');
  }
  if (e.isFinal) {
    if (debug && !this._active) {
      throw new Error('DragControlMethod inactive detected when already inactive');
    }
    this._active = false;
    this.emit('inactive');
  }
};

DragControlMethod.prototype._handleStart = function(e) {
  // Prevent this event from dragging other DOM elements, causing
  // unexpected behavior on Chrome.
  e.preventDefault();

  this._startEvent = e;
};


DragControlMethod.prototype._handleMove = function(e) {
  // Prevent this event from dragging other DOM elements, causing
  // unexpected behavior on Chrome.
  e.preventDefault();

  if (this._startEvent) {
    this._updateDynamicsMove(e);
    this.emit('parameterDynamics', 'axisScaledX', this._dynamics.x);
    this.emit('parameterDynamics', 'axisScaledY', this._dynamics.y);
  }
};


DragControlMethod.prototype._handleEnd = function(e) {
  // Prevent this event from dragging other DOM elements, causing
  // unexpected behavior on Chrome.
  e.preventDefault();

  if (this._startEvent) {
    this._updateDynamicsRelease(e);
    this.emit('parameterDynamics', 'axisScaledX', this._dynamics.x);
    this.emit('parameterDynamics', 'axisScaledY', this._dynamics.y);
  }

  this._startEvent = false;
  this._lastEvent = false;
};


DragControlMethod.prototype._updateDynamicsMove = function(e) {
  var x = e.deltaX;
  var y = e.deltaY;

  // When a second finger touches the screen, panstart sometimes has a large
  // offset at start; subtract that offset to prevent a sudden jump.
  var eventToSubtract = this._lastEvent || this._startEvent;

  if (eventToSubtract) {
    x -= eventToSubtract.deltaX;
    y -= eventToSubtract.deltaY;
  }

  var elementRect = this._element.getBoundingClientRect();
  var width = elementRect.right - elementRect.left;
  var height = elementRect.bottom - elementRect.top;

  x /= width;
  y /= height;

  this._dynamics.x.reset();
  this._dynamics.y.reset();
  this._dynamics.x.offset = -x;
  this._dynamics.y.offset = -y;

  this._lastEvent = e;
};


var tmpReleaseFriction = [ null, null ];
DragControlMethod.prototype._updateDynamicsRelease = function(e) {
  var elementRect = this._element.getBoundingClientRect();
  var width = elementRect.right - elementRect.left;
  var height = elementRect.bottom - elementRect.top;

  var x = 1000 * e.velocityX / width;
  var y = 1000 * e.velocityY / height;

  this._dynamics.x.reset();
  this._dynamics.y.reset();
  this._dynamics.x.velocity = x;
  this._dynamics.y.velocity = y;

  maxFriction(this._opts.friction, this._dynamics.x.velocity, this._dynamics.y.velocity, this._opts.maxFrictionTime, tmpReleaseFriction);
  this._dynamics.x.friction = tmpReleaseFriction[0];
  this._dynamics.y.friction = tmpReleaseFriction[1];
};


module.exports = DragControlMethod;

},{"../util/clearOwnProperties":76,"../util/defaults":81,"./Dynamics":39,"./HammerGestures":41,"./util":48,"minimal-event-emitter":14}],39:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @class Dynamics
 * @classdesc
 *
 * Represents how a control parameter changes. Used in the events emitted by
 * {@link ControlMethod}.
 *
 * @property {number} offset Parameter changed by a fixed value
 * @property {number} velocity Parameter is changing at this velocity
 * @property {number} friction The velocity will decrease at this rate
 */
function Dynamics() {
  this.velocity = null;
  this.friction = null;
  this.offset = null;
}

Dynamics.equals = function(d1, d2) {
  return d1.velocity === d2.velocity && d1.friction === d2.friction && d1.offset === d2.offset;
};

Dynamics.prototype.equals = function(other) {
  return Dynamics.equals(this, other);
};

Dynamics.prototype.update = function(other, elapsed) {
  if (other.offset) {
    // If other has an offset, make this.offset a number instead of null
    this.offset = this.offset || 0;
    this.offset += other.offset;
  }

  var offsetFromVelocity = this.offsetFromVelocity(elapsed);
  if (offsetFromVelocity) {
    // If there is an offset to add from the velocity, make this offset a number instead of null
    this.offset = this.offset || 0;
    this.offset += offsetFromVelocity;
  }

  this.velocity = other.velocity;
  this.friction = other.friction;
};

Dynamics.prototype.reset = function() {
  this.velocity = null;
  this.friction = null;
  this.offset = null;
};


Dynamics.prototype.velocityAfter = function(elapsed) {
  if (!this.velocity) {
    return null;
  }
  if (this.friction) {
    return decreaseAbs(this.velocity, this.friction *elapsed);
  }
  return this.velocity;
};

Dynamics.prototype.offsetFromVelocity = function(elapsed) {
  elapsed = Math.min(elapsed, this.nullVelocityTime());

  var velocityEnd = this.velocityAfter(elapsed);
  var averageVelocity = (this.velocity + velocityEnd) / 2;

  return averageVelocity * elapsed;
};


Dynamics.prototype.nullVelocityTime = function() {
  if (this.velocity == null) {
    return 0;
  }
  if (this.velocity && !this.friction) {
    return Infinity;
  }
  return Math.abs(this.velocity / this.friction);
};

function decreaseAbs(num, dec) {
  if (num < 0) {
    return Math.min(0, num + dec);
  }
  if (num > 0) {
    return Math.max(0, num - dec);
  }
  return 0;
}

module.exports = Dynamics;

},{}],40:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class ElementPressControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Sets the velocity and friction of a single parameter by pressing and
 * unpressing a DOM element.
 *
 * @param {Element} element Element which activates the method when pressed
 * @param {string} parameter The parameter to be controlled (e.g. `x`, `y` or `zoom`)
 * @param {number} velocity Velocity at which the parameter changes. Use a
 * negative number for opposite direction
 * @param {number} friction Friction at which the parameter stops
*/
function ElementPressControlMethod(element, parameter, velocity, friction) {
  if(!element) {
    throw new Error("ElementPressControlMethod: element must be defined");
  }
  if(!parameter) {
    throw new Error("ElementPressControlMethod: parameter must be defined");
  }
  if(!velocity) {
    throw new Error("ElementPressControlMethod: velocity must be defined");
  }
  if(!friction) {
    throw new Error("ElementPressControlMethod: friction must be defined");
  }

  this._element = element;

  this._pressHandler = this._handlePress.bind(this);
  this._releaseHandler = this._handleRelease.bind(this);

  element.addEventListener('mousedown', this._pressHandler);
  element.addEventListener('mouseup', this._releaseHandler);
  element.addEventListener('mouseleave', this._releaseHandler);
  element.addEventListener('touchstart', this._pressHandler);
  element.addEventListener('touchmove', this._releaseHandler);
  element.addEventListener('touchend', this._releaseHandler);

  this._parameter = parameter;
  this._velocity = velocity;
  this._friction = friction;
  this._dynamics = new Dynamics();

  this._pressing = false;
}
eventEmitter(ElementPressControlMethod);

/**
 * Destructor.
 */
ElementPressControlMethod.prototype.destroy = function() {
  this._element.removeEventListener('mousedown', this._pressHandler);
  this._element.removeEventListener('mouseup', this._releaseHandler);
  this._element.removeEventListener('mouseleave', this._releaseHandler);
  this._element.removeEventListener('touchstart', this._pressHandler);
  this._element.removeEventListener('touchmove', this._releaseHandler);
  this._element.removeEventListener('touchend', this._releaseHandler);
  clearOwnProperties(this);
};

ElementPressControlMethod.prototype._handlePress = function() {
  this._pressing = true;

  this._dynamics.velocity = this._velocity;
  this._dynamics.friction = 0;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
  this.emit('active');
};

ElementPressControlMethod.prototype._handleRelease = function() {
  if(this._pressing) {
    this._dynamics.friction = this._friction;
    this.emit('parameterDynamics', this._parameter, this._dynamics);
    this.emit('inactive');
  }

  this._pressing = false;
};

module.exports = ElementPressControlMethod;

},{"../util/clearOwnProperties":76,"./Dynamics":39,"minimal-event-emitter":14}],41:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Hammer = require('hammerjs');

var nextId = 1;
var idProperty = 'MarzipanoHammerElementId';
function getKeyForElementAndType(element, type) {
  if (!element[idProperty]) {
    element[idProperty] = nextId++;
  }
  return type + element[idProperty];
}


/**
 * @class HammerGestures
 * @classdesc
 *
 * Manages Hammer.js instances. One instance is created for each combination of
 * DOM element and pointer type.
 */
function HammerGestures() {
  this._managers = {};
  this._refCount = {};
}


HammerGestures.prototype.get = function(element, type) {
  var key = getKeyForElementAndType(element, type);
  if (!this._managers[key]) {
    this._managers[key] = this._createManager(element, type);
    this._refCount[key] = 0;
  }
  this._refCount[key]++;
  return new HammerGesturesHandle(this, this._managers[key], element, type);
};


HammerGestures.prototype._createManager = function(element, type) {
  var manager = new Hammer.Manager(element);

  // Managers are created with different parameters for different pointer
  // types.
  if (type === 'mouse') {
    manager.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL, threshold: 0 }));
  }
  else if (type === 'touch' || type === 'pen' || type === 'kinect') {
    // On touch one wants to have both panning and pinching. The panning
    // recognizer needs a threshold to allow the pinch to be recognized.
    manager.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL, threshold: 20, pointers: 1 }));
    manager.add(new Hammer.Pinch());
  }

  return manager;
};


HammerGestures.prototype._releaseHandle = function(element, type) {
  var key = getKeyForElementAndType(element, type);
  if (this._refCount[key]) {
    this._refCount[key]--;
    if (!this._refCount[key]) {
      this._managers[key].destroy();
      delete this._managers[key];
      delete this._refCount[key];
    }
  }
};


function HammerGesturesHandle(hammerGestures, manager, element, type) {
  this._manager = manager;
  this._element = element;
  this._type = type;
  this._hammerGestures = hammerGestures;
  this._eventHandlers = [];
}


HammerGesturesHandle.prototype.on = function(events, handler) {
  var type = this._type;
  var handlerFilteredEvents = function(e) {
    if (type === e.pointerType) {
      handler(e);
    }
  };

  this._eventHandlers.push({ events: events, handler: handlerFilteredEvents });
  this._manager.on(events, handlerFilteredEvents);
};


HammerGesturesHandle.prototype.release = function() {
  for (var i = 0; i < this._eventHandlers.length; i++) {
    var eventHandler = this._eventHandlers[i];
    this._manager.off(eventHandler.events, eventHandler.handler);
  }

  this._hammerGestures._releaseHandle(this._element, this._type);
  this._manager = null;
  this._element = null;
  this._type = null;
  this._hammerGestures = null;
};


HammerGesturesHandle.prototype.manager = function() {
  return this._manager;
};


module.exports = new HammerGestures();

},{"hammerjs":13}],42:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class KeyControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Sets the velocity and friction of a single parameter by pressing and
 * unpressing a key.
 *
 * @param {number} keyCode Key which activates the method when pressed
 * @param {string} parameter The parameter to be controlled (e.g. `x`, `y` or `zoom`)
 * @param {number} velocity Velocity at which the parameter changes. Use a
 * negative number for opposite direction
 * @param {number} friction Friction at which the parameter stops
 * @param {Element} [element=document] DOM element where the key events are listened to
 */
function KeyControlMethod(keyCode, parameter, velocity, friction, element) {
  if(!keyCode) {
    throw new Error("KeyControlMethod: keyCode must be defined");
  }
  if(!parameter) {
    throw new Error("KeyControlMethod: parameter must be defined");
  }
  if(!velocity) {
    throw new Error("KeyControlMethod: velocity must be defined");
  }
  if(!friction) {
    throw new Error("KeyControlMethod: friction must be defined");
  }

  element = element || document;

  this._keyCode = keyCode;
  this._parameter = parameter;
  this._velocity = velocity;
  this._friction = friction;
  this._element = element;

  this._keydownHandler = this._handlePress.bind(this);
  this._keyupHandler = this._handleRelease.bind(this);
  this._blurHandler = this._handleBlur.bind(this);

  this._element.addEventListener('keydown', this._keydownHandler);
  this._element.addEventListener('keyup', this._keyupHandler);
  window.addEventListener('blur', this._blurHandler);

  this._dynamics = new Dynamics();
  this._pressing = false;
}
eventEmitter(KeyControlMethod);

/**
 * Destructor.
 */
KeyControlMethod.prototype.destroy = function() {
  this._element.removeEventListener('keydown', this._keydownHandler);
  this._element.removeEventListener('keyup', this._keyupHandler);
  window.removeEventListener('blur', this._blurHandler);
  clearOwnProperties(this);
};

KeyControlMethod.prototype._handlePress = function(e) {
  if(e.keyCode !== this._keyCode) { return; }

  this._pressing = true;

  this._dynamics.velocity = this._velocity;
  this._dynamics.friction = 0;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
  this.emit('active');
};

KeyControlMethod.prototype._handleRelease = function(e) {
  if(e.keyCode !== this._keyCode) { return; }

  if(this._pressing) {
    this._dynamics.friction = this._friction;
    this.emit('parameterDynamics', this._parameter, this._dynamics);
    this.emit('inactive');
  }

  this._pressing = false;
};

KeyControlMethod.prototype._handleBlur = function() {
  this._dynamics.velocity = 0;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
  this.emit('inactive');

  this._pressing = false;
};

module.exports = KeyControlMethod;

},{"../util/clearOwnProperties":76,"./Dynamics":39,"minimal-event-emitter":14}],43:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var HammerGestures = require('./HammerGestures');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class PinchZoomControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Control the view fov/zoom by pinching with two fingers.
 *
 * @param {Element} element Element to listen for events.
 * @param {string} pointerType Which Hammer.js pointer type to use
 * @param {Object} opts
 */
function PinchZoomControlMethod(element, pointerType, opts) {
  this._hammer = HammerGestures.get(element, pointerType);

  this._lastEvent = null;

  this._active = false;

  this._dynamics = new Dynamics();

  this._hammer.on('pinchstart', this._handleStart.bind(this));
  this._hammer.on('pinch', this._handleEvent.bind(this));
  this._hammer.on('pinchend', this._handleEnd.bind(this));
  this._hammer.on('pinchcancel', this._handleEnd.bind(this));
}

eventEmitter(PinchZoomControlMethod);

/**
 * Destructor.
 */
PinchZoomControlMethod.prototype.destroy = function() {
  this._hammer.release();
  clearOwnProperties(this);
};


PinchZoomControlMethod.prototype._handleStart = function() {
  if (!this._active) {
    this._active = true;
    this.emit('active');
  }
};


PinchZoomControlMethod.prototype._handleEnd = function() {
  this._lastEvent = null;

  if (this._active) {
    this._active = false;
    this.emit('inactive');
  }
};


PinchZoomControlMethod.prototype._handleEvent = function(e) {
  var scale = e.scale;

  if (this._lastEvent) {
    scale /= this._lastEvent.scale;
  }

  this._dynamics.offset = (scale - 1) * -1;
  this.emit('parameterDynamics', 'zoom', this._dynamics);

  this._lastEvent = e;
};


module.exports = PinchZoomControlMethod;

},{"../util/clearOwnProperties":76,"./Dynamics":39,"./HammerGestures":41,"minimal-event-emitter":14}],44:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var HammerGestures = require('./HammerGestures');
var defaults = require('../util/defaults');
var maxFriction = require('./util').maxFriction;
var clearOwnProperties = require('../util/clearOwnProperties');


var defaultOptions = {
  speed: 8,
  friction: 6,
  maxFrictionTime: 0.3
};


/**
 * @class QtvrControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Controls the view by holding the mouse button down and moving it.
 * Also known as "QTVR" control mode.
 *
 * @param {Element} element Element to listen for events.
 * @param {string} pointerType Which Hammer.js pointer type to use (e.g.
 * `mouse` or `touch`).
 * @param {Object} opts
 * @param {number} opts.speed
 * @param {number} opts.friction
 * @param {number} opts.maxFrictionTime
 */
// TODO: allow speed not change linearly with distance to click spot.
// Quadratic or other would allow a larger speed range.
function QtvrControlMethod(element, pointerType, opts) {
  this._element = element;

  this._opts = defaults(opts || {}, defaultOptions);

  this._active = false;

  this._hammer = HammerGestures.get(element, pointerType);

  this._dynamics = {
    x: new Dynamics(),
    y: new Dynamics()
  };

  this._hammer.on('panstart', this._handleStart.bind(this));
  this._hammer.on('panmove', this._handleMove.bind(this));
  this._hammer.on('panend', this._handleRelease.bind(this));
  this._hammer.on('pancancel', this._handleRelease.bind(this));
}

eventEmitter(QtvrControlMethod);

/**
 * Destructor.
 */
QtvrControlMethod.prototype.destroy = function() {
  this._hammer.release();
  clearOwnProperties(this);
};


QtvrControlMethod.prototype._handleStart = function(e) {
  // Prevent event dragging other DOM elements and causing strange behavior on Chrome
  e.preventDefault();

  if (!this._active) {
    this._active = true;
    this.emit('active');
  }
};


QtvrControlMethod.prototype._handleMove = function(e) {
  // Prevent event dragging other DOM elements and causing strange behavior on Chrome
  e.preventDefault();

  this._updateDynamics(e, false);
};


QtvrControlMethod.prototype._handleRelease = function(e) {
  // Prevent event dragging other DOM elements and causing strange behavior on Chrome
  e.preventDefault();

  this._updateDynamics(e, true);

  if (this._active) {
    this._active = false;
    this.emit('inactive');
  }
};


var tmpReleaseFriction = [ null, null ];
QtvrControlMethod.prototype._updateDynamics = function(e, release) {
  var elementRect = this._element.getBoundingClientRect();
  var width = elementRect.right - elementRect.left;
  var height = elementRect.bottom - elementRect.top;
  var maxDim = Math.max(width, height);

  var x = e.deltaX / maxDim * this._opts.speed;
  var y = e.deltaY / maxDim * this._opts.speed;

  this._dynamics.x.reset();
  this._dynamics.y.reset();
  this._dynamics.x.velocity = x;
  this._dynamics.y.velocity = y;

  if (release) {
    maxFriction(this._opts.friction, this._dynamics.x.velocity, this._dynamics.y.velocity, this._opts.maxFrictionTime, tmpReleaseFriction);
    this._dynamics.x.friction = tmpReleaseFriction[0];
    this._dynamics.y.friction = tmpReleaseFriction[1];
  }

  this.emit('parameterDynamics', 'x', this._dynamics.x);
  this.emit('parameterDynamics', 'y', this._dynamics.y);
};


module.exports = QtvrControlMethod;

},{"../util/clearOwnProperties":76,"../util/defaults":81,"./Dynamics":39,"./HammerGestures":41,"./util":48,"minimal-event-emitter":14}],45:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var defaults = require('../util/defaults');
var clearOwnProperties = require('../util/clearOwnProperties');

var defaultOptions = {
  frictionTime: 0.2,
  zoomDelta: 0.001
};

/**
 * @class ScrollZoomControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Controls the fov/zoom through the mouse wheel.
 *
 * @param {Element} element Element to listen for events.
 * @param {Object} opts
 * @param {number} [opts.frictionTime=0.2]
 * @param {number} [opts.zoomDelta=0.001]
 */
function ScrollZoomControlMethod(element, opts) {
  this._element = element;
  this._opts = defaults(opts || {}, defaultOptions);
  this._dynamics = new Dynamics();
  this._eventList = [];

  var fn = this._opts.frictionTime ? this.withSmoothing : this.withoutSmoothing;
  this._wheelListener = fn.bind(this);
  
  element.addEventListener('wheel', this._wheelListener);
}

eventEmitter(ScrollZoomControlMethod);

/**
 * Destructor.
 */
ScrollZoomControlMethod.prototype.destroy = function() {
  this._element.removeEventListener(this._wheelListener);
  clearOwnProperties(this);
};


ScrollZoomControlMethod.prototype.withoutSmoothing = function(e) {
  this._dynamics.offset = wheelEventDelta(e) * this._opts.zoomDelta;
  this.emit('parameterDynamics', 'zoom', this._dynamics);

  e.preventDefault();

  this.emit('active');
  this.emit('inactive');
};


ScrollZoomControlMethod.prototype.withSmoothing = function(e) {
  var currentTime = e.timeStamp;

  // Record event.
  this._eventList.push(e);

  // Remove events whose smoothing has already expired.
  while (this._eventList[0].timeStamp < currentTime - this._opts.frictionTime*1000) {
    this._eventList.shift(0);
  }

  // Get the current velocity from the recorded events.
  // Each wheel movement causes a velocity of change/frictionTime during frictionTime.
  var velocity = 0;
  for (var i = 0; i < this._eventList.length; i++) {
    var zoomChangeFromEvent = wheelEventDelta(this._eventList[i]) * this._opts.zoomDelta;
    velocity += zoomChangeFromEvent / this._opts.frictionTime;
  }

  this._dynamics.velocity = velocity;
  this._dynamics.friction = Math.abs(velocity) / this._opts.frictionTime;

  this.emit('parameterDynamics', 'zoom', this._dynamics);

  e.preventDefault();

  this.emit('active');
  this.emit('inactive');
};


function wheelEventDelta(e) {
  var multiplier = e.deltaMode == 1 ? 20 : 1;
  return e.deltaY * multiplier;
}


module.exports = ScrollZoomControlMethod;

},{"../util/clearOwnProperties":76,"../util/defaults":81,"./Dynamics":39,"minimal-event-emitter":14}],46:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class VelocityControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Sets the velocity and friction of a single parameter.
 *
 * The user should emit 'active' and 'inactive' events if required.
 *
 * @param {String} parameter The parameter to be controlled (e.g. `x`, `y` or `zoom`)
*/
function VelocityControlMethod(parameter) {
  if(!parameter) {
    throw new Error("VelocityControlMethod: parameter must be defined");
  }

  this._parameter = parameter;
  this._dynamics = new Dynamics();
}
eventEmitter(VelocityControlMethod);

/**
 * Destructor.
 */
VelocityControlMethod.prototype.destroy = function() {
  clearOwnProperties(this);
};

/**
 * Set the parameter's velocity.
 * @param {Number} velocity
 */
VelocityControlMethod.prototype.setVelocity = function(velocity) {
  this._dynamics.velocity = velocity;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
};

/**
 * Set the parameter's friction.
 * @param {Number} friction
 */
VelocityControlMethod.prototype.setFriction = function(friction) {
  this._dynamics.friction = friction;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
};

module.exports = VelocityControlMethod;

},{"../util/clearOwnProperties":76,"./Dynamics":39,"minimal-event-emitter":14}],47:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaults = require('../util/defaults');
var DragControlMethod = require('./Drag');
var QtvrControlMethod = require('./Qtvr');
var ScrollZoomControlMethod = require('./ScrollZoom');
var PinchZoomControlMethod = require('./PinchZoom');
var KeyControlMethod = require('./Key');

var defaultOptions = {
  mouseViewMode: 'drag'
};

/**
 * Instantiate and register some commonly used {@link ControlMethod} instances.
 *
 * The following instances are registered:
 *   - mouseViewDrag
 *   - mouseViewQtvr
 *   - touchView
 *   - pinch
 *   - arrowKeys
 *   - plusMinusKeys
 *   - wasdKeys
 *   - qeKeys
 *
 * @param {Controls} controls Where to register the instances.
 * @param {Element} element Element to listen for events.
 * @param {Object} opts
 * @param {'drag'|'qtvr'} mouseViewMode
 */
function registerDefaultControls(controls, element, opts) {
  opts = defaults(opts || {}, defaultOptions);

  var controlMethods = {
    mouseViewDrag: new DragControlMethod(element, 'mouse'),
    mouseViewQtvr: new QtvrControlMethod(element, 'mouse'),
    touchView: new DragControlMethod(element, 'touch'),
    pinch: new PinchZoomControlMethod(element, 'touch'),

    leftArrowKey: new KeyControlMethod(37, 'x', -0.7, 3),
    rightArrowKey: new KeyControlMethod(39, 'x', 0.7, 3),
    upArrowKey: new KeyControlMethod(38, 'y', -0.7, 3),
    downArrowKey: new KeyControlMethod(40, 'y', 0.7, 3),
    plusKey: new KeyControlMethod(107, 'zoom', -0.7, 3),
    minusKey: new KeyControlMethod(109, 'zoom', 0.7, 3),

    wKey: new KeyControlMethod(87, 'y', -0.7, 3),
    aKey: new KeyControlMethod(65, 'x', -0.7, 3),
    sKey: new KeyControlMethod(83, 'y', 0.7, 3),
    dKey: new KeyControlMethod(68, 'x', 0.7, 3),
    qKey: new KeyControlMethod(81, 'roll', 0.7, 3),
    eKey: new KeyControlMethod(69, 'roll', -0.7, 3)
  };

  if(opts.scrollZoom !== false) {
    controlMethods.scrollZoom = new ScrollZoomControlMethod(element); //{ frictionTime: 0 }
  }

  var controlMethodGroups = {
    arrowKeys: [ 'leftArrowKey', 'rightArrowKey', 'upArrowKey', 'downArrowKey' ],
    plusMinusKeys: [ 'plusKey', 'minusKey' ],
    wasdKeys: [ 'wKey', 'aKey', 'sKey', 'dKey' ],
    qeKeys: [ 'qKey', 'eKey' ]
  };


  var enabledControls = [ 'scrollZoom', 'touchView', 'pinch' ];
  switch (opts.mouseViewMode) {
    case 'drag':
      enabledControls.push('mouseViewDrag');
      break;
    case 'qtvr':
      enabledControls.push('mouseViewQtvr');
      break;
    default:
      throw new Error("Unknown mouse view mode: " + opts.mouseViewMode);
  }

  for (var id in controlMethods) {
    var method = controlMethods[id];
    controls.registerMethod(id, method);
    if (enabledControls.indexOf(id) >= 0) {
      controls.enableMethod(id);
    }
  }

  for (var groupId in controlMethodGroups) {
    var methodGroup = controlMethodGroups[groupId];
    controls.addMethodGroup(groupId, methodGroup);
  }

  return controlMethods;
}

module.exports = registerDefaultControls;
},{"../util/defaults":81,"./Drag":38,"./Key":42,"./PinchZoom":43,"./Qtvr":44,"./ScrollZoom":45}],48:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function maxFriction(friction, velocityX, velocityY, maxFrictionTime, result) {
  var velocity = Math.sqrt(Math.pow(velocityX,2) + Math.pow(velocityY,2));
  friction = Math.max(friction, velocity/maxFrictionTime);
  changeVectorNorm(velocityX, velocityY, friction, result);
  result[0] = Math.abs(result[0]);
  result[1] = Math.abs(result[1]);
}

function changeVectorNorm(x, y, n, result) {
  var theta = Math.atan(y/x);
  result[0] = n * Math.cos(theta);
  result[1] = n * Math.sin(theta);
}

module.exports = {
  maxFriction: maxFriction,
  changeVectorNorm: changeVectorNorm
};
},{}],49:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('../util/inherits');
var hash = require('../util/hash');
var TileSearcher = require('../TileSearcher');
var LruMap = require('../collections/LruMap');
var Level = require('./Level');
var makeLevelList = require('./common').makeLevelList;
var makeSelectableLevelList = require('./common').makeSelectableLevelList;
var clamp = require('../util/clamp');
var cmp = require('../util/cmp');
var type = require('../util/type');
var vec3 = require('gl-matrix').vec3;
var vec4 = require('gl-matrix').vec4;

var neighborsCacheSize = 64;

// Initials for cube faces.
var faceList = 'fudlrb';

// Rotation of each face, relative to the front face.
var faceRotation = {
  f: { x: 0, y: 0 },
  b: { x: 0, y: Math.PI },
  l: { x: 0, y: Math.PI/2 },
  r: { x: 0, y: -Math.PI/2 },
  u: { x: Math.PI/2, y: 0 },
  d: { x: -Math.PI/2, y: 0 }
};

// Zero vector.
var origin = vec3.create();

// Rotate a vector in ZXY order.
function rotateVector(vec, z, x, y) {
  if (z) {
    vec3.rotateZ(vec, vec, origin, z);
  }
  if (x) {
    vec3.rotateX(vec, vec, origin, x);
  }
  if (y) {
    vec3.rotateY(vec, vec, origin, y);
  }
}

// Normalized vectors pointing to the center of each face.
var faceVectors = {};
for (var i = 0; i < faceList.length; i++) {
  var face = faceList[i];
  var rotation = faceRotation[face];
  var v = vec3.fromValues(0,  0, -1);
  rotateVector(v, 0, rotation.x, rotation.y);
  faceVectors[face] = v;
}

// Map each face to its adjacent faces.
// The order is as suggested by the front face.
var adjacentFace = {
  f: [ 'l', 'r', 'u', 'd' ],
  b: [ 'r', 'l', 'u', 'd' ],
  l: [ 'b', 'f', 'u', 'd' ],
  r: [ 'f', 'b', 'u', 'd' ],
  u: [ 'l', 'r', 'b', 'f' ],
  d: [ 'l', 'r', 'f', 'b' ]
};

// Offsets to apply to the (x,y) coordinates of a tile to get its neighbors.
var neighborOffsets = [
  [  0,  1 ], // top
  [  1,  0 ], // right
  [  0, -1 ], // bottom
  [ -1,  0 ]  // left
];


/**
 * @class CubeTile
 * @implements Tile
 * @classdesc
 *
 * A tile in a @{CubeGeometry}.
 */
function CubeTile(face, x, y, z, geometry) {
  this.face = face;
  this.x = x;
  this.y = y;
  this.z = z;
  this._geometry = geometry;
  this._level = geometry.levelList[z];
}


CubeTile.prototype.rotX = function() {
  return faceRotation[this.face].x;
};


CubeTile.prototype.rotY = function() {
  return faceRotation[this.face].y;
};


CubeTile.prototype.centerX = function() {
  return (this.x + 0.5) / this._level.numHorizontalTiles() - 0.5;
};


CubeTile.prototype.centerY = function() {
  return 0.5 - (this.y + 0.5) / this._level.numVerticalTiles();
};


CubeTile.prototype.scaleX = function() {
  return 1 / this._level.numHorizontalTiles();
};


CubeTile.prototype.scaleY = function() {
  return 1 / this._level.numVerticalTiles();
};


CubeTile.prototype.vertices = function(result) {
  if (!result) {
    result = [vec3.create(), vec3.create(), vec3.create(), vec3.create()];
  }

  var rot = faceRotation[this.face];

  function makeVertex(vec, x, y) {
    vec3.set(vec, x, y, -0.5);
    rotateVector(vec, 0, rot.x, rot.y);
  }

  var left = this.centerX() - this.scaleX() / 2;
  var right = this.centerX() + this.scaleX() / 2;
  var bottom = this.centerY() - this.scaleY() / 2;
  var top = this.centerY() + this.scaleY() / 2;

  makeVertex(result[0], left, top);
  makeVertex(result[1], right, top);
  makeVertex(result[2], right, bottom);
  makeVertex(result[3], left, bottom);

  return result;
};


CubeTile.prototype.parent = function() {

  if (this.z === 0) {
    return null;
  }

  var face = this.face;
  var z = this.z;
  var x = this.x;
  var y = this.y;

  var geometry = this._geometry;
  var level = geometry.levelList[z];
  var parentLevel = geometry.levelList[z-1];

  var tileX = Math.floor(x / level.numHorizontalTiles() * parentLevel.numHorizontalTiles());
  var tileY = Math.floor(y / level.numVerticalTiles() * parentLevel.numVerticalTiles());
  var tileZ = z-1;

  return new CubeTile(face, tileX, tileY, tileZ, geometry);

};


CubeTile.prototype.children = function(result) {

  if (this.z === this._geometry.levelList.length - 1) {
    return null;
  }

  var face = this.face;
  var z = this.z;
  var x = this.x;
  var y = this.y;

  var geometry = this._geometry;
  var level = geometry.levelList[z];
  var childLevel = geometry.levelList[z+1];

  var nHoriz = childLevel.numHorizontalTiles() / level.numHorizontalTiles();
  var nVert = childLevel.numVerticalTiles() / level.numVerticalTiles();

  result = result || [];

  for (var h = 0; h < nHoriz; h++) {
    for (var v = 0; v < nVert; v++) {
      var tileX = nHoriz * x + h;
      var tileY = nVert * y + v;
      var tileZ = z+1;
      result.push(new CubeTile(face, tileX, tileY, tileZ, geometry));
    }
  }

  return result;

};


CubeTile.prototype.neighbors = function() {

  var geometry = this._geometry;
  var cache = geometry._neighborsCache;

  // Satisfy from cache when available.
  var cachedResult = cache.get(this);
  if (cachedResult) {
    return cachedResult;
  }

  var vec = geometry._vec;

  var face = this.face;
  var x = this.x;
  var y = this.y;
  var z = this.z;
  var level = this._level;

  var numX = level.numHorizontalTiles();
  var numY = level.numVerticalTiles();

  var result = [];

  for (var i = 0; i < neighborOffsets.length; i++) {
    var xOffset = neighborOffsets[i][0];
    var yOffset = neighborOffsets[i][1];

    var newX = x + xOffset;
    var newY = y + yOffset;
    var newZ = z;
    var newFace = face;

    if (newX < 0 || newX >= numX || newY < 0 || newY >= numY) {

      // If the neighboring tile belongs to a different face, calculate a
      // vector pointing to the edge between the two faces at the point the
      // tile and its neighbor meet, and convert it into tile coordinates for
      // the neighboring face.

      var xCoord = this.centerX();
      var yCoord = this.centerY();

      // First, calculate the vector as if the initial tile belongs to the
      // front face, so that the tile x,y coordinates map directly into the
      // x,y axes.

      if (newX < 0) {
        vec3.set(vec, -0.5, yCoord, -0.5);
        newFace = adjacentFace[face][0];
      } else if (newX >= numX) {
        vec3.set(vec, 0.5, yCoord, -0.5);
        newFace = adjacentFace[face][1];
      } else if (newY < 0) {
        vec3.set(vec, xCoord, 0.5, -0.5);
        newFace = adjacentFace[face][2];
      } else if (newY >= numY) {
        vec3.set(vec, xCoord, -0.5, -0.5);
        newFace = adjacentFace[face][3];
      }

      var rot;

      // Then, rotate the vector into the actual face the initial tile
      // belongs to.

      rot = faceRotation[face];
      rotateVector(vec, 0, rot.x, rot.y);

      // Finally, rotate the vector from the neighboring face into the front
      // face. Again, this is so that the neighboring tile x,y coordinates
      // map directly into the x,y axes.

      rot = faceRotation[newFace];
      rotateVector(vec, 0, -rot.x, -rot.y);

      // Calculate the neighboring tile coordinates.

      newX = clamp(Math.floor((0.5 + vec[0]) * numX), 0, numX - 1);
      newY = clamp(Math.floor((0.5 - vec[1]) * numY), 0, numY - 1);
    }

    result.push(new CubeTile(newFace, newX, newY, newZ, geometry));
  }

  // Store into cache to satisfy future requests.
  cache.set(this, result);

  return result;

};


CubeTile.prototype.hash = function() {
  return hash(faceList.indexOf(this.face), this.z, this.y, this.x);
};


CubeTile.prototype.equals = function(that) {
  return (this._geometry === that._geometry &&
      this.face === that.face &&
      this.z === that.z &&
      this.y === that.y &&
      this.x === that.x);
};


CubeTile.prototype.cmp = function(that) {
  return (cmp(this.z, that.z) ||
  cmp(faceList.indexOf(this.face), faceList.indexOf(that.face)) ||
  cmp(this.y, that.y) || cmp(this.x, that.x));
};


CubeTile.prototype.str = function() {
  return 'CubeTile(' + tile.face + ', ' + tile.x + ', ' + tile.y + ', ' + tile.z + ')';
};


function CubeLevel(levelProperties) {
  this.constructor.super_.call(this, levelProperties);

  this._size = levelProperties.size;
  this._tileSize = levelProperties.tileSize;

  if (this._size % this._tileSize !== 0) {
    throw new Error('Level size is not multiple of tile size: ' +
                    this._size + ' ' + this._tileSize);
  }
}

inherits(CubeLevel, Level);


CubeLevel.prototype.width = function() {
  return this._size;
};


CubeLevel.prototype.height = function() {
  return this._size;
};


CubeLevel.prototype.tileWidth = function() {
  return this._tileSize;
};


CubeLevel.prototype.tileHeight = function() {
  return this._tileSize;
};


CubeLevel.prototype._validateWithParentLevel = function(parentLevel) {

  var width = this.width();
  var height = this.height();
  var tileWidth = this.tileWidth();
  var tileHeight = this.tileHeight();
  var numHorizontal = this.numHorizontalTiles();
  var numVertical = this.numVerticalTiles();

  var parentWidth = parentLevel.width();
  var parentHeight = parentLevel.height();
  var parentTileWidth = parentLevel.tileWidth();
  var parentTileHeight = parentLevel.tileHeight();
  var parentNumHorizontal = parentLevel.numHorizontalTiles();
  var parentNumVertical = parentLevel.numVerticalTiles();

  if (width % parentWidth !== 0) {
    throw new Error('Level width must be multiple of parent level: ' +
                    width + ' vs. ' + parentWidth);
  }

  if (height % parentHeight !== 0) {
    throw new Error('Level height must be multiple of parent level: ' +
                    height + ' vs. ' + parentHeight);
  }

  if (numHorizontal % parentNumHorizontal !== 0) {
    throw new Error('Number of horizontal tiles must be multiple of parent level: ' +
      numHorizontal + " (" + width + '/' + tileWidth + ')' + " vs. " +
      parentNumHorizontal + " (" + parentWidth + '/' + parentTileWidth + ')');
  }

  if (numVertical % parentNumVertical !== 0) {
    throw new Error('Number of vertical tiles must be multiple of parent level: ' +
      numVertical + " (" + height + '/' + tileHeight + ')' + " vs. " +
      parentNumVertical + " (" + parentHeight + '/' + parentTileHeight + ')');
  }

};


/**
 * @class CubeGeometry
 * @implements Geometry
 * @classdesc
 *
 * A {@link Geometry} implementation suitable for tiled cube images with
 * multiple resolution levels.
 *
 * The following restrictions apply:
 *   - All tiles in a level must be square and form a rectangular grid;
 *   - The size of a level must be a multiple of the tile size;
 *   - The size of a level must be a multiple of the parent level size;
 *   - The number of tiles in a level must be a multiple of the number of tiles
 *     in the parent level.
 *
 * @param {Object[]} levelPropertiesList Level description
 * @param {number} levelPropertiesList[].size Cube face size in pixels
 * @param {number} levelPropertiesList[].tileSize Tile size in pixels
 */
function CubeGeometry(levelPropertiesList) {
  if (type(levelPropertiesList) !== 'array') {
    throw new Error('Level list must be an array');
  }

  this.levelList = makeLevelList(levelPropertiesList, CubeLevel);
  this.selectableLevelList = makeSelectableLevelList(this.levelList);

  for (var i = 1; i < this.levelList.length; i++) {
    this.levelList[i]._validateWithParentLevel(this.levelList[i-1]);
  }

  this._tileSearcher = new TileSearcher(this);

  this._neighborsCache = new LruMap(neighborsCacheSize);

  this._vec = vec4.create();

  this._viewSize = {};
}


CubeGeometry.prototype.maxTileSize = function() {
  var maxTileSize = 0;
  for (var i = 0; i < this.levelList.length; i++) {
    var level = this.levelList[i];
    maxTileSize = Math.max(maxTileSize, level.tileWidth, level.tileHeight);
  }
  return maxTileSize;
};


CubeGeometry.prototype.levelTiles = function(level, result) {

  var levelIndex = this.levelList.indexOf(level);
  var maxX = level.numHorizontalTiles() - 1;
  var maxY = level.numVerticalTiles() - 1;

  result = result || [];

  for (var f = 0; f < faceList.length; f++) {
    var face = faceList[f];
    for (var x = 0; x <= maxX; x++) {
      for (var y = 0; y <= maxY; y++) {
        result.push(new CubeTile(face, x, y, levelIndex, this));
      }
    }
  }

  return result;

};


CubeGeometry.prototype._closestTile = function(view, level) {
  var ray = this._vec;

  // Compute a view ray into the central screen point.
  vec4.set(ray, 0, 0, 1, 1);
  vec4.transformMat4(ray, ray, view.inverseProjection());

  var minAngle = Infinity;
  var closestFace = null;

  // Find the face whose vector makes a minimal angle with the view ray.
  // This is the face into which the view ray points.
  for (var face in faceVectors) {
    var vector = faceVectors[face];
    // For a small angle between two normalized vectors, angle ~ 1-cos(angle).
    var angle = 1 - vec3.dot(vector, ray);
    if (angle < minAngle) {
      minAngle = angle;
      closestFace = face;
    }
  }

  // Project view ray onto cube, i.e., normalize the coordinate with
  // largest absolute value to ±0.5.
  var max = Math.max(Math.abs(ray[0]), Math.abs(ray[1]), Math.abs(ray[2])) / 0.5;
  for (var i = 0; i < 3; i++) {
    ray[i] = ray[i] / max;
  }

  // Rotate view ray into front face.
  var rot = faceRotation[closestFace];
  rotateVector(ray, 0, -rot.x, -rot.y);

  // Get the desired zoom level.
  var tileZ = this.levelList.indexOf(level);
  var numX = level.numHorizontalTiles();
  var numY = level.numVerticalTiles();

  // Find the coordinates of the tile that the view ray points into.
  var tileX = clamp(Math.floor((0.5 + ray[0]) * numX), 0, numX - 1);
  var tileY = clamp(Math.floor((0.5 - ray[1]) * numY), 0, numY - 1);

  return new CubeTile(closestFace, tileX, tileY, tileZ, this);
};


CubeGeometry.prototype.visibleTiles = function(view, level, result) {
  var viewSize = this._viewSize;
  var tileSearcher = this._tileSearcher;

  result = result || [];

  view.size(viewSize);
  if (viewSize.width === 0 || viewSize.height === 0) {
    // No tiles are visible if the viewport is empty.
    return result;
  }

  var startingTile = this._closestTile(view, level);
  var count = tileSearcher.search(view, startingTile, result);
  if (!count) {
    throw new Error('Starting tile is not visible');
  }

  return result;
};


CubeGeometry.Tile = CubeGeometry.prototype.Tile = CubeTile;
CubeGeometry.type = CubeGeometry.prototype.type = 'cube';
CubeTile.type = CubeTile.prototype.type = 'cube';


module.exports = CubeGeometry;

},{"../TileSearcher":22,"../collections/LruMap":28,"../util/clamp":75,"../util/cmp":77,"../util/hash":88,"../util/inherits":89,"../util/type":101,"./Level":52,"./common":53,"gl-matrix":3}],50:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('../util/inherits');
var hash = require('../util/hash');
var cmp = require('../util/cmp');
var common = require('./common');
var Level = require('./Level');
var type = require('../util/type');


/**
 * @class EquirectTile
 * @implements Tile
 * @classdesc
 *
 * A tile in an @{EquirectGeometry}.
 */
function EquirectTile(z, geometry) {
  this.z = z;
  this._geometry = geometry;
  this._level = geometry.levelList[z];
}


EquirectTile.prototype.rotX = function() {
  return 0;
};


EquirectTile.prototype.rotY = function() {
  return 0;
};


EquirectTile.prototype.centerX = function() {
  return 0.5;
};


EquirectTile.prototype.centerY = function() {
  return 0.5;
};


EquirectTile.prototype.scaleX = function() {
  return 1;
};


EquirectTile.prototype.scaleY = function() {
  return 1;
};


EquirectTile.prototype.parent = function() {
  if (this.z === 0) {
    return null;
  }
  return new EquirectTile(this.z - 1, this._geometry);
};


EquirectTile.prototype.children = function(result) {
  if (this.z === this._geometry.levelList.length - 1) {
    return null;
  }
  result = result || [];
  result.push(new EquirectTile(this.z + 1, this._geometry));
  return result;
};


EquirectTile.prototype.neighbors = function() {
  return [];
};


EquirectTile.prototype.hash = function() {
  return hash(this.z);
};


EquirectTile.prototype.equals = function(that) {
  return this._geometry === that._geometry && this.z === that.z;
};


EquirectTile.prototype.cmp = function(that) {
  return cmp(this.z, that.z);
};


EquirectTile.prototype.str = function() {
  return 'EquirectTile(' + tile.z + ')';
};


function EquirectLevel(levelProperties) {
  this.constructor.super_.call(this, levelProperties);
  this._width = levelProperties.width;
}

inherits(EquirectLevel, Level);


EquirectLevel.prototype.width = function() {
  return this._width;
};


EquirectLevel.prototype.height = function() {
  return this._width/2;
};


EquirectLevel.prototype.tileWidth = function() {
  return this._width;
};


EquirectLevel.prototype.tileHeight = function() {
  return this._width/2;
};


/**
 * @class EquirectGeometry
 * @implements Geometry
 * @classdesc
 *
 * A {@link Geometry} implementation suitable for equirectangular images with a
 * 2:1 aspect ratio.
 *
 * @param {Object[]} levelPropertiesList Level description
 * @param {number} levelPropertiesList[].width Level width in pixels
*/
function EquirectGeometry(levelPropertiesList) {
  if (type(levelPropertiesList) !== 'array') {
    throw new Error('Level list must be an array');
  }

  this.levelList = common.makeLevelList(levelPropertiesList, EquirectLevel);
  this.selectableLevelList = common.makeSelectableLevelList(this.levelList);
}


EquirectGeometry.prototype.maxTileSize = function() {
  var maxTileSize = 0;
  for (var i = 0; i < this.levelList.length; i++) {
    var level = this.levelList[i];
    maxTileSize = Math.max(maxTileSize, level.tileWidth, level.tileHeight);
  }
  return maxTileSize;
};


EquirectGeometry.prototype.levelTiles = function(level, result) {
  var levelIndex = this.levelList.indexOf(level);
  result = result || [];
  result.push(new EquirectTile(levelIndex, this));
  return result;
};


EquirectGeometry.prototype.visibleTiles = function(view, level, result) {
  var tile = new EquirectTile(this.levelList.indexOf(level), this);
  result = result || [];
  result.length = 0;
  result.push(tile);
};


EquirectGeometry.Tile = EquirectGeometry.prototype.Tile = EquirectTile;
EquirectGeometry.type = EquirectGeometry.prototype.type = 'equirect';
EquirectTile.type = EquirectTile.prototype.type = 'equirect';


module.exports = EquirectGeometry;

},{"../util/cmp":77,"../util/hash":88,"../util/inherits":89,"../util/type":101,"./Level":52,"./common":53}],51:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('../util/inherits');
var hash = require('../util/hash');
var TileSearcher = require('../TileSearcher');
var LruMap = require('../collections/LruMap');
var Level = require('./Level');
var makeLevelList = require('./common').makeLevelList;
var makeSelectableLevelList = require('./common').makeSelectableLevelList;
var clamp = require('../util/clamp');
var mod = require('../util/mod');
var cmp = require('../util/cmp');
var type = require('../util/type');
var vec2 = require('gl-matrix').vec2;
var vec4 = require('gl-matrix').vec4;

var neighborsCacheSize = 64;

// Offsets to apply to the (x,y) coordinates of a tile to get its neighbors.
var neighborOffsets = [
  [  0,  1 ], // top
  [  1,  0 ], // right
  [  0, -1 ], // bottom
  [ -1,  0 ]  // left
];


/**
 * @class FlatTile
 * @implements Tile
 * @classdesc
 *
 * A tile in a {@link FlatGeometry}.
 */
function FlatTile(x, y, z, geometry) {
  this.x = x;
  this.y = y;
  this.z = z;
  this._geometry = geometry;
  this._level = geometry.levelList[z];
}


FlatTile.prototype.rotX = function() {
  return 0;
};


FlatTile.prototype.rotY = function() {
  return 0;
};


FlatTile.prototype.centerX = function() {
  var levelWidth = this._level.width();
  var tileWidth = this._level.tileWidth();
  return (this.x * tileWidth + 0.5 * this.width()) / levelWidth - 0.5;
};


FlatTile.prototype.centerY = function() {
  var levelHeight = this._level.height();
  var tileHeight = this._level.tileHeight();
  return 0.5 - (this.y * tileHeight + 0.5 * this.height()) / levelHeight;
};


FlatTile.prototype.scaleX = function() {
  var levelWidth = this._level.width();
  return this.width() / levelWidth;
};


FlatTile.prototype.scaleY = function() {
  var levelHeight = this._level.height();
  return this.height() / levelHeight;
};


FlatTile.prototype.width = function() {
  var levelWidth = this._level.width();
  var tileWidth = this._level.tileWidth();
  if (this.x === this._level.numHorizontalTiles() - 1) {
    var widthRemainder = mod(levelWidth, tileWidth);
    return widthRemainder || tileWidth;
  } else {
    return tileWidth;
  }
};


FlatTile.prototype.height = function() {
  var levelHeight = this._level.height();
  var tileHeight = this._level.tileHeight();
  if (this.y === this._level.numVerticalTiles() - 1) {
    var heightRemainder = mod(levelHeight, tileHeight);
    return heightRemainder || tileHeight;
  } else {
    return tileHeight;
  }
};


FlatTile.prototype.levelWidth = function() {
  return this._level.width();
};


FlatTile.prototype.levelHeight = function() {
  return this._level.height();
};


FlatTile.prototype.vertices = function(result) {
  if (!result) {
    result = [vec2.create(), vec2.create(), vec2.create(), vec2.create()];
  }

  var left = this.centerX() - this.scaleX() / 2;
  var right = this.centerX() + this.scaleX() / 2;
  var bottom = this.centerY() - this.scaleY() / 2;
  var top = this.centerY() + this.scaleY() / 2;

  vec2.set(result[0], left, top);
  vec2.set(result[1], right, top);
  vec2.set(result[2], right, bottom);
  vec2.set(result[3], left, bottom);

  return result;
};


FlatTile.prototype.parent = function() {


  if (this.z === 0) {
    return null;
  }

  var geometry = this._geometry;

  var z = this.z - 1;
  // TODO: Currently assuming each level is double the size of previous one.
  // Fix to support other multiples.
  var x = Math.floor(this.x / 2);
  var y = Math.floor(this.y / 2);

  return new FlatTile(x, y, z, geometry);

};


FlatTile.prototype.children = function(result) {
  if (this.z === this._geometry.levelList.length - 1) {
    return null;
  }

  var geometry = this._geometry;
  var z = this.z + 1;

  result = result || [];

  // TODO: Currently assuming each level is double the size of previous one.
  // Fix to support other multiples.
  result.push(new FlatTile(2*this.x  , 2*this.y  , z, geometry));
  result.push(new FlatTile(2*this.x  , 2*this.y+1, z, geometry));
  result.push(new FlatTile(2*this.x+1, 2*this.y  , z, geometry));
  result.push(new FlatTile(2*this.x+1, 2*this.y+1, z, geometry));

  return result;

};


FlatTile.prototype.neighbors = function() {

  var geometry = this._geometry;
  var cache = geometry._neighborsCache;

  // Satisfy from cache when available.
  var cachedResult = cache.get(this);
  if (cachedResult) {
    return cachedResult;
  }

  var x = this.x;
  var y = this.y;
  var z = this.z;
  var level = this._level;

  var numX = level.numHorizontalTiles() - 1;
  var numY = level.numVerticalTiles() - 1;

  var result = [];

  for (var i = 0; i < neighborOffsets.length; i++) {
    var xOffset = neighborOffsets[i][0];
    var yOffset = neighborOffsets[i][1];

    var newX = x + xOffset;
    var newY = y + yOffset;
    var newZ = z;

    if (0 <= newX && newX <= numX && 0 <= newY && newY <= numY) {
      result.push(new FlatTile(newX, newY, newZ, geometry));
    }
  }

  // Store into cache to satisfy future requests.
  cache.set(this, result);

  return result;

};


FlatTile.prototype.hash = function() {
  return hash(this.z, this.y, this.x);
};


FlatTile.prototype.equals = function(that) {
  return (this._geometry === that._geometry &&
      this.z === that.z && this.y === that.y && this.x === that.x);
};


FlatTile.prototype.cmp = function(that) {
  return (cmp(this.z, that.z) || cmp(this.y, that.y) || cmp(this.x, that.x));
};


FlatTile.prototype.str = function() {
  return 'FlatTile(' + tile.x + ', ' + tile.y + ', ' + tile.z + ')';
};


function FlatLevel(levelProperties) {
  this.constructor.super_.call(this, levelProperties);

  this._width = levelProperties.width;
  this._height = levelProperties.height;
  this._tileWidth = levelProperties.tileWidth;
  this._tileHeight = levelProperties.tileHeight;
}

inherits(FlatLevel, Level);


FlatLevel.prototype.width = function() {
  return this._width;
};


FlatLevel.prototype.height = function() {
  return this._height;
};


FlatLevel.prototype.tileWidth = function() {
  return this._tileWidth;
};


FlatLevel.prototype.tileHeight = function() {
  return this._tileHeight;
};


FlatLevel.prototype._validateWithParentLevel = function(parentLevel) {

  var width = this.width();
  var height = this.height();
  var tileWidth = this.tileWidth();
  var tileHeight = this.tileHeight();

  var parentWidth = parentLevel.width();
  var parentHeight = parentLevel.height();
  var parentTileWidth = parentLevel.tileWidth();
  var parentTileHeight = parentLevel.tileHeight();

  if (width % parentWidth !== 0) {
    return new Error('Level width must be multiple of parent level: ' +
                     width + ' vs. ' + parentWidth);
  }

  if (height % parentHeight !== 0) {
    return new Error('Level height must be multiple of parent level: ' +
                     height + ' vs. ' + parentHeight);
  }

  if (tileWidth % parentTileWidth !== 0) {
    return new Error('Level tile width must be multiple of parent level: ' +
                     tileWidth + ' vs. ' + parentTileWidth);
  }

  if (tileHeight % parentTileHeight !== 0) {
    return new Error('Level tile height must be multiple of parent level: ' +
                     tileHeight + ' vs. ' + parentTileHeight);
  }

};


/**
 * @class FlatGeometry
 * @implements Geometry
 * @classdesc
 *
 * A {@link Geometry} implementation suitable for tiled flat images with
 * multiple resolution levels.
 *
 * The following restrictions apply:
 *   - All tiles must be square, except when in the last row or column position,
 *     and must form a rectangular grid;
 *   - The width and height of a level must be multiples of the parent level
 *     width and height.
 *
 * @param {Object[]} levelPropertiesList Level description
 * @param {number} levelPropertiesList[].width Level width in pixels
 * @param {number} levelPropertiesList[].tileWidth Tile width in pixels for
 *                 square tiles
 * @param {number} levelPropertiesList[].height Level height in pixels
 * @param {number} levelPropertiesList[].tileHeight Tile height in pixels for
 *                 square tiles
 */
function FlatGeometry(levelPropertiesList) {
  if (type(levelPropertiesList) !== 'array') {
    throw new Error('Level list must be an array');
  }

  this.levelList = makeLevelList(levelPropertiesList, FlatLevel);
  this.selectableLevelList = makeSelectableLevelList(this.levelList);

  for (var i = 1; i < this.levelList.length; i++) {
    this.levelList[i]._validateWithParentLevel(this.levelList[i-1]);
  }

  this._tileSearcher = new TileSearcher(this);

  this._neighborsCache = new LruMap(neighborsCacheSize);

  this._vec = vec4.create();

  this._viewSize = {};
}


FlatGeometry.prototype.maxTileSize = function() {
  var maxTileSize = 0;
  for (var i = 0; i < this.levelList.length; i++) {
    var level = this.levelList[i];
    maxTileSize = Math.max(maxTileSize, level.tileWidth, level.tileHeight);
  }
  return maxTileSize;
};


FlatGeometry.prototype.levelTiles = function(level, result) {

  var levelIndex = this.levelList.indexOf(level);
  var maxX = level.numHorizontalTiles() - 1;
  var maxY = level.numVerticalTiles() - 1;

  if (!result) {
    result = [];
  }

  for (var x = 0; x <= maxX; x++) {
    for (var y = 0; y <= maxY; y++) {
      result.push(new FlatTile(x, y, levelIndex, this));
    }
  }

  return result;

};


FlatGeometry.prototype._closestTile = function(view, level) {
  var ray = this._vec;

  // Compute a view ray into the central screen point.
  vec4.set(ray, 0, 0, 1, 1);
  vec4.transformMat4(ray, ray, view.inverseProjection());

  // Compute the image coordinates that the view ray points into.
  var x = 0.5 + ray[0];
  var y = 0.5 - ray[1];

  // Get the desired zoom level.
  var tileZ = this.levelList.indexOf(level);
  var levelWidth = level.width();
  var levelHeight = level.height();
  var tileWidth = level.tileWidth();
  var tileHeight = level.tileHeight();
  var numX = level.numHorizontalTiles();
  var numY = level.numVerticalTiles();

  // Find the coordinates of the tile that the view ray points into.
  var tileX = clamp(Math.floor(x * levelWidth / tileWidth), 0, numX - 1);
  var tileY = clamp(Math.floor(y * levelHeight / tileHeight), 0, numY - 1);

  return new FlatTile(tileX, tileY, tileZ, this);
};


FlatGeometry.prototype.visibleTiles = function(view, level, result) {
  var viewSize = this._viewSize;
  var tileSearcher = this._tileSearcher;

  result = result || [];

  view.size(viewSize);
  if (viewSize.width === 0 || viewSize.height === 0) {
    // No tiles are visible if the viewport is empty.
    return result;
  }

  var startingTile = this._closestTile(view, level);
  var count = tileSearcher.search(view, startingTile, result);
  if (!count) {
    throw new Error('Starting tile is not visible');
  }

  return result;
};


FlatGeometry.Tile = FlatGeometry.prototype.Tile = FlatTile;
FlatGeometry.type = FlatGeometry.prototype.type = 'flat';
FlatTile.type = FlatTile.prototype.type = 'flat';


module.exports = FlatGeometry;

},{"../TileSearcher":22,"../collections/LruMap":28,"../util/clamp":75,"../util/cmp":77,"../util/hash":88,"../util/inherits":89,"../util/mod":91,"../util/type":101,"./Level":52,"./common":53,"gl-matrix":3}],52:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function Level(levelProperties) {
  this._fallbackOnly = !!levelProperties.fallbackOnly;
}

Level.prototype.numHorizontalTiles = function() {
  return Math.ceil(this.width() / this.tileWidth());
};

Level.prototype.numVerticalTiles = function() {
  return Math.ceil(this.height() / this.tileHeight());
};

Level.prototype.fallbackOnly = function() {
  return this._fallbackOnly;
};

module.exports = Level;
},{}],53:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var cmp = require('../util/cmp');

function makeLevelList(levelPropertiesList, LevelClass) {
  var list = [];

  for (var i = 0; i < levelPropertiesList.length; i++) {
    list.push(new LevelClass(levelPropertiesList[i]));
  }

  list.sort(function(level1, level2) {
    return cmp(level1.width(), level2.width());
  });

  return list;
}

function makeSelectableLevelList(levelList) {
  var list = [];

  for (var i = 0; i < levelList.length; i++) {
    if (!levelList[i]._fallbackOnly) {
      list.push(levelList[i]);
    }
  }

  if (!list.length) {
    throw new Error('No selectable levels in list');
  }

  return list;
}

module.exports = {
  makeLevelList: makeLevelList,
  makeSelectableLevelList: makeSelectableLevelList
};

},{"../util/cmp":77}],54:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = {

  // Stages.
  WebGlStage: require('./stages/WebGl'),

  // Renderers.
  WebGlCubeRenderer: require('./renderers/WebGlCube'),
  WebGlFlatRenderer: require('./renderers/WebGlFlat'),
  WebGlEquirectRenderer: require('./renderers/WebGlEquirect'),
  registerDefaultRenderers: require('./renderers/registerDefaultRenderers'),

  // Geometries.
  CubeGeometry: require('./geometries/Cube'),
  FlatGeometry: require('./geometries/Flat'),
  EquirectGeometry: require('./geometries/Equirect'),

  // Views.
  RectilinearView: require('./views/Rectilinear'),
  FlatView: require('./views/Flat'),

  // Sources.
  ImageUrlSource: require('./sources/ImageUrl'),
  SingleAssetSource: require('./sources/SingleAsset'),

  // Assets.
  StaticAsset: require('./assets/Static'),
  DynamicAsset: require('./assets/Dynamic'),

  // Texture store.
  TextureStore: require('./TextureStore'),

  // Layer.
  Layer: require('./Layer'),

  // Render loop.
  RenderLoop: require('./RenderLoop'),

  // Controls.
  KeyControlMethod: require('./controls/Key'),
  DragControlMethod: require('./controls/Drag'),
  QtvrControlMethod: require('./controls/Qtvr'),
  ScrollZoomControlMethod: require('./controls/ScrollZoom'),
  PinchZoomControlMethod: require('./controls/PinchZoom'),
  VelocityControlMethod: require('./controls/Velocity'),
  ElementPressControlMethod: require('./controls/ElementPress'),
  Controls: require('./controls/Controls'),
  Dynamics: require('./controls/Dynamics'),

  // High-level API.
  Viewer: require('./Viewer'),
  Scene: require('./Scene'),

  // Hotspots.
  Hotspot: require('./Hotspot'),
  HotspotContainer: require('./HotspotContainer'),

  // Effects.
  colorEffects: require('./colorEffects'),

  // Miscellaneous functions.
  registerDefaultControls: require('./controls/registerDefaultControls'),
  autorotate: require('./autorotate'),

  // Utility functions.
  util: {
    async: require('./util/async'),
    cancelize: require('./util/cancelize'),
    chain: require('./util/chain'),
    clamp: require('./util/clamp'),
    clearOwnProperties: require('./util/clearOwnProperties'),
    cmp: require('./util/cmp'),
    compose: require('./util/compose'),
    convertFov: require('./util/convertFov'),
    decimal: require('./util/decimal'),
    defaults: require('./util/defaults'),
    defer: require('./util/defer'),
    degToRad: require('./util/degToRad'),
    delay: require('./util/delay'),
    dom: require('./util/dom'),
    extend: require('./util/extend'),
    hash: require('./util/hash'),
    inherits: require('./util/inherits'),
    mod: require('./util/mod'),
    noop: require('./util/noop'),
    now: require('./util/now'),
    once: require('./util/once'),
    pixelRatio: require('./util/pixelRatio'),
    radToDeg: require('./util/radToDeg'),
    real: require('./util/real'),
    retry: require('./util/retry'),
    tween: require('./util/tween'),
    type: require('./util/type')
  },

  // Expose dependencies for clients to use.
  dependencies: {
    bowser: require('bowser'),
    glMatrix: require('gl-matrix'),
    eventEmitter: require('minimal-event-emitter'),
    hammerjs: require('hammerjs')
  }
};

},{"./Hotspot":15,"./HotspotContainer":16,"./Layer":17,"./RenderLoop":19,"./Scene":20,"./TextureStore":21,"./Viewer":24,"./assets/Dynamic":25,"./assets/Static":26,"./autorotate":27,"./colorEffects":34,"./controls/Controls":37,"./controls/Drag":38,"./controls/Dynamics":39,"./controls/ElementPress":40,"./controls/Key":42,"./controls/PinchZoom":43,"./controls/Qtvr":44,"./controls/ScrollZoom":45,"./controls/Velocity":46,"./controls/registerDefaultControls":47,"./geometries/Cube":49,"./geometries/Equirect":50,"./geometries/Flat":51,"./renderers/WebGlCube":58,"./renderers/WebGlEquirect":59,"./renderers/WebGlFlat":60,"./renderers/registerDefaultRenderers":61,"./sources/ImageUrl":66,"./sources/SingleAsset":67,"./stages/WebGl":70,"./util/async":71,"./util/cancelize":73,"./util/chain":74,"./util/clamp":75,"./util/clearOwnProperties":76,"./util/cmp":77,"./util/compose":78,"./util/convertFov":79,"./util/decimal":80,"./util/defaults":81,"./util/defer":82,"./util/degToRad":83,"./util/delay":84,"./util/dom":85,"./util/extend":86,"./util/hash":88,"./util/inherits":89,"./util/mod":91,"./util/noop":92,"./util/now":93,"./util/once":94,"./util/pixelRatio":95,"./util/radToDeg":97,"./util/real":98,"./util/retry":99,"./util/tween":100,"./util/type":101,"./views/Flat":102,"./views/Rectilinear":103,"bowser":1,"gl-matrix":3,"hammerjs":13,"minimal-event-emitter":14}],55:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var StaticAsset = require('../assets/Static');
var NetworkError = require('../NetworkError');
var global = require('../util/global');
var once = require('../util/once');

// TODO: Move the load queue into the loader.

// Options for createImageBitmap.
var createImageBitmapOpts = {
  imageOrientation: 'flipY',
  premultiplyAlpha: 'premultiply',
  resizeQuality: 'high'
};

/**
 * @class HtmlImageLoader
 * @implements ImageLoader
 * @classdesc
 *
 * A {@link Loader} for HTML images.
 *
 * @param {Stage} stage The stage which is going to request images to be loaded.
 */
function HtmlImageLoader(stage) {
  this._stage = stage;
}

/**
 * Loads an {@link Asset} from an image.
 * @param {string} url The image URL.
 * @param {?Rect} rect A {@link Rect} describing a portion of the image, or null
 *     to use the full image.
 * @param {function(?Error, Asset)} done The callback.
 * @return {function()} A function to cancel loading.
 */
HtmlImageLoader.prototype.loadImage = function(url, rect, done) {
  var self = this;

  var img = new Image();

  // Allow cross-domain image loading.
  // This is required to be able to create WebGL textures from images fetched
  // from a different domain. Note that setting the crossorigin attribute to
  // 'anonymous' will trigger a CORS preflight for cross-domain requests, but no
  // credentials (cookies or HTTP auth) will be sent; to do so, the attribute
  // would have to be set to 'use-credentials' instead. Unfortunately, this is
  // not a safe choice, as it causes requests to fail when the response contains
  // an Access-Control-Allow-Origin header with a wildcard. See the section
  // "Credentialed requests and wildcards" on:
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
  img.crossOrigin = 'anonymous';

  var x = rect && rect.x || 0;
  var y = rect && rect.y || 0;
  var width = rect && rect.width || 1;
  var height = rect && rect.height || 1;

  done = once(done);

  img.onload = function() {
    self._handleLoad(img, x, y, width, height, done);
  };

  img.onerror = function() {
    self._handleError(url, done);
  };

  img.src = url;

  function cancel() {
    img.onload = img.onerror = null;
    img.src = '';
    done.apply(null, arguments);
  }

  return cancel;
};

HtmlImageLoader.prototype._handleLoad = function(img, x, y, width, height, done) {
  if (x === 0 && y === 0 && width === 1 && height === 1) {
    // Fast path for when cropping is not needed.
    done(null, new StaticAsset(img));
    return;
  }

  x *= img.naturalWidth;
  y *= img.naturalHeight;
  width *= img.naturalWidth;
  height *= img.naturalHeight;

  if (global.createImageBitmap) {
    // Prefer to crop using createImageBitmap, which can potentially offload
    // work to another thread and avoid blocking the user interface.
    // Assume that the promise is never rejected.
    global.createImageBitmap(img, x, y, width, height, createImageBitmapOpts)
      .then(function(bitmap) {
        done(null, new StaticAsset(bitmap));
      });
  } else {
    // Fall back to cropping using a canvas, which can potentially block the
    // user interface, but is the best we can do.
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var context = canvas.getContext('2d');
    context.drawImage(img, x, y, width, height, 0, 0, width, height);
    done(null, new StaticAsset(canvas));
  }
};

HtmlImageLoader.prototype._handleError = function(url, done) {
  // TODO: is there any way to distinguish a network error from other
  // kinds of errors? For now we always return NetworkError since this
  // prevents images to be retried continuously while we are offline.
  done(new NetworkError('Network error: ' + url));
};

module.exports = HtmlImageLoader;

},{"../NetworkError":18,"../assets/Static":26,"../util/global":87,"../util/once":94}],56:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mat4 = require('gl-matrix').mat4;
var vec3 = require('gl-matrix').vec3;
var clearOwnProperties = require('../util/clearOwnProperties');

var WebGlCommon = require('./WebGlCommon');
var createConstantBuffers = WebGlCommon.createConstantBuffers;
var destroyConstantBuffers = WebGlCommon.destroyConstantBuffers;
var createShaderProgram = WebGlCommon.createShaderProgram;
var destroyShaderProgram = WebGlCommon.destroyShaderProgram;
var enableAttributes = WebGlCommon.enableAttributes;
var disableAttributes = WebGlCommon.disableAttributes;
var setViewport = WebGlCommon.setViewport;
var setupPixelEffectUniforms = WebGlCommon.setupPixelEffectUniforms;

var setDepth = WebGlCommon.setDepth;
var setTexture = WebGlCommon.setTexture;

var vertexSrc = require('../shaders/vertexNormal');
var fragmentSrc = require('../shaders/fragmentNormal');

var vertexIndices = [0, 1, 2, 0, 2, 3];
var vertexPositions = [-0.5, -0.5, 0.0, 0.5, -0.5, 0.0, 0.5, 0.5, 0.0, -0.5, 0.5, 0.0];
var textureCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];

var attribList = ['aVertexPosition', 'aTextureCoord'];
var uniformList = [
  'uDepth', 'uOpacity', 'uSampler', 'uProjMatrix', 'uViewportMatrix',
  'uColorOffset', 'uColorMatrix'
];


function WebGlBaseRenderer(gl) {
  this.gl = gl;

  // The projection matrix positions the tiles in world space.
  // We compute it in Javascript because lack of precision in the vertex shader
  // causes seams to appear between adjacent tiles at large zoom levels.
  this.projMatrix = mat4.create();

  // The viewport matrix responsible for viewport clamping.
  // See setViewport() for an explanation of how it works.
  this.viewportMatrix = mat4.create();

  // Translation and scale vectors for tiles.
  this.translateVector = vec3.create();
  this.scaleVector = vec3.create();

  this.constantBuffers = createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords);

  this.shaderProgram = createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList);
}

WebGlBaseRenderer.prototype.destroy = function() {
  destroyConstantBuffers(this.gl, this.constantBuffers);
  destroyShaderProgram(this.gl, this.shaderProgram);
  clearOwnProperties(this);
};

WebGlBaseRenderer.prototype.startLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var viewportMatrix = this.viewportMatrix;

  gl.useProgram(shaderProgram);

  enableAttributes(gl, shaderProgram);

  setViewport(gl, layer, rect, viewportMatrix);
  gl.uniformMatrix4fv(shaderProgram.uViewportMatrix, false, viewportMatrix);

  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.vertexPositions);
  gl.vertexAttribPointer(shaderProgram.aVertexPosition, 3, gl.FLOAT, gl.FALSE, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.textureCoords);
  gl.vertexAttribPointer(shaderProgram.aTextureCoord, 2, gl.FLOAT, gl.FALSE, 0, 0);

  setupPixelEffectUniforms(gl, layer.effects(), {
    opacity: shaderProgram.uOpacity,
    colorOffset: shaderProgram.uColorOffset,
    colorMatrix: shaderProgram.uColorMatrix
  });
};


WebGlBaseRenderer.prototype.endLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  disableAttributes(gl, shaderProgram);
};


WebGlBaseRenderer.prototype.renderTile = function(tile, texture, layer, layerZ) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var projMatrix = this.projMatrix;
  var translateVector = this.translateVector;
  var scaleVector = this.scaleVector;

  translateVector[0] = tile.centerX();
  translateVector[1] = tile.centerY();
  translateVector[2] = -0.5;

  scaleVector[0] = tile.scaleX();
  scaleVector[1] = tile.scaleY();
  scaleVector[2] = 1.0;

  mat4.copy(projMatrix, layer.view().projection());
  mat4.rotateX(projMatrix, projMatrix, tile.rotX());
  mat4.rotateY(projMatrix, projMatrix, tile.rotY());
  mat4.translate(projMatrix, projMatrix, translateVector);
  mat4.scale(projMatrix, projMatrix, scaleVector);

  gl.uniformMatrix4fv(shaderProgram.uProjMatrix, false, projMatrix);

  setDepth(gl, shaderProgram, layerZ, tile.z);

  setTexture(gl, shaderProgram, texture);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, constantBuffers.vertexIndices);
  gl.drawElements(gl.TRIANGLES, vertexIndices.length, gl.UNSIGNED_SHORT, 0);
};


module.exports = WebGlBaseRenderer;

},{"../shaders/fragmentNormal":63,"../shaders/vertexNormal":65,"../util/clearOwnProperties":76,"./WebGlCommon":57,"gl-matrix":3}],57:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// These are used to set the WebGl depth for a tile.
var MAX_LAYERS = 256; // Max number of layers per stage.
var MAX_LEVELS = 256; // Max number of levels per layer.

var clamp = require('../util/clamp');
var vec4 = require('gl-matrix').vec4;
var vec3 = require('gl-matrix').vec3;
var mat4 = require('gl-matrix').mat4;


function createShader(gl, type, src) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw gl.getShaderInfoLog(shader);
  }
  return shader;
}


function createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList) {

  var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSrc);
  var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);

  var shaderProgram = gl.createProgram();

  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);

  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    throw gl.getProgramInfoLog(shaderProgram);
  }

  for (var i = 0; i < attribList.length; i++) {
    var attrib = attribList[i];
    shaderProgram[attrib] = gl.getAttribLocation(shaderProgram, attrib);
    if (shaderProgram[attrib] === -1) {
      throw new Error('Shader program has no ' + attrib + ' attribute');
    }
  }

  for (var j = 0; j < uniformList.length; j++) {
    var uniform = uniformList[j];
    shaderProgram[uniform] = gl.getUniformLocation(shaderProgram, uniform);
    if (shaderProgram[uniform] === -1) {
      throw new Error('Shader program has no ' + uniform + ' uniform');
    }
  }

  return shaderProgram;
}


function destroyShaderProgram(gl, shaderProgram) {
  var shaderList = gl.getAttachedShaders(shaderProgram);
  for (var i = 0; i < shaderList.length; i++) {
    var shader = shaderList[i];
    gl.detachShader(shaderProgram, shader);
    gl.deleteShader(shader);
  }
  gl.deleteProgram(shaderProgram);
}


function createConstantBuffer(gl, target, usage, value) {
  var buffer = gl.createBuffer();
  gl.bindBuffer(target, buffer);
  gl.bufferData(target, value, usage);
  return buffer;
}


function createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords) {
  return {
    vertexIndices: createConstantBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, new Uint16Array(vertexIndices)),
    vertexPositions: createConstantBuffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW, new Float32Array(vertexPositions)),
    textureCoords: createConstantBuffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW, new Float32Array(textureCoords))
  };
}


function destroyConstantBuffers(gl, constantBuffers) {
  gl.deleteBuffer(constantBuffers.vertexIndices);
  gl.deleteBuffer(constantBuffers.vertexPositions);
  gl.deleteBuffer(constantBuffers.textureCoords);
}


function enableAttributes(gl, shaderProgram) {
  var numAttrs = gl.getProgramParameter(shaderProgram, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < numAttrs; i++) {
    gl.enableVertexAttribArray(i);
  }
}


function disableAttributes(gl, shaderProgram) {
  var numAttrs = gl.getProgramParameter(shaderProgram, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < numAttrs; i++) {
    gl.disableVertexAttribArray(i);
  }
}


function setTexture(gl, shaderProgram, texture) {
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture._texture);
  gl.uniform1i(shaderProgram.uSampler, 0);
}


function setDepth(gl, shaderProgram, layerZ, tileZ) {
  var depth = (((layerZ + 1) * MAX_LEVELS) - tileZ) / (MAX_LEVELS * MAX_LAYERS);
  gl.uniform1f(shaderProgram.uDepth, depth);
}


var defaultOpacity = 1.0;
var defaultColorOffset = vec4.create();
var defaultColorMatrix = mat4.create();
mat4.identity(defaultColorMatrix);

function setupPixelEffectUniforms(gl, effects, uniforms) {
  var opacity = defaultOpacity;
  if (effects && effects.opacity != null) {
    opacity = effects.opacity;
  }
  gl.uniform1f(uniforms.opacity, opacity);

  var colorOffset = defaultColorOffset;
  if (effects && effects.colorOffset) {
    colorOffset = effects.colorOffset;
  }
  gl.uniform4fv(uniforms.colorOffset, colorOffset);

  var colorMatrix = defaultColorMatrix;
  if (effects && effects.colorMatrix) {
    colorMatrix = effects.colorMatrix;
  }
  gl.uniformMatrix4fv(uniforms.colorMatrix, false, colorMatrix);
}


// Temporary vectors for setViewport.
var translateVector = vec3.create();
var scaleVector = vec3.create();


// Sets the WebGL viewport and returns a viewport clamping compensation matrix.
//
// Negative viewport origin coordinates cause rendering issues. Letting the
// viewport dimensions extend beyond the visible area do not seem to cause
// rendering issues, but they may still have an impact on performance.
// Therefore, when the scene's rect is not fully contained in the rendering
// area, we clamp the viewport to the rendering area, and return a compensation
// matrix to scale and translate vertices accordingly.
function setViewport(gl, layer, rect, viewportMatrix) {
  if (rect.x === 0 && rect.width === 1 && rect.y === 0 && rect.height === 1) {
    // Fast path for full rect.
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    mat4.identity(viewportMatrix);
    return;
  }

  var offsetX = rect.x;
  var clampedOffsetX = clamp(offsetX, 0, 1);
  var leftExcess = clampedOffsetX - offsetX;
  var maxClampedWidth = 1 - clampedOffsetX;
  var clampedWidth = clamp(rect.width - leftExcess, 0, maxClampedWidth);
  var rightExcess = rect.width - clampedWidth;

  var offsetY = 1 - rect.height - rect.y;
  var clampedOffsetY = clamp(offsetY, 0, 1);
  var bottomExcess = clampedOffsetY - offsetY;
  var maxClampedHeight = 1 - clampedOffsetY;
  var clampedHeight = clamp(rect.height - bottomExcess, 0, maxClampedHeight);
  var topExcess = rect.height - clampedHeight;

  vec3.set(
    scaleVector,
    rect.width / clampedWidth,
    rect.height / clampedHeight,
    1);

  vec3.set(
    translateVector,
    (rightExcess - leftExcess) / clampedWidth,
    (topExcess - bottomExcess) / clampedHeight,
    0);

  mat4.identity(viewportMatrix);
  mat4.translate(viewportMatrix, viewportMatrix, translateVector);
  mat4.scale(viewportMatrix, viewportMatrix, scaleVector);

  gl.viewport(gl.drawingBufferWidth * clampedOffsetX,
              gl.drawingBufferHeight * clampedOffsetY,
              gl.drawingBufferWidth * clampedWidth,
              gl.drawingBufferHeight * clampedHeight);
}

module.exports = {
  createShaderProgram: createShaderProgram,
  destroyShaderProgram: destroyShaderProgram,
  createConstantBuffers: createConstantBuffers,
  destroyConstantBuffers: destroyConstantBuffers,
  enableAttributes: enableAttributes,
  disableAttributes: disableAttributes,
  setTexture: setTexture,
  setDepth: setDepth,
  setViewport: setViewport,
  setupPixelEffectUniforms: setupPixelEffectUniforms
};

},{"../util/clamp":75,"gl-matrix":3}],58:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WebGlBaseRenderer = require('./WebGlBase');
var inherits = require('../util/inherits');

/**
 * @class WebGlCubeRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link CubeGeometry} and {@link RectilinearView}, appropriate
 * for a {@link WebGlStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function WebGlCubeRenderer() {
  this.constructor.super_.apply(this, arguments);
}

inherits(WebGlCubeRenderer, WebGlBaseRenderer);

module.exports = WebGlCubeRenderer;

},{"../util/inherits":89,"./WebGlBase":56}],59:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mat4 = require('gl-matrix').mat4;
var clearOwnProperties = require('../util/clearOwnProperties');

var WebGlCommon = require('./WebGlCommon');
var createConstantBuffers = WebGlCommon.createConstantBuffers;
var destroyConstantBuffers = WebGlCommon.destroyConstantBuffers;
var createShaderProgram = WebGlCommon.createShaderProgram;
var destroyShaderProgram = WebGlCommon.destroyShaderProgram;
var enableAttributes = WebGlCommon.enableAttributes;
var disableAttributes = WebGlCommon.disableAttributes;
var setViewport = WebGlCommon.setViewport;
var setupPixelEffectUniforms = WebGlCommon.setupPixelEffectUniforms;

var setDepth = WebGlCommon.setDepth;
var setTexture = WebGlCommon.setTexture;

var vertexSrc = require('../shaders/vertexEquirect');
var fragmentSrc = require('../shaders/fragmentEquirect');

var vertexIndices = [0, 1, 2, 0, 2, 3];
var vertexPositions = [-1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 1.0, 0.0];
var textureCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];

var attribList = ['aVertexPosition'];
var uniformList = [
  'uDepth', 'uOpacity', 'uSampler', 'uInvProjMatrix', 'uViewportMatrix',
  'uColorOffset', 'uColorMatrix', 'uTextureX', 'uTextureY', 'uTextureWidth',
  'uTextureHeight'
];


/**
 * @class WebGlEquirectRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link EquirectGeometry} and {@link RectilinearView},
 * appropriate for {@link WebGlStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function WebGlEquirectRenderer(gl) {
  this.gl = gl;

  // The inverse projection matrix.
  this.invProjMatrix = mat4.create();

  // The viewport matrix responsible for viewport clamping.
  // See setViewport() for an explanation of how it works.
  this.viewportMatrix = mat4.create();

  this.constantBuffers = createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords);

  this.shaderProgram = createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList);
}

WebGlEquirectRenderer.prototype.destroy = function() {
  destroyConstantBuffers(this.gl, this.constantBuffers);
  destroyShaderProgram(this.gl, this.shaderProgram);
  clearOwnProperties(this);
};


WebGlEquirectRenderer.prototype.startLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var invProjMatrix = this.invProjMatrix;
  var viewportMatrix = this.viewportMatrix;

  gl.useProgram(shaderProgram);

  enableAttributes(gl, shaderProgram);

  setViewport(gl, layer, rect, viewportMatrix);
  gl.uniformMatrix4fv(shaderProgram.uViewportMatrix, false, viewportMatrix);

  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.vertexPositions);
  gl.vertexAttribPointer(shaderProgram.aVertexPosition, 3, gl.FLOAT, gl.FALSE, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.textureCoords);

  // Compute and set the inverse projection matrix.
  mat4.copy(invProjMatrix, layer.view().projection());
  mat4.invert(invProjMatrix, invProjMatrix);

  gl.uniformMatrix4fv(shaderProgram.uInvProjMatrix, false, invProjMatrix);

  // Compute and set the texture scale and crop offsets.
  var textureCrop = layer.effects().textureCrop || {};
  var textureX = textureCrop.x != null ? textureCrop.x : 0;
  var textureY = textureCrop.y != null ? textureCrop.y : 0;
  var textureWidth = textureCrop.width != null ? textureCrop.width : 1;
  var textureHeight = textureCrop.height != null ? textureCrop.height : 1;

  gl.uniform1f(shaderProgram.uTextureX, textureX);
  gl.uniform1f(shaderProgram.uTextureY, textureY);
  gl.uniform1f(shaderProgram.uTextureWidth, textureWidth);
  gl.uniform1f(shaderProgram.uTextureHeight, textureHeight);

  setupPixelEffectUniforms(gl, layer.effects(), {
    opacity: shaderProgram.uOpacity,
    colorOffset: shaderProgram.uColorOffset,
    colorMatrix: shaderProgram.uColorMatrix
  });
};


WebGlEquirectRenderer.prototype.endLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  disableAttributes(gl, shaderProgram);
};


WebGlEquirectRenderer.prototype.renderTile = function(tile, texture, layer, layerZ) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;

  setDepth(gl, shaderProgram, layerZ, tile.z);

  setTexture(gl, shaderProgram, texture);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, constantBuffers.vertexIndices);
  gl.drawElements(gl.TRIANGLES, vertexIndices.length, gl.UNSIGNED_SHORT, 0);
};


module.exports = WebGlEquirectRenderer;

},{"../shaders/fragmentEquirect":62,"../shaders/vertexEquirect":64,"../util/clearOwnProperties":76,"./WebGlCommon":57,"gl-matrix":3}],60:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WebGlBaseRenderer = require('./WebGlBase');
var inherits = require('../util/inherits');

/**
 * @class WebGlFlatRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link FlatGeometry} and {@link FlatView}, appropriate for a
 * {@link WebGlStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function WebGlFlatRenderer() {
  this.constructor.super_.apply(this, arguments);
}

inherits(WebGlFlatRenderer, WebGlBaseRenderer);

module.exports = WebGlFlatRenderer;

},{"../util/inherits":89,"./WebGlBase":56}],61:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WebGlCube = require('./WebGlCube');
var WebGlFlat = require('./WebGlFlat');
var WebGlEquirect = require('./WebGlEquirect');

/**
 * Registers all known renderers for the given stage type into that stage.
 * Most users will not need to register renderers, as {@link Viewer} does it for
 * them.
 *
 * @param {Stage} stage The stage where the renderers are to be registered.
 * @throws An error if the stage type is unknown.
 */
function registerDefaultRenderers(stage) {
  switch (stage.type) {
    case 'webgl':
      stage.registerRenderer('flat', 'flat', WebGlFlat);
      stage.registerRenderer('cube', 'rectilinear', WebGlCube);
      stage.registerRenderer('equirect', 'rectilinear', WebGlEquirect);
      break;
    default:
      throw new Error('Unknown stage type: ' + stage.type);
  }
}

module.exports = registerDefaultRenderers;

},{"./WebGlCube":58,"./WebGlEquirect":59,"./WebGlFlat":60}],62:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'#ifdef GL_FRAGMENT_PRECISION_HIGH',
'precision highp float;',
'#else',
'precision mediump float',
'#endif',

'uniform sampler2D uSampler;',
'uniform float uOpacity;',
'uniform float uTextureX;',
'uniform float uTextureY;',
'uniform float uTextureWidth;',
'uniform float uTextureHeight;',
'uniform vec4 uColorOffset;',
'uniform mat4 uColorMatrix;',

'varying vec4 vRay;',

'const float PI = 3.14159265358979323846264;',

'void main(void) {',
'  float r = inversesqrt(vRay.x * vRay.x + vRay.y * vRay.y + vRay.z * vRay.z);',
'  float phi  = acos(vRay.y * r);',
'  float theta = atan(vRay.x, -1.0*vRay.z);',
'  float s = 0.5 + 0.5 * theta / PI;',
'  float t = 1.0 - phi / PI;',

'  s = s * uTextureWidth + uTextureX;',
'  t = t * uTextureHeight + uTextureY;',

'  vec4 color = texture2D(uSampler, vec2(s, t)) * uColorMatrix + uColorOffset;',
'  gl_FragColor = vec4(color.rgba * uOpacity);',
'}'
].join('\n');

},{}],63:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'#ifdef GL_FRAGMENT_PRECISION_HIGH',
'precision highp float;',
'#else',
'precision mediump float;',
'#endif',

'uniform sampler2D uSampler;',
'uniform float uOpacity;',
'uniform vec4 uColorOffset;',
'uniform mat4 uColorMatrix;',

'varying vec2 vTextureCoord;',

'void main(void) {',
'  vec4 color = texture2D(uSampler, vTextureCoord) * uColorMatrix + uColorOffset;',
'  gl_FragColor = vec4(color.rgba * uOpacity);',
'}'
].join('\n');

},{}],64:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'attribute vec3 aVertexPosition;',

'uniform float uDepth;',
'uniform mat4 uViewportMatrix;',
'uniform mat4 uInvProjMatrix;',

'varying vec4 vRay;',

'void main(void) {',
'  vRay = uInvProjMatrix * vec4(aVertexPosition.xy, 1.0, 1.0);',
'  gl_Position = uViewportMatrix * vec4(aVertexPosition.xy, uDepth, 1.0);',
'}'
].join('\n');

},{}],65:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'attribute vec3 aVertexPosition;',
'attribute vec2 aTextureCoord;',

'uniform float uDepth;',
'uniform mat4 uViewportMatrix;',
'uniform mat4 uProjMatrix;',

'varying vec2 vTextureCoord;',

'void main(void) {',
'  gl_Position = uViewportMatrix * uProjMatrix * vec4(aVertexPosition.xy, 0.0, 1.0);',
'  gl_Position.z = uDepth * gl_Position.w;',
'  vTextureCoord = aTextureCoord;',
'}'
].join('\n');

},{}],66:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var NetworkError = require('../NetworkError');
var WorkPool = require('../collections/WorkPool');
var chain = require('../util/chain');
var delay = require('../util/delay');
var now = require('../util/now');


// Map template properties to their corresponding tile properties.
var templateProperties = {
  x: 'x',
  y: 'y',
  z: 'z',
  f: 'face'
};

// Default face order for cube maps.
var defaultCubeMapFaceOrder = 'bdflru';

// Default maximum number of concurrent requests.
var defaultConcurrency = 4;

// Default milliseconds to wait before retrying failed requests.
var defaultRetryDelay = 10000;


/**
 * @class ImageUrlSource
 * @implements Source
 * @classdesc
 *
 * A {@link Source} that loads {@link Asset assets} from images given a URL and
 * a crop rectangle.
 *
 * @param {Function} sourceFromTile Function that receives a tile and returns
 * a `{ url, rect }` object, where `url` is an image URL and `rect`, when
 * present, is an `{ x, y, width, height }` object in normalized coordinates
 * denoting the portion of the image to use.
 * @param {Object} opts
 * @param {number} [opts.concurrency=4] Maximum number of tiles to request at
 *     the same time. The limit is per {@link ImageSourceUrl} instance.
 * @param {number} [opts.retryDelay=10000] Time in milliseconds to wait before
 *     retrying a failed request.
 */
function ImageUrlSource(sourceFromTile, opts) {

  opts = opts ? opts : {};

  this._loadPool = new WorkPool({
    concurrency: opts.concurrency || defaultConcurrency
  });

  this._retryDelay = opts.retryDelay || defaultRetryDelay;
  this._retryMap = {};

  this._sourceFromTile = sourceFromTile;
}

eventEmitter(ImageUrlSource);


ImageUrlSource.prototype.loadAsset = function(stage, tile, done) {

  var self = this;

  var retryDelay = this._retryDelay;
  var retryMap = this._retryMap;

  var tileSource = this._sourceFromTile(tile);
  var url = tileSource.url;
  var rect = tileSource.rect;

  var loadImage = stage.loadImage.bind(stage, url, rect);

  var loadFn = function(done) {
    // TODO: Deduplicate load requests for the same URL. Although the browser
    // might be smart enough to avoid duplicate requests, they are still unduly
    // impacted by the concurrency parameter.
    return self._loadPool.push(loadImage, function(err, asset) {
      if (err) {
        if (err instanceof NetworkError) {
          // If a network error occurred, wait before retrying.
          retryMap[url] = now();
          self.emit('networkError', err, tile);
        }
        done(err, tile);
      } else {
        // On a successful fetch, forget the previous timeout.
        delete retryMap[url];
        done(null, tile, asset);
      }
    });
  };

  // Check whether we are retrying a failed request.
  var delayAmount;
  var lastTime = retryMap[url];
  if (lastTime != null) {
    var currentTime = now();
    var elapsed = currentTime - lastTime;
    if (elapsed < retryDelay) {
      // Wait before retrying.
      delayAmount = retryDelay - elapsed;
    } else {
      // Retry timeout expired; perform the request at once.
      delayAmount = 0;
      delete retryMap[url];
    }
  }

  var delayFn = delay.bind(null, delayAmount);

  return chain(delayFn, loadFn)(done);
};


/**
 * Creates an ImageUrlSource from a string template.
 *
 * @param {String} url Tile URL template, which may contain the following
 *    placeholders:
 *    - `{f}` : tile face (one of `b`, `d`, `f`, `l`, `r`, `u`)
 *    - `{z}` : tile level index (0 is the smallest level)
 *    - `{x}` : tile horizontal index
 *    - `{y}` : tile vertical index
 * @param {Object} opts In addition to the options already supported by the
 *     {@link ImageUrlSource} constructor.
 * @param {String} opts.cubeMapPreviewUrl URL to use as the preview level.
 *     This must be a single image containing six cube faces laid out
 *     vertically according to the face order parameter.
 * @param {String} [opts.cubeMapPreviewFaceOrder='bdflru'] Face order within
 *     the preview image.
 */
ImageUrlSource.fromString = function(url, opts) {
  opts = opts || {};

  var faceOrder = opts && opts.cubeMapPreviewFaceOrder || defaultCubeMapFaceOrder;

  var urlFn = opts.cubeMapPreviewUrl ? withPreview : withoutPreview;

  return new ImageUrlSource(urlFn, opts);

  function withoutPreview(tile) {
    var tileUrl = url;

    for (var property in templateProperties) {
      var templateProperty = templateProperties[property];
      var regExp = propertyRegExp(property);
      var valueFromTile = tile.hasOwnProperty(templateProperty) ? tile[templateProperty] : '';
      tileUrl = tileUrl.replace(regExp, valueFromTile);
    }

    return { url: tileUrl };
  }

  function withPreview(tile) {
    if (tile.z === 0) {
      return cubeMapUrl(tile);
    }
    else {
      return withoutPreview(tile);
    }
  }

  function cubeMapUrl(tile) {
    var y = faceOrder.indexOf(tile.face) / 6;
    return {
      url: opts.cubeMapPreviewUrl,
      rect: { x: 0, y: y, width: 1, height: 1/6 }
    };
  }
};

function propertyRegExp(property) {
  var regExpStr = '\\{(' + property + ')\\}';
  return new RegExp(regExpStr, 'g');
}

module.exports = ImageUrlSource;

},{"../NetworkError":18,"../collections/WorkPool":32,"../util/chain":74,"../util/delay":84,"../util/now":93,"minimal-event-emitter":14}],67:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @class SingleAssetSource
 * @implements Source
 * @classdesc
 *
 * A {@link Source} that always provides the same {@link Asset}.
 *
 * @param {Asset} asset The asset.
*/
function SingleAssetSource(asset) {
  this._asset = asset;
}

SingleAssetSource.prototype.asset = function() {
  return this._asset;
};

SingleAssetSource.prototype.loadAsset = function(stage, tile, done) {
  var self = this;

  var timeout = setTimeout(function() {
    done(null, tile, self._asset);
  }, 0);

  function cancel() {
    clearTimeout(timeout);
    done.apply(null, arguments);
  }

  return cancel;
};

module.exports = SingleAssetSource;

},{}],68:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @class RendererRegistry
 * @classdesc
 *
 * A RendererRegistry maps pairs of {@link Geometry} and {@link View} type into
 * the appropriate {@link Renderer} class. It is used by a {@link Stage} to
 * determine the appropriate renderer for a {@link Layer}.
 *
 * See also {@link Stage#registerRenderer}.
 */
function RendererRegistry() {
  this._renderers = {};
}

/**
 * Registers a renderer for the given geometry and view type.
 * @param {string} geometryType The geometry type, as given by
 *     {@link Geometry#type}.
 * @param {string} viewType The view type, as given by {@link View#type}.
 * @param {*} Renderer The renderer class.
 */
RendererRegistry.prototype.set = function(geometryType, viewType, Renderer) {
  if (!this._renderers[geometryType]) {
    this._renderers[geometryType] = {};
  }
  this._renderers[geometryType][viewType] = Renderer;
};

/**
 * Retrieves the renderer for the given geometry and view type.
 * @param {string} geometryType The geometry type, as given by
 *     {@link Geometry#type}.
 * @param {string} viewType The view type, as given by {@link View#type}.
 * @param {*} Renderer The renderer class, or null if no such renderer has been
 * registered.
 */
RendererRegistry.prototype.get = function(geometryType, viewType) {
  var Renderer = this._renderers[geometryType] &&
      this._renderers[geometryType][viewType];
  return Renderer || null;
};

module.exports = RendererRegistry;

},{}],69:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var WorkQueue = require('../collections/WorkQueue');
var calcRect = require('../util/calcRect');
var async = require('../util/async');
var cancelize = require('../util/cancelize');
var clearOwnProperties = require('../util/clearOwnProperties');

var RendererRegistry = require('./RendererRegistry');

function forwardTileCmp(t1, t2) {
    return t1.cmp(t2);
}

function reverseTileCmp(t1, t2) {
    return -t1.cmp(t2);
}

/**
 * Signals that the stage has been rendered.
 *
 * @param {boolean} stable Whether all tiles were successfully rendered without
 *     missing textures or resorting to fallbacks.
 * @event Stage#renderComplete
 */

/**
 * Signals that the contents of the stage have been invalidated and must be
 * rendered again.
 *
 * This is used by the {@link RenderLoop} implementation.
 *
 * @event Stage#renderInvalid
 */

/**
 * @interface Stage
 * @classdesc
 *
 * A Stage is a container with the ability to render a stack of
 * {@link Layer layers}.
 *
 * This class should never be instantiated directly. Use {@link WebGlStage}
 * instead.
 *
 * @param {Object} opts
 * @param {boolean} [opts.progressive=false]
 *
 * Options listed here may be passed into the `opts` constructor argument of
 * subclasses.
 *
 * The `progressive` option controls whether resolution levels are loaded in
 * order, from lowest to highest. This results in a more pleasing effect when
 * zooming past several levels in a large panoramas, but consumes additional
 * bandwidth.
 */
function Stage(opts) {
    this._progressive = !!(opts && opts.progressive);

    // The list of layers in display order (background to foreground).
    this._layers = [];

    // The list of renderers; the i-th renderer is for the i-th layer.
    this._renderers = [];

    // The lists of tiles to load and render, populated during render().
    this._tilesToLoad = [];
    this._tilesToRender = [];

    // Temporary tile lists.
    this._tmpVisible = [];
    this._tmpChildren = [];

    // Cached stage dimensions.
    // Start with zero, which inhibits rendering until setSize() is called.
    this._width = 0;
    this._height = 0;

    // Temporary variable for rect.
    this._tmpRect = {};

    // Temporary variable for size.
    this._tmpSize = {};

    // Work queue for createTexture.
    this._createTextureWorkQueue = new WorkQueue();

    // Function to emit event when render parameters have changed.
    this._emitRenderInvalid = this._emitRenderInvalid.bind(this);

    // The renderer registry maps each geometry/view pair into the respective
    // Renderer class.
    this._rendererRegistry = new RendererRegistry();
}

eventEmitter(Stage);


/**
 * Destructor.
 */
Stage.prototype.destroy = function () {
    this.removeAllLayers();
    clearOwnProperties(this);
};


/**
 * Registers a {@link Renderer} for the given {@link Geometry} and {@link View}
 * type.
 *
 * The {@link registerDefaultRenderers} utility function may be used to
 * register all known renderers for a stage type into that stage. Most users
 * will not need to register renderers, as {@link Viewer} does it for them.
 *
 * @param {string} geometryType The geometry type, as given by
 *     {@link Geometry#type}.
 * @param {string} viewType The view type, as given by {@link View#type}.
 * @param {*} Renderer The renderer class.
 */
Stage.prototype.registerRenderer = function (geometryType, viewType, Renderer) {
    return this._rendererRegistry.set(geometryType, viewType, Renderer);
};


/**
 * Returns the underlying DOM element.
 *
 * Must be overridden by subclasses.
 *
 * @return {Element}
 */
Stage.prototype.domElement = function () {
    throw new Error('Stage implementation must override domElement');
};


/**
 * Get the stage width.
 * @return {number}
 */
Stage.prototype.width = function () {
    return this._width;
};


/**
 * Get the stage height.
 * @return {number}
 */
Stage.prototype.height = function () {
    return this._height;
};


/**
 * Get the stage dimensions. If an argument is supplied, it is filled in with
 * the result and returned. Otherwise, a fresh object is filled in and returned.
 *
 * @param {Size=} size
 */
Stage.prototype.size = function (size) {
    size = size || {};
    size.width = this._width;
    size.height = this._height;
    return size;
};


/**
 * Set the stage dimensions.
 *
 * This contains the size update logic common to all stage types. Subclasses
 * must define the {@link Stage#setSizeForType} method to perform their own
 * logic.
 *
 * @param {Size} size
 */
Stage.prototype.setSize = function (size) {
    this._width = size.width;
    this._height = size.height;

    this.setSizeForType(); // must be defined by subclasses.

    this.emit('resize');
    this._emitRenderInvalid();
};


/**
 * Call {@link Stage#setSize} instead.
 *
 * This contains the size update logic specific to a stage type. It is called by
 * {@link Stage#setSize} after the base class has been updated to reflect the
 * new size, but before any events are emitted.
 *
 * @param {Size} size
 */
Stage.prototype.setSizeForType = function (size) {
    throw new Error('Stage implementation must override setSizeForType');
};


/**
 * Loads an {@link Asset} from an image.
 * @param {string} url The image URL.
 * @param {?Rect} rect A {@link Rect} describing a portion of the image, or null
 *     to use the full image.
 * @param {function(?Error, Asset)} done The callback.
 * @return {function()} A function to cancel loading.
 */
Stage.prototype.loadImage = function () {
    throw new Error('Stage implementation must override loadImage');
};


Stage.prototype._emitRenderInvalid = function () {
    this.emit('renderInvalid');
};


/**
 * Verifies that the layer is valid for this stage, throwing an exception
 * otherwise.
 *
 * @param {Layer} layer
 * @throws {Error} If the layer is not valid for this stage.
 */
Stage.prototype.validateLayer = function (layer) {
    throw new Error('Stage implementation must override validateLayer');
};


/**
 * Returns a list of all {@link Layer layers} belonging to the stage. The
 * returned list is in display order, background to foreground.
 * @return {Layer[]}
 */
Stage.prototype.listLayers = function () {
    // Return a copy to prevent unintended mutation by the caller.
    return [].concat(this._layers);
};


/**
 * Return whether a {@link Layer layer} belongs to the stage.
 * @param {Layer} layer
 * @return {boolean}
 */
Stage.prototype.hasLayer = function (layer) {
    return this._layers.indexOf(layer) >= 0;
};


/**
 * Adds a {@link Layer layer} into the stage.
 * @param {Layer} layer The layer to add.
 * @param {number|undefined} i The optional position, where 0 ≤ i ≤ n and n is
 *     the current number of layers. The default is n, which inserts at the
 *     top of the display stack.
 * @throws An error if the layer already belongs to the stage or if the position
 *     is invalid.
 */
Stage.prototype.addLayer = function (layer, i) {
    if (this._layers.indexOf(layer) >= 0) {
        throw new Error('Layer already in stage');
    }

    if (i == null) {
        i = this._layers.length;
    }
    if (i < 0 || i > this._layers.length) {
        throw new Error('Invalid layer position');
    }

    this.validateLayer(layer); // must be defined by subclasses.

    var geometryType = layer.geometry().type;
    var viewType = layer.view().type;
    var rendererClass = this._rendererRegistry.get(geometryType, viewType);
    if (!rendererClass) {
        throw new Error('No ' + this.type + ' renderer avaiable for ' +
            geometryType + ' geometry and ' + viewType + ' view');
    }
    var renderer = this.createRenderer(rendererClass);

    this._layers.splice(i, 0, layer);
    this._renderers.splice(i, 0, renderer);

    // Listeners for render invalid.
    layer.addEventListener('viewChange', this._emitRenderInvalid);
    layer.addEventListener('effectsChange', this._emitRenderInvalid);
    layer.addEventListener('fixedLevelChange', this._emitRenderInvalid);
    layer.addEventListener('textureStoreChange', this._emitRenderInvalid);

    this._emitRenderInvalid();
};


/**
 * Moves a {@link Layer layer} into a different position in the display stack.
 * @param {Layer} layer The layer to move.
 * @param {number} i The position, where 0 ≤ i ≤ n-1 and n is the current number
 *     of layers.
 * @throws An error if the layer does not belong to the stage or if the position
 *     is invalid.
 */
Stage.prototype.moveLayer = function (layer, i) {
    var index = this._layers.indexOf(layer);
    if (index < 0) {
        throw new Error('No such layer in stage');
    }

    if (i < 0 || i >= this._layers.length) {
        throw new Error('Invalid layer position');
    }

    layer = this._layers.splice(index, 1)[0];
    var renderer = this._renderers.splice(index, 1)[0];

    this._layers.splice(i, 0, layer);
    this._renderers.splice(i, 0, renderer);

    this._emitRenderInvalid();
};


/**
 * Removes a {@link Layer} from the stage.
 * @param {Layer} layer The layer to remove.
 * @throws An error if the layer does not belong to the stage.
 */
Stage.prototype.removeLayer = function (layer) {
    var index = this._layers.indexOf(layer);
    if (index < 0) {
        throw new Error('No such layer in stage');
    }

    var removedLayer = this._layers.splice(index, 1)[0];
    var renderer = this._renderers.splice(index, 1)[0];

    this.destroyRenderer(renderer);

    removedLayer.removeEventListener('viewChange', this._emitRenderInvalid);
    removedLayer.removeEventListener('effectsChange', this._emitRenderInvalid);
    removedLayer.removeEventListener('fixedLevelChange', this._emitRenderInvalid);
    removedLayer.removeEventListener('textureStoreChange', this._emitRenderInvalid);

    this._emitRenderInvalid();
};


/**
 * Removes all {@link Layer layers} from the stage.
 */
Stage.prototype.removeAllLayers = function () {
    while (this._layers.length > 0) {
        this.removeLayer(this._layers[0]);
    }
};


/**
 * Called before a frame is rendered.
 *
 * Must be overridden by subclasses.
 */
Stage.prototype.startFrame = function () {
    throw new Error('Stage implementation must override startFrame');
};


/**
 * Called after a frame is rendered.
 *
 * Must be overridden by subclasses.
 */
Stage.prototype.endFrame = function () {
    throw new Error('Stage implementation must override endFrame');
};


/**
 * Render the current frame. Usually called from a {@link RenderLoop}.
 *
 * This contains the rendering logic common to all stage types. Subclasses
 * define the startFrame() and endFrame() methods to perform their own logic.
 */
Stage.prototype.render = function () {
    var i, j;

    var tilesToLoad = this._tilesToLoad;
    var tilesToRender = this._tilesToRender;

    var stableStage = true;
    var stableLayer;

    // Get the stage dimensions.
    var width = this._width;
    var height = this._height;

    var rect = this._tmpRect;
    var size = this._tmpSize;

    if (width <= 0 || height <= 0) {
        return;
    }

    this.startFrame(); // defined by subclasses

    // Signal start of frame to the texture stores.
    for (i = 0; i < this._layers.length; i++) {
        this._layers[i].textureStore().startFrame();
    }

    // Render layers.
    for (i = 0; i < this._layers.length; i++) {
        var layer = this._layers[i];
        var effects = layer.effects();
        var view = layer.view();
        var textureStore = layer.textureStore();
        var renderer = this._renderers[i];
        var depth = this._layers.length - i;
        var tile, texture;

        // Convert the rect effect into a normalized rect.
        // TODO: avoid doing this on every frame.
        calcRect(width, height, effects && effects.rect, rect);

        if (rect.width <= 0 || rect.height <= 0) {
            // Skip rendering on a null viewport.
            continue;
        }

        // Update the view size.
        size.width = rect.width * this._width;
        size.height = rect.height * this._height;
        view.setSize(size);

        // Signal start of layer to the renderer.
        renderer.startLayer(layer, rect);

        // We render with both alpha blending and depth testing enabled. Thus, when
        // rendering a subsequent pixel at the same location than an existing one,
        // the subsequent pixel gets discarded unless it has smaller depth, and is
        // otherwise composited with the existing pixel.
        //
        // When using fallback tiles to fill a gap in the preferred resolution
        // level, we prefer higher resolution fallbacks to lower resolution ones.
        // However, where fallbacks overlap, we want higher resolution ones to
        // prevail, and we don't want multiple fallbacks to be composited with each
        // other, as that would produce a bad result when semitransparent textures
        // are involved.
        //
        // In order to achieve this within the constraints of alpha blending and
        // depth testing, the depth of a tile must be inversely proportional to its
        // resolution, and higher-resolution tiles must be rendered before lower-
        // resolution ones.

        // Collect the lists of tiles to load and render.
        stableLayer = this._collectTiles(layer, textureStore);

        // Mark all the tiles whose textures must be loaded.
        // This will either trigger loading (for textures not yet loaded) or
        // prevent unloading (for textures already loaded).
        for (j = 0; j < tilesToLoad.length; j++) {
            tile = tilesToLoad[j];
            textureStore.markTile(tile);
        }

        // Render tiles.
        for (j = 0; j < tilesToRender.length; j++) {
            tile = tilesToRender[j];
            texture = textureStore.texture(tile);
            renderer.renderTile(tile, texture, layer, depth);
        }

        layer.emit('renderComplete', stableLayer);
        if (!stableLayer) {
            stableStage = false;
        }

        // Signal end of layer to the renderer.
        renderer.endLayer(layer, rect);
    }

    // Signal end of frame to the texture stores.
    for (i = 0; i < this._layers.length; i++) {
        this._layers[i].textureStore().endFrame();
    }

    this.endFrame(); // defined by subclasses

    this.emit('renderComplete', stableStage);
};

Stage.prototype._collectTiles = function (layer, textureStore) {
    var tilesToLoad = this._tilesToLoad;
    var tilesToRender = this._tilesToRender;
    var tmpVisible = this._tmpVisible;

    tilesToLoad.length = 0;
    tilesToRender.length = 0;
    tmpVisible.length = 0;

    layer.visibleTiles(tmpVisible);

    var isStable = true;

    for (var i = 0; i < tmpVisible.length; i++) {
        var tile = tmpVisible[i];
        var needsFallback;
        this._collectTileToLoad(tile);
        if (textureStore.texture(tile)) {
            // The preferred texture is available.
            // No fallback is required.
            needsFallback = false;
            this._collectTileToRender(tile);
        } else {
            // The preferred texture is unavailable.
            // Collect children for rendering as a fallback.
            needsFallback = this._collectChildren(tile, textureStore);
            isStable = false;
        }
        // Collect all parents for loading, and the closest parent for rendering if
        // a fallback is required.
        this._collectParents(tile, textureStore, needsFallback);
    }

    // Sort tiles to load in ascending resolution order.
    tilesToLoad.sort(forwardTileCmp);

    // Sort tiles to render in descending resolution order.
    tilesToRender.sort(reverseTileCmp);

    return isStable;
};

Stage.prototype._collectChildren = function (tile, textureStore) {
    var tmpChildren = this._tmpChildren;

    var needsFallback = true;

    // Fall back as many levels as necessary on single-child geometries, but do
    // not go beyond immediate children on multiple-child geometries, to avoid
    // exploring an exponential number of tiles.
    do {
        tmpChildren.length = 0;
        if (!tile.children(tmpChildren)) {
            break;
        }
        needsFallback = false;
        for (var i = 0; i < tmpChildren.length; i++) {
            tile = tmpChildren[i];
            if (textureStore.texture(tile)) {
                this._collectTileToLoad(tile);
                this._collectTileToRender(tile);
            } else {
                needsFallback = true;
            }
        }
    } while (needsFallback && tmpChildren.length === 1)

    return needsFallback;
};

Stage.prototype._collectParents = function (tile, textureStore, needsFallback) {
    // Recursively visit parent tiles until:
    //   - all parents have been marked for loading, if progressive rendering is
    //     enabled; and
    //   - at least one parent has been marked for both loading and rendering, if
    //     a fallback is required.
    var needsLoading = this._progressive;
    while ((needsLoading || needsFallback) && (tile = tile.parent()) != null) {
        if (needsFallback) {
            if (textureStore.texture(tile)) {
                this._collectTileToRender(tile);
                needsFallback = false;
            } else if (!this._progressive) {
                continue;
            }
        }
        if (!this._collectTileToLoad(tile)) {
            needsLoading = false;
        }
    }
    return needsFallback;
};

Stage.prototype._collectTileToLoad = function (tile) {
    return this._collectTileIntoList(tile, this._tilesToLoad);
};

Stage.prototype._collectTileToRender = function (tile) {
    return this._collectTileIntoList(tile, this._tilesToRender);
};

Stage.prototype._collectTileIntoList = function (tile, tileList) {
    // TODO: Investigate whether it's worth it to make this better than O(n²).
    var found = false;
    for (var i = 0; i < tileList.length; i++) {
        if (tile.equals(tileList[i])) {
            found = true;
            break;
        }
    }
    if (!found) {
        tileList.push(tile);
    }
    return !found;
};

/**
 * Create a texture for the given tile and asset. Called by {@link TextureStore}.
 * @param {Tile} tile
 * @param {Asset} asset
 * @param {Function} done
 */
Stage.prototype.createTexture = function (tile, asset, done) {

    var self = this;

    function makeTexture() {
        return new self.TextureClass(self, tile, asset);
    }

    var fn = cancelize(async(makeTexture));

    return this._createTextureWorkQueue.push(fn, function (err, texture) {
        done(err, tile, asset, texture);
    });

};

/**
 * The stage type, used to determine the appropriate renderer for a given
 * geometry and view.
 *
 * The sole known value is `"webgl".
 *
 * See also {@link Stage#registerRenderer}.
 *
 * @property {string}
 * @name Stage#type
 */

module.exports = Stage;

},{"../collections/WorkQueue":33,"../util/async":71,"../util/calcRect":72,"../util/cancelize":73,"../util/clearOwnProperties":76,"./RendererRegistry":68,"minimal-event-emitter":14}],70:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Stage = require('./Stage');
var HtmlImageLoader = require('../loaders/HtmlImage');
var browser = require('bowser');
var inherits = require('../util/inherits');
var pixelRatio = require('../util/pixelRatio');
var ispot = require('../util/ispot');
var setAbsolute = require('../util/dom').setAbsolute;
var setFullSize = require('../util/dom').setFullSize;
var clearOwnProperties = require('../util/clearOwnProperties');

// TODO(tjgq): Unify Stage and WebGlStage.

// Browser-specific workarounds.
var browserQuirks = {
    // Whether to use texImage2D instead of texSubImage2D when repainting an
    // existing texture from a video element. On most browsers texSubImage2D is
    // faster, but on Chrome the performance degrades significantly. See:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=612542
    videoUseTexImage2D: browser.chrome
};


function initWebGlContext(canvas, opts) {
    var options = {
        alpha: true,
        premultipliedAlpha: true,
        antialias: !!(opts && opts.antialias),
        preserveDrawingBuffer: !!(opts && opts.preserveDrawingBuffer),
        xrCompatible: !!(opts && opts.xrCompatible)
    };

    var gl = (canvas.getContext) && (canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options));

    if (!gl) {
        throw new Error('Could not get WebGL context');
    }

    if (opts.wrapContext) {
        gl = opts.wrapContext(gl);
    }

    return gl;
}

/**
 * @class WebGlStage
 * @extends Stage
 * @classdesc
 *
 * A {@link Stage} implementation using WebGl.
 *
 * @param {Object} opts
 * @param {boolean} [opts.antialias=false]
 * @param {boolean} [opts.preserveDrawingBuffer=false]
 * @param {boolean} [opts.generateMipmaps=false]
 * @param {function} [opts.wrapContext]
 *
 * The `antialias` and `preserveDrawingBuffer` options control the WebGL
 * context attributes of the same name. The `alpha` and `premultipliedAlpha`
 * WebGL context attributes are set to their default true value and cannot
 * be overriden; this allows semitransparent textures to be composited with
 * the page. See:
 * https://www.khronos.org/registry/webgl/specs/1.0/#WEBGLCONTEXTATTRIBUTES
 *
 * The `generateMipmaps` option controls texture mipmap generation. Mipmaps
 * may improve rendering quality, at the cost of increased memory usage.
 * Due to technical limitations, they are only generated for textures whose
 * dimensions are a power of two. See:
 * https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support
 *
 * The `wrapContext` option is a function that receives and returns a
 * WebGLRenderingContext. The stage will use its return value as the context.
 * This is useful when used together with WebGLDebugUtils to debug WebGL issues.
 * See https://www.khronos.org/webgl/wiki/Debugging.
 *
 * Also see the available {@link Stage} options.
 */
function WebGlStage(opts) {
    opts = opts || {};

    var self = this;

    this.constructor.super_.call(this, opts);

    this._generateMipmaps = opts.generateMipmaps != null ?
        opts.generateMipmaps : false;

    this._loader = new HtmlImageLoader(this);

    this._domElement = document.createElement('canvas');

    setAbsolute(this._domElement);
    setFullSize(this._domElement);

    this._gl = initWebGlContext(this._domElement, opts);

    this._handleContextLoss = function () {
        self.emit('webglcontextlost');
        self._gl = null;
    };

    // Handle WebGl context loss.
    this._domElement.addEventListener('webglcontextlost', this._handleContextLoss);

    // WebGl renderers are singletons for a given stage. This list stores the
    // existing renderers so they can be reused across layers with the same
    // geometry and view type.
    this._rendererInstances = [];
}

inherits(WebGlStage, Stage);


/**
 * Destructor.
 */
WebGlStage.prototype.destroy = function () {
    this._domElement.removeEventListener('webglcontextlost', this._handleContextLoss);
    // Delegate clearing own properties to the Stage destructor.
    this.constructor.super_.prototype.destroy.call(this);
};


/**
 * Returns the underlying DOM element.
 *
 * @return {Element}
 */
WebGlStage.prototype.domElement = function () {
    return this._domElement;
};


/**
 * Returns the underlying WebGL rendering context.
 *
 * @return {WebGLRenderingContext }
 */
WebGlStage.prototype.webGlContext = function () {
    return this._gl;
};


WebGlStage.prototype.setSizeForType = function () {
    // Update the size of the canvas coordinate space.
    //
    // The size is obtained by taking the stage dimensions, which are set in CSS
    // pixels, and multiplying them by the device pixel ratio. Crucially, this
    // must be the only place where the WebGL rendering pipeline accesses the
    // pixel ratio; subsequent uses should reference the `drawingBufferWidth` and
    // `drawingBufferHeight` properties on the WebGLRenderingContext. Failing to
    // do so will break the rendering if the pixel ratio changes but the stage
    // size does not, e.g. when moving the window across screens.
    var ratio = pixelRatio();
    this._domElement.width = ratio * this._width;
    this._domElement.height = ratio * this._height;
};


WebGlStage.prototype.loadImage = function (url, rect, done) {
    return this._loader.loadImage(url, rect, done);
};


WebGlStage.prototype.maxTextureSize = function () {
    return this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE);
};


WebGlStage.prototype.validateLayer = function (layer) {
    var tileSize = layer.geometry().maxTileSize();
    var maxTextureSize = this.maxTextureSize();
    if (tileSize > maxTextureSize) {
        throw new Error('Layer has level with tile size larger than maximum texture size (' + tileSize + ' vs. ' + maxTextureSize + ')');
    }
};


WebGlStage.prototype.createRenderer = function (Renderer) {
    var rendererInstances = this._rendererInstances;
    for (var i = 0; i < rendererInstances.length; i++) {
        if (rendererInstances[i] instanceof Renderer) {
            return rendererInstances[i];
        }
    }
    var renderer = new Renderer(this._gl);
    rendererInstances.push(renderer);
    return renderer;
};


WebGlStage.prototype.destroyRenderer = function (renderer) {
    var rendererInstances = this._rendererInstances;
    if (this._renderers.indexOf(renderer) < 0) {
        renderer.destroy();
        var index = rendererInstances.indexOf(renderer);
        if (index >= 0) {
            rendererInstances.splice(index, 1);
        }
    }
};


WebGlStage.prototype.startFrame = function () {

    var gl = this._gl;

    if (!gl) {
        throw new Error('Bad WebGL context - maybe context was lost?');
    }

    // Set the WebGL viewport.
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

    // Clear framebuffer.
    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Enable depth testing.
    gl.enable(gl.DEPTH_TEST);

    // Enable blending. ONE and ONE_MINUS_SRC_ALPHA are the right choices for
    // premultiplied textures.
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

};


WebGlStage.prototype.endFrame = function () { };


WebGlStage.prototype.takeSnapshot = function (options) {

    // Validate passed argument
    if (typeof options !== 'object' || options == null) {
        options = {};
    }

    var quality = options.quality;

    // Set default quality if it is not passed
    if (typeof quality == 'undefined') {
        quality = 75;
    }

    // Throw if quality is of invlid type or out of bounds
    if (typeof quality !== 'number' || quality < 0 || quality > 100) {
        throw new Error('WebGLStage: Snapshot quality needs to be a number between 0 and 100');
    }

    // Canvas method "toDataURL" needs to be called in the same
    // context as where the actual rendering is done. Hence this.
    this.render();

    // Return the snapshot
    return this._domElement.toDataURL('image/jpeg', quality / 100);
}


WebGlStage.type = WebGlStage.prototype.type = 'webgl';


function WebGlTexture(stage, tile, asset) {
    this._stage = stage;
    this._gl = stage._gl;
    this._texture = null;
    this._timestamp = null;
    this._width = this._height = null;
    this.refresh(tile, asset);
}


WebGlTexture.prototype.refresh = function (tile, asset) {

    var gl = this._gl;
    var stage = this._stage;
    var texture;

    // Check whether the texture needs to be updated.
    var timestamp = asset.timestamp();
    if (timestamp === this._timestamp) {
        return;
    }

    // Get asset element.
    var element = asset.element();

    // Get asset dimensions.
    var width = asset.width();
    var height = asset.height();

    if (width !== this._width || height !== this._height) {

        // If the texture dimensions have changed since the last refresh, create
        // a new texture with the correct size.

        // Check if texture dimensions would exceed the maximum texture size.
        var maxSize = stage.maxTextureSize();
        if (width > maxSize) {
            throw new Error('Texture width larger than max size (' + width + ' vs. ' + maxSize + ')');
        }
        if (height > maxSize) {
            throw new Error('Texture height larger than max size (' + height + ' vs. ' + maxSize + ')');
        }

        // Delete the current texture if it exists.
        // This is necessary for Chrome on Android. If it isn't done the textures
        // do not render when the size changes.
        if (this._texture) {
            gl.deleteTexture(texture);
        }

        // The texture must be premultiplied by alpha to ensure correct blending of
        // semitransparent textures. For details, see:
        // http://www.realtimerendering.com/blog/gpus-prefer-premultiplication/
        texture = this._texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, element);

    } else {

        // If the texture dimensions remain the same, repaint the existing texture.
        // Repainting with texSubImage2D is usually faster than with texImage2D,
        // except in the case noted in browserQuirks.

        texture = this._texture;
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

        if (element instanceof HTMLVideoElement && browserQuirks.videoUseTexImage2D) {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, element);
        } else {
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, element);
        }

    }

    // Generate mipmap if the corresponding stage option is set and the texture
    // dimensions are powers of two.
    if (stage._generateMipmaps && ispot(width) && ispot(height)) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.generateMipmap(gl.TEXTURE_2D);
    } else {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    }

    // Clamp texture to edges.
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    // Unbind texture.
    gl.bindTexture(gl.TEXTURE_2D, null);

    // Update texture dimensions and timestamp.
    this._timestamp = timestamp;
    this._width = width;
    this._height = height;

};


WebGlTexture.prototype.destroy = function () {
    if (this._texture) {
        this._gl.deleteTexture(this._texture);
    }
    clearOwnProperties(this);
};


WebGlStage.TextureClass = WebGlStage.prototype.TextureClass = WebGlTexture;


module.exports = WebGlStage;

},{"../loaders/HtmlImage":55,"../util/clearOwnProperties":76,"../util/dom":85,"../util/inherits":89,"../util/ispot":90,"../util/pixelRatio":95,"./Stage":69,"bowser":1}],71:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Transform a synchronous function into an asynchronous one.
function async(fn) {
  return function asynced(done) {
    var err, ret;
    try {
      ret = fn();
    } catch (e) {
      err = e;
    } finally {
      if (err) {
        done(err);
      } else {
        done(null, ret);
      }
    }
  };
}

module.exports = async;

},{}],72:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * Converts a {@link RectSpec} into an equivalent {@link Rect}.
 *
 * A {@link RectSpec} is a convenient user API format, providing default values
 * and the flexibility of specifying absolute, relative or mixed dimensions.
 *
 * A {@link Rect} is a more convenient format for the rendering pipeline. It is
 * always expressed in normalized coordinates, and all its properties are
 * guaranteed to be present.
 *
 * @param {number} totalWidth The total width of the rendering area in pixels.
 * @param {number} totalHeight The total height of the rendering area in pixels.
 * @param {RectSpec} spec The input spec, defaulting to the full rendering area
 *     if null or undefined.
 * @param {Rect} result The output spec. If the argument is present, it is
 *     filled in and returned; otherwise, a fresh object is returned.
 */
function calcRect(totalWidth, totalHeight, spec, result) {

  result = result || {};

  var width;
  if (spec != null && spec.absoluteWidth != null) {
    width = spec.absoluteWidth / totalWidth;
  } else if (spec != null && spec.relativeWidth != null) {
    width = spec.relativeWidth;
  } else {
    width = 1;
  }

  var height;
  if (spec && spec.absoluteHeight != null) {
    height = spec.absoluteHeight / totalHeight;
  } else if (spec != null && spec.relativeHeight != null) {
    height = spec.relativeHeight;
  } else {
    height = 1;
  }

  var x;
  if (spec != null && spec.absoluteX != null) {
    x = spec.absoluteX / totalWidth;
  } else if (spec != null && spec.relativeX != null) {
    x = spec.relativeX;
  } else {
    x = 0;
  }

  var y;
  if (spec != null && spec.absoluteY != null) {
    y = spec.absoluteY / totalHeight;
  } else if (spec != null && spec.relativeY != null) {
    y = spec.relativeY;
  } else {
    y = 0;
  }

  result.x = x;
  result.y = y;
  result.width = width;
  result.height = height;

  return result;
}

module.exports = calcRect;

},{}],73:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var once = require('./once');

// A cancelable function is an asynchronous function (i.e., one whose last
// argument is a callback receiving an error plus zero or more return values)
// that (synchronously) returns a cancel() function. Calling cancel() should
// abort the asynchronous operation and call the callback with the arguments
// that were passed into cancel(). Calling cancel() twice, as with callbacks,
// is not guaranteed to be safe.

// Wrap a non-cancellable asynchronous function into a cancelable one.
//
// Calling cancel() on the returned function will not interrupt the execution
// of the original function; it will merely ignore its return value.
//
// Usually, instead of wrapping your function, you want to implement cancel()
// yourself in order to have some abort logic. This utility function provides a
// straighforward solution for cases in which no custom abort logic is required.
function cancelize(fn) {
  return function cancelized() {
    if (!arguments.length) {
      throw new Error('cancelized: expected at least one argument');
    }
    var args = Array.prototype.slice.call(arguments, 0);
    var done = args[args.length - 1] = once(args[args.length - 1]);

    function cancel() {
      done.apply(null, arguments);
    }

    fn.apply(null, args);

    return cancel;
  };
}

module.exports = cancelize;

},{"./once":94}],74:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var noop = require('./noop');

// Return a function that executes its arguments (which should be cancelables)
// in sequence, so that each of them passes its return values to the next.
// Execution is aborted if one of the functions returns an error; in that case
// the last function in the sequence is called with the error.
// See util/cancelize.js for an explanation of what cancelables are.
function chain() {

  // The list of functions to chain together.
  var argList = Array.prototype.slice.call(arguments, 0);

  return function chained() {

    // List of remaining functions to be executed.
    // Make a copy of the original list so we can mutate the former while
    // preserving the latter intact for future invocations of the chain.
    var fnList = argList.slice(0);

    // Currently executing function.
    var fn = null;

    // Cancel method for the currently executing function.
    var cfn = null;

    // Arguments for the first function.
    var args = arguments.length ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : [];

    // Callback for the chain.
    var done = arguments.length ? arguments[arguments.length - 1] : noop;

    // Execute the next function in the chain.
    // Receives the error and return values from the previous function.
    function exec() {

      // Extract error from arguments.
      var err = arguments[0];

      // Abort chain on error.
      if (err) {
        fn = cfn = null;
        done.apply(null, arguments);
        return;
      }

      // Terminate if there are no functions left in the chain.
      if (!fnList.length) {
        fn = cfn = null;
        done.apply(null, arguments);
        return;
      }

      // Advance to the next function in the chain.
      fn = fnList.shift();
      var _fn = fn;

      // Extract arguments to pass into the next function.
      var ret = Array.prototype.slice.call(arguments, 1);

      // Call next function with previous return value and call back exec.
      ret.push(exec);
      var _cfn = fn.apply(null, ret); // fn(null, ret..., exec)

      // Detect when fn has completed synchronously and do not clobber the
      // internal state in that case. You're not expected to understand this.
      if (_fn !== fn) {
        return;
      }

      // Remember the cancel method for the currently executing function.
      // Detect chaining on non-cancellable function.
      if (typeof _cfn !== 'function') {
        throw new Error('chain: chaining on non-cancellable function');
      } else {
        cfn = _cfn;
      }

    }

    // Cancel chain execution.
    function cancel() {
      if (cfn) {
        cfn.apply(null, arguments);
      }
    }

    // Start chain execution.
    // We call exec as if linking from a previous function in the chain,
    // except that the error is always null. As a consequence, chaining on an
    // empty list yields the identity function.
    args.unshift(null);
    exec.apply(null, args); // exec(null, args...)

    return cancel;

  };

}

module.exports = chain;

},{"./noop":92}],75:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

module.exports = clamp;
},{}],76:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Sets an object's own properties to undefined. This may be called by
// destructors to avoid retaining references and help detect incorrect use of
// destroyed instances.
function clearOwnProperties(obj) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      obj[prop] = undefined;
    }
  }
}

module.exports = clearOwnProperties;

},{}],77:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function cmp(x, y) {
  if (x < y) {
    return -1;
  }
  if (x > y) {
    return 1;
  }
  return 0;
}

module.exports = cmp;
},{}],78:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
  * Compose multiple functions
  *
  * `compose(f, g)` returns `function(x) { return f(g(x)); }`
  *
  * @memberof util
  * @param {Function[]} functions The functions to compose
  * @return {Function}
  */
function compose() {
  var fnList = arguments;
  return function composed(initialArg) {
    var ret = initialArg;
    for (var i = 0; i < fnList.length; i++) {
      var fn = fnList[i];
      ret = fn.call(null, ret);
    }
    return ret;
  };
}

module.exports = compose;
},{}],79:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * Convert fov
 *
 * For example, to convert from hfov to vfov one would call 
 * `convert(hfov, width, height)`
 *
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function convert(fov, fromDimension, toDimension) {
  return 2 * Math.atan(toDimension * Math.tan(fov / 2) / fromDimension);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function htov(fov, width, height) {
  return convert(fov, width, height);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function htod(fov, width, height) {
  return convert(fov, width, Math.sqrt(width * width + height * height));
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function vtoh(fov, width, height) {
  return convert(fov, height, width);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function vtod(fov, width, height) {
  return convert(fov, height, Math.sqrt(width * width + height * height));
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function dtoh(fov, width, height) {
  return convert(fov, Math.sqrt(width * width + height * height), width);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function dtov(fov, width, height) {
  return convert(fov, Math.sqrt(width * width + height * height), height);
}

/**
 * @namespace util.convertFov
 */
module.exports = {
  convert: convert,
  htov: htov,
  htod: htod,
  vtoh: vtoh,
  vtod: vtod,
  dtoh: dtoh,
  dtov: dtov
};

},{}],80:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Convert a number to a string in decimal notation.
function decimal(x) {
  // Double-precision floats have 15 significant decimal digits.
  return x.toPrecision(15);
}

module.exports = decimal;
},{}],81:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function defaults(obj, defaultsObj) {
  for (var key in defaultsObj) {
    if (!(key in obj)) {
      obj[key] = defaultsObj[key];
    }
  }
  return obj;
}

module.exports = defaults;
},{}],82:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function defer(fn, args) {
  function deferred() {
    if (args && args.length > 0) {
      fn.apply(null, args);
    } else {
      fn();
    }
  }
  setTimeout(deferred, 0);
}

module.exports = defer;
},{}],83:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @memberof util
 * @param {number} deg
 * @return {number}
 */
function degToRad(deg) {
  return deg * Math.PI / 180;
}

module.exports = degToRad;
},{}],84:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Perform a cancelable delay.
// See util/cancelize.js for an explanation of what cancelables are.
function delay(ms, done) {

  // Work around IE8 bug whereby a setTimeout callback may still be called
  // after the corresponding clearTimeout is invoked.
  var timer = null;

  function finish() {
    if (timer != null) {
      timer = null;
      done(null);
    }
  }

  function cancel() {
    if (timer != null) {
      clearTimeout(timer);
      timer = null;
      done.apply(null, arguments);
    }
  }

  timer = setTimeout(finish, ms);

  return cancel;

}

module.exports = delay;

},{}],85:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';


function prefixProperty(property) {

  var style = document.documentElement.style;
  var prefixList = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];

  for (var i = 0; i < prefixList.length; i++) {
    var prefix = prefixList[i];
    var capitalizedProperty = property[0].toUpperCase() + property.slice(1);
    var prefixedProperty = prefix + capitalizedProperty;

    if (prefixedProperty in style) {
      return prefixedProperty;
    }
  }

  return property;

}


function getWithVendorPrefix(property) {
  var prefixedProperty = prefixProperty(property);
  return function getPropertyWithVendorPrefix(element) {
    return element.style[prefixedProperty];
  };

}


function setWithVendorPrefix(property) {
  var prefixedProperty = prefixProperty(property);
  return function setPropertyWithVendorPrefix(element, val) {
    return (element.style[prefixedProperty] = val);
  };
}


var setTransform = setWithVendorPrefix('transform');
var setTransformOrigin = setWithVendorPrefix('transformOrigin');


function setNullTransform(element) {
  setTransform(element, 'translateZ(0)');
}


function setNullTransformOrigin(element) {
  setTransformOrigin(element, '0 0 0');
}


function setAbsolute(element) {
  element.style.position = 'absolute';
}


function setPixelPosition(element, x, y) {
  element.style.left = x + 'px';
  element.style.top = y + 'px';
}


function setPixelSize(element, width, height) {
  element.style.width = width + 'px';
  element.style.height = height + 'px';
}


function setNullSize(element) {
  element.style.width = element.style.height = 0;
}


function setFullSize(element) {
  element.style.width = element.style.height = '100%';
}


function setOverflowHidden(element) {
  element.style.overflow = 'hidden';
}


function setOverflowVisible(element) {
  element.style.overflow = 'visible';
}


function setNoPointerEvents(element) {
  element.style.pointerEvents = 'none';
}


function setBlocking(element) {
  element.style.backgroundColor = '#000';
  element.style.opacity = '0';
  element.style.filter = 'alpha(opacity=0)';
}


module.exports = {
  prefixProperty: prefixProperty,
  getWithVendorPrefix: getWithVendorPrefix,
  setWithVendorPrefix: setWithVendorPrefix,
  setTransform: setTransform,
  setTransformOrigin: setTransformOrigin,
  setNullTransform: setNullTransform,
  setNullTransformOrigin: setNullTransformOrigin,
  setAbsolute: setAbsolute,
  setPixelPosition: setPixelPosition,
  setPixelSize: setPixelSize,
  setNullSize: setNullSize,
  setFullSize: setFullSize,
  setOverflowHidden: setOverflowHidden,
  setOverflowVisible: setOverflowVisible,
  setNoPointerEvents: setNoPointerEvents,
  setBlocking: setBlocking
};

},{}],86:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function extend(obj, sourceObj) {
  for (var key in sourceObj) {
    obj[key] = sourceObj[key];
  }
  return obj;
}

module.exports = extend;
},{}],87:[function(require,module,exports){
(function (global){(function (){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// The global object.
var globalObject = (function() {
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
  return null;
})();

module.exports = globalObject;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],88:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Jenkins one-at-a-time hash
// http://www.burtleburtle.net/bob/hash/doobs.html
// Input: an array of integers
// Output: an integer

function hash() {
  var h = 0;
  for (var i = 0; i < arguments.length; i++) {
    var k = arguments[i];
    h += k;
    h += k << 10;
    h ^= k >> 6;
  }
  h += h << 3;
  h ^= h >> 11;
  h += h << 15;
  return h >= 0 ? h : -h;
}

module.exports = hash;
},{}],89:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Make ctor a subclass of superCtor.
// Do not depend on ES5 Object.create semantics because of older browsers.
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  var TempCtor = function() {};
  TempCtor.prototype = superCtor.prototype;
  ctor.prototype = new TempCtor();
  ctor.prototype.constructor = ctor;
}

module.exports = inherits;
},{}],90:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Returns whether n is a power of two.
function ispot(n) {
  return (n & (n - 1)) == 0;
}

module.exports = ispot;
},{}],91:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * Modulo operation
 *
 * @memberof util
 * @param {Number} dividend
 * @param {Number} divisor
 * @returns {Number} Value in range `[0,divisor[`
 */
function mod(a, b) {
  return (+a % (b = +b) + b) % b;
}

module.exports = mod;
},{}],92:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function noop() {}

module.exports = noop;
},{}],93:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function getNow() {
  if (typeof performance !== 'undefined' && performance.now) {
    return function performanceNow() {
      return performance.now();
    };
  }
  return function dateNow() {
    return Date.now();
  };
}

module.exports = getNow();

},{}],94:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function once(fn) {
  var called = false;
  var value;
  return function onced() {
    if (!called) {
      called = true;
      value = fn.apply(null, arguments);
    }
    return value;
  };
}

module.exports = once;
},{}],95:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaultPixelRatio = 1;

function pixelRatio() {
  if (typeof window !== 'undefined') {
    if (window.devicePixelRatio) {
      return window.devicePixelRatio;
    }
    else {
      var screen = window.screen;
      if (screen && screen.deviceXDPI && screen.logicalXDPI) {
        return screen.deviceXDPI / screen.logicalXDPI;
      } else if (screen && screen.systemXDPI && screen.logicalXDPI) {
        return screen.systemXDPI / screen.logicalXDPI;
      }
    }
  }
  return defaultPixelRatio;
}

module.exports = pixelRatio;

},{}],96:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var setTransform = require('./dom').setTransform;
var decimal = require('./decimal');

function positionAbsolutely(element, x, y, extraTransforms) {
  extraTransforms = extraTransforms || '';
  // A translateZ(0) transform improves performance on Chrome by creating a
  // new layer for the element, which prevents unnecessary repaints.
  var transform = 'translateX(' + decimal(x) + 'px) translateY(' + decimal(y) + 'px) translateZ(0) ' + extraTransforms;
  setTransform(element, transform);
}

module.exports = positionAbsolutely;

},{"./decimal":80,"./dom":85}],97:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @memberof util
 * @param {number} rad
 * @return {number}
 */
function radToDeg(rad) {
  return rad * 180 / Math.PI;
}

module.exports = radToDeg;
},{}],98:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function real(x) {
  return typeof x === 'number' && isFinite(x);
}

module.exports = real;
},{}],99:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var noop = require('./noop');

// Return a cancelable function that executes fn in a loop until it returns
// successfully.
function retry(fn) {

  return function retried() {

    var args = arguments.length ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : [];
    var done = arguments.length ? arguments[arguments.length - 1] : noop;

    var cfn = null;
    var canceled = false;

    function exec() {
      var err = arguments[0];
      if (!err || canceled) {
        done.apply(null, arguments);
      } else {
        cfn = fn.apply(null, args);
      }
    }

    args.push(exec);
    exec(true);

    return function cancel() {
      canceled = true;
      cfn.apply(null, arguments);
    };

  };

}

module.exports = retry;

},{"./noop":92}],100:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var now = require('./now');

function tween(duration, update, done) {
  var cancelled = false;

  var startTime = now();

  function runUpdate() {
    if(cancelled) { return; }
    var tweenVal = (now() - startTime)/duration;
    if(tweenVal < 1) {
      update(tweenVal);
      requestAnimationFrame(runUpdate);
    }
    else {
      update(1);
      done();
    }
  }

  update(0);
  requestAnimationFrame(runUpdate);

  return function cancel() {
    cancelled = true;
    done.apply(null, arguments);
  }
}

module.exports = tween;
},{"./now":93}],101:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function type(x) {
  var typ = typeof x;
  if (typ === 'object') {
    if (x === null) {
      return 'null';
    }
    if (Object.prototype.toString.call(x) === '[object Array]') {
      return 'array';
    }
    if (Object.prototype.toString.call(x) === '[object RegExp]') {
      return 'regexp';
    }
  }
  return typ;
}

module.exports = type;

},{}],102:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var mat4 = require('gl-matrix').mat4;
var vec4 = require('gl-matrix').vec4;
var pixelRatio = require('../util/pixelRatio');
var real = require('../util/real');
var clamp = require('../util/clamp');
var clearOwnProperties = require('../util/clearOwnProperties');

// Default viewport dimensions.
// Start with zero to ensure that those values are handled correctly.
var defaultWidth = 0;
var defaultHeight = 0;

// Default view parameters.
var defaultX = 0.5;
var defaultY = 0.5;
var defaultZoom = 1;

// Constant values used to simplify the frustum culling logic.
// planeAxes[i] indicates the coordinate value that defines a frustum plane.
// planeCmp[i] indicates how point and plane coordinates should be compared
// to determine whether the point is on the outer side of the plane.
var planeAxes = [
  1, // top
  0, // right
  1, // bottom
  0  // left
];
var planeCmp = [
  -1, // top
  -1, // right
   1, // bottom
   1  // left
];

// A zoom of exactly 0 breaks some computations, so we force a minimum positive
// value. We use 6 decimal places for the epsilon value to avoid broken
// rendering due to loss of precision in floating point computations.
var zoomLimitEpsilon = 0.000001;


/**
 * @interface FlatViewParams
 *
 * A camera configuration for a {@link FlatView}.
 *
 * @property {number} x The horizontal coordinate of the image point displayed
 *     at the viewport center, in the [0, 1] range.
 *     When `x === 0.5`, the image is centered horizontally.
 *     When `x === 0`, the left edge of the image is at the viewport center.
 *     When `x === 1`, the right edge of the image is at the viewport center.
 * @property {number} y The vertical coordinate of the image point displayed at
 *     the viewport center, in the [0, 1] range.
 *     When `y === 0.5`, the image is centered vertically.
 *     When `y === 0`, the top edge of the image is at the viewport center.
 *     When `y === 1`, the bottom edge of the image is at the viewport center.
 * @property {number} zoom The horizontal zoom, in the [0, ∞) range.
 *     When `zoom === 1`, the viewport is as wide as the image.
 *     When `zoom < 1`, the image is zoomed in.
 *     When `zoom > 1`, the image is zoomed out.
 * @property {number} mediaAspectRatio The image aspect ratio.
 *     When `mediaAspectRatio === 1`, the image width equals its height.
 *     When `mediaAspectRatio < 1`, the image width is less than its height.
 *     When `mediaAspectRatio > 1`, the image height is less than its width.
 */


/**
 * @interface FlatViewCoords
 *
 * The position of a point in a flat image.
 *
 * @property {number} x The horizontal coordinate, in the [0, 1] range.
 * @property {number} y The vertical coordinate, in the [0, 1] range.
 */


/**
 * @typedef {function} FlatViewLimiter
 *
 * View limiter for a {@link FlatView}.
 *
 * A view limiter is a function that receives a {@link FlatViewParams} object,
 * optionally modifies it in place, and returns it. It can be used to enforce
 * constraints on the view parameters.
 *
 * See {@link FlatView.limit} for commonly used limiters. They may be composed
 * together or with user-defined limiters with {@link util.compose}.
 *
 * @param {FlatViewParams} params
 * @return {FlatViewParams}
 */


/**
 * @class FlatView
 * @implements View
 * @classdesc
 *
 * A {@link View} implementing an orthogonal projection for flat images.
 *
 * @param {FlatViewParams} params The initial view parameters. The
 *     `mediaAspectRatio` parameter must always be set. The other parameters
 *     default to `{x: 0.5, y: 0.5, z: 1 }` if unspecified.
 * @param {FlatViewLimiter=} limiter The view limiter. If unspecified, no view
 *     limiting is applied. See {@link FlatView.limit} for commonly used
 *     limiters.
 */
function FlatView(params, limiter) {
  // Require an aspect ratio to be specified.
  if (!(params && params.mediaAspectRatio != null)) {
    throw new Error('mediaAspectRatio must be defined');
  }

  // The initial values for the view parameters.
  this._x = params && params.x != null ? params.x : defaultX;
  this._y = params && params.y != null ? params.y : defaultY;
  this._zoom = params && params.zoom != null ? params.zoom : defaultZoom;
  this._mediaAspectRatio = params.mediaAspectRatio;
  this._width = params && params.width != null ?
    params.width : defaultWidth;
  this._height = params && params.height != null ?
    params.height : defaultHeight;

  // The initial value for the view limiter.
  this._limiter = limiter || null;

  // The last calculated projection matrix and its inverse.
  this._projMatrix = mat4.create();
  this._invProjMatrix = mat4.create();

  // The last calculated view frustum.
  this._frustum = [
    0, // top
    0, // right
    0, // bottom
    0  // left
  ];

  // Whether the projection matrices and view frustum need to be updated.
  this._projectionChanged = true;

  // Temporary variables used for calculations.
  this._params = {};
  this._vec = vec4.create();

  // Force view limiting on initial parameters.
  this._update();
}

eventEmitter(FlatView);


/**
 * Destructor.
 */
FlatView.prototype.destroy = function() {
  clearOwnProperties(this);
};


/**
 * Get the x parameter.
 * @return {number}
 */
FlatView.prototype.x = function() {
  return this._x;
};


/**
 * Get the y parameter.
 * @return {number}
 */
FlatView.prototype.y = function() {
  return this._y;
};


/**
 * Get the zoom value.
 * @return {number}
 */
FlatView.prototype.zoom = function() {
  return this._zoom;
};


/**
 * Get the media aspect ratio.
 * @return {number}
 */
FlatView.prototype.mediaAspectRatio = function() {
  return this._mediaAspectRatio;
};


/**
 * Get the viewport width.
 * @return {number}
 */
FlatView.prototype.width = function() {
  return this._width;
};


/**
 * Get the viewport height.
 * @return {number}
 */
FlatView.prototype.height = function() {
  return this._height;
};


/**
 * Get the viewport dimensions. If an argument is supplied, it is filled in with
 * the result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {Size=} size
 * @return {Size}
 */
FlatView.prototype.size = function(size) {
  size = size || {};
  size.width = this._width;
  size.height = this._height;
  return size;
};


/**
 * Get the view parameters. If an argument is supplied, it is filled in with the
 * result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {FlatViewParams=} params
 * @return {FlatViewParams}
 */
FlatView.prototype.parameters = function(params) {
  params = params || {};
  params.x = this._x;
  params.y = this._y;
  params.zoom = this._zoom;
  params.mediaAspectRatio = this._mediaAspectRatio;
  return params;
};


/**
 * Get the view limiter, or null if unset.
 * @return {?FlatViewLimiter}
 */
FlatView.prototype.limiter = function() {
  return this._limiter;
};


/**
 * Set the x parameter.
 * @param {number} x
 */
FlatView.prototype.setX = function(x) {
  this._resetParams();
  this._params.x = x;
  this._update(this._params);
};


/**
 * Set the y parameter.
 * @param {number} y
 */
FlatView.prototype.setY = function(y) {
  this._resetParams();
  this._params.y = y;
  this._update(this._params);
};


/**
 * Set the zoom value.
 * @param {number} zoom
 */
FlatView.prototype.setZoom = function(zoom) {
  this._resetParams();
  this._params.zoom = zoom;
  this._update(this._params);
};


/**
 * Add xOffset to the x parameter.
 * @param {number} xOffset
 */
FlatView.prototype.offsetX = function(xOffset) {
  this.setX(this._x + xOffset);
};


/**
 * Add yOffset to the y parameter.
 * @param {number} yOffset
 */
FlatView.prototype.offsetY = function(yOffset)
{
  this.setY(this._y + yOffset);
};


/**
 * Add zoomOffset to the zoom value.
 * @param {number} zoomOffset
 */
FlatView.prototype.offsetZoom = function(zoomOffset) {
  this.setZoom(this._zoom + zoomOffset);
};


/**
 * Set the media aspect ratio.
 * @param {number} mediaAspectRatio
 */
FlatView.prototype.setMediaAspectRatio = function(mediaAspectRatio) {
  this._resetParams();
  this._params.mediaAspectRatio = mediaAspectRatio;
  this._update(this._params);
};


/**
 * Set the viewport dimensions.
 * @param {Size} size
 */
FlatView.prototype.setSize = function(size) {
  this._resetParams();
  this._params.width = size.width;
  this._params.height = size.height;
  this._update(this._params);
};


/**
 * Set the view parameters. Unspecified parameters are left unchanged.
 * @param {FlatViewParameters} params
 */
FlatView.prototype.setParameters = function(params) {
  this._resetParams();
  this._params.x = params.x;
  this._params.y = params.y;
  this._params.zoom = params.zoom;
  this._params.mediaAspectRatio = params.mediaAspectRatio;
  this._update(this._params);
};


/**
 * Set the view limiter.
 * @param {?FlatViewLimiter} limiter The new limiter, or null to unset.
 */
FlatView.prototype.setLimiter = function(limiter) {
  this._limiter = limiter || null;
  this._update();
};


FlatView.prototype._resetParams = function() {
  var params = this._params;
  params.x = null;
  params.y = null;
  params.zoom = null;
  params.mediaAspectRatio = null;
  params.width = null;
  params.height = null;
};


FlatView.prototype._update = function(params) {

  // Avoid object allocation when no parameters are supplied.
  if (params == null) {
    this._resetParams();
    params = this._params;
  }

  // Save old parameters for later comparison.
  var oldX = this._x;
  var oldY = this._y;
  var oldZoom = this._zoom;
  var oldMediaAspectRatio = this._mediaAspectRatio;
  var oldWidth = this._width;
  var oldHeight = this._height;

  // Fill in object with the new set of parameters to pass into the limiter.
  params.x = params.x != null ? params.x : oldX;
  params.y = params.y != null ? params.y : oldY;
  params.zoom = params.zoom != null ? params.zoom : oldZoom;
  params.mediaAspectRatio = params.mediaAspectRatio != null ?
    params.mediaAspectRatio : oldMediaAspectRatio;
  params.width = params.width != null ? params.width : oldWidth;
  params.height = params.height != null ? params.height : oldHeight;

  // Apply view limiting when defined.
  if (this._limiter) {
    params = this._limiter(params);
    if (!params) {
      throw new Error('Bad view limiter');
    }
  }

  // Grab the limited parameters.
  var newX = params.x;
  var newY = params.y;
  var newZoom = params.zoom;
  var newMediaAspectRatio = params.mediaAspectRatio;
  var newWidth = params.width;
  var newHeight = params.height;

  // Consistency check.
  if (!real(newX) || !real(newY) || !real(newZoom) ||
      !real(newMediaAspectRatio) || !real(newWidth) || !real(newHeight)) {
    throw new Error('Bad view - suspect a broken limiter');
  }

  // Constrain zoom.
  newZoom = clamp(newZoom, zoomLimitEpsilon, Infinity);

  // Update parameters.
  this._x = newX;
  this._y = newY;
  this._zoom = newZoom;
  this._mediaAspectRatio = newMediaAspectRatio;
  this._width = newWidth;
  this._height = newHeight;

  // Check whether the parameters changed and emit the corresponding events.
  if (newX !== oldX || newY !== oldY || newZoom !== oldZoom ||
      newMediaAspectRatio !== oldMediaAspectRatio ||
      newWidth !== oldWidth || newHeight !== oldHeight) {
    this._projectionChanged = true;
    this.emit('change');
  }
  if (newWidth !== oldWidth || newHeight !== oldHeight) {
    this.emit('resize');
  }

};


FlatView.prototype._zoomX = function() {
  return this._zoom;
};


FlatView.prototype._zoomY = function() {
  var mediaAspectRatio = this._mediaAspectRatio;
  var aspect = this._width / this._height;
  var zoomX = this._zoom;
  var zoomY = zoomX * mediaAspectRatio / aspect;
  if (isNaN(zoomY)) {
    zoomY = zoomX;
  }
  return zoomY;
};


FlatView.prototype.updateWithControlParameters = function(parameters) {
  var scale = this.zoom();
  var zoomX = this._zoomX();
  var zoomY = this._zoomY();

  // TODO: should the scale be the same for both axes?
  this.offsetX(parameters.axisScaledX * zoomX + parameters.x * scale);
  this.offsetY(parameters.axisScaledY * zoomY + parameters.y * scale);
  this.offsetZoom(parameters.zoom * scale);
};


FlatView.prototype._updateProjection = function() {
  var projMatrix = this._projMatrix;
  var invProjMatrix = this._invProjMatrix;
  var frustum = this._frustum;

  // Recalculate projection matrix when required.
  if (this._projectionChanged) {
    var x = this._x;
    var y = this._y;
    var zoomX = this._zoomX();
    var zoomY = this._zoomY();

    // Recalculate view frustum.
    var top     = frustum[0] = (0.5 - y) + 0.5 * zoomY;
    var right   = frustum[1] = (x - 0.5) + 0.5 * zoomX;
    var bottom  = frustum[2] = (0.5 - y) - 0.5 * zoomY;
    var left    = frustum[3] = (x - 0.5) - 0.5 * zoomX;

    // Recalculate projection matrix and its inverse.
    mat4.ortho(projMatrix, left, right, bottom, top, -1, 1);
    mat4.invert(invProjMatrix, projMatrix);

    this._projectionChanged = false;
  }
};


/**
 * Returns the projection matrix for the current view.
 * @returns {mat4}
 */
FlatView.prototype.projection = function() {
  this._updateProjection();
  return this._projMatrix;
};


/**
 * Returns the inverse projection matrix for the current view.
 * @returns {mat4}
 */
FlatView.prototype.inverseProjection = function() {
  this._updateProjection();
  return this._invProjMatrix;
};


/**
 * Return whether the view frustum intersects the given rectangle.
 *
 * This function may return false positives, but never false negatives.
 * It is used for frustum culling, i.e., excluding invisible tiles from the
 * rendering process.
 *
 * @param {vec3[]} rectangle The vertices of the rectangle.
 */
FlatView.prototype.intersects = function(rectangle) {
  this._updateProjection();

  var frustum = this._frustum;

  // Check whether the rectangle is on the outer side of any of the frustum
  // planes. This is a sufficient condition, though not necessary, for the
  // rectangle to be completely outside the fruouter
  for (var i = 0; i < frustum.length; i++) {
    var limit = frustum[i];
    var axis = planeAxes[i];
    var cmp = planeCmp[i];
    var inside = false;
    for (var j = 0; j < rectangle.length; j++) {
      var vertex = rectangle[j];
      if (cmp < 0 && vertex[axis] < limit || cmp > 0 && vertex[axis] > limit) {
        inside = true;
        break;
      }
    }
    if (!inside) {
      return false;
    }
  }
  return true;
};


/**
 * Select the level that should be used to render the view.
 * @param {Level[]} levelList the list of levels from which to select.
 * @return {Level} the selected level.
 */
FlatView.prototype.selectLevel = function(levels) {

  // Multiply the viewport width by the device pixel ratio to get the required
  // horizontal resolution in pixels.
  //
  // Calculate the fraction of the image that would be visible at the current
  // zoom value. Then, for each level, multiply by the level width to get the
  // width in pixels of the portion that would be visible.
  //
  // Search for the smallest level that satifies the the required width,
  // falling back on the largest level if none do.

  var requiredPixels = pixelRatio() * this.width();
  var zoomFactor = this._zoom;

  for (var i = 0; i < levels.length; i++) {
    var level = levels[i];
    if (zoomFactor * level.width() >= requiredPixels) {
      return level;
    }
  }

  return levels[levels.length - 1];

};


/**
 * Convert view coordinates into screen coordinates. If a result argument is
 * provided, it is filled in and returned. Otherwise, a fresh object is filled
 * in and returned.
 *
 * @param {FlatViewCoords} coords The view coordinates.
 * @param {Coords=} result The result argument for the screen coordinates.
 * @return {Coords}
 */
FlatView.prototype.coordinatesToScreen = function(coords, result) {
  var ray = this._vec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Undefined on a null viewport.
  if (width <= 0 || height <= 0) {
    result.x = null;
    result.y = null;
    return null;
  }

  // Extract coordinates from argument, filling in default values.
  var x = coords && coords.x != null ? coords.x : defaultX;
  var y = coords && coords.y != null ? coords.y : defaultY;

  // Project view ray onto clip space.
  vec4.set(ray, x - 0.5, 0.5 - y, -1, 1);
  vec4.transformMat4(ray, ray, this.projection());

  // Calculate perspective divide.
  for (var i = 0; i < 3; i++) {
    ray[i] /= ray[3];
  }

  // Convert to viewport coordinates and return.
  result.x = width * (ray[0] + 1) / 2;
  result.y = height * (1 - ray[1]) / 2;

  return result;
};


/**
 * Convert screen coordinates into view coordinates. If a result argument is
 * provided, it is filled in with the result and returned. Otherwise, a fresh
 * object is filled in and returned.
 *
 * @param {Coords} coords The screen coordinates.
 * @param {FlatViewCoords=} result The result argument for the view coordinates.
 * @return {FlatViewCoords}
 */
FlatView.prototype.screenToCoordinates = function(coords, result) {
  var ray = this._vec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Convert viewport coordinates to clip space.
  var vecx = 2 * coords.x / width - 1;
  var vecy = 1 - 2 * coords.y / height;
  vec4.set(ray, vecx, vecy, 1, 1);

  // Project back to world space.
  vec4.transformMat4(ray, ray, this.inverseProjection());

  // Convert to flat coordinates.
  result.x = 0.5 + ray[0];
  result.y = 0.5 - ray[1];

  return result;
};


/**
 * Factory functions for view limiters. See {@link FlatViewLimiter}.
 * @namespace
 */
FlatView.limit = {

  /**
   * Returns a view limiter that constrains the x parameter.
   * @param {number} min The minimum x value.
   * @param {number} max The maximum y value.
   * @return {FlatViewLimiter}
   */
  x: function(min, max) {
    return function limitX(params) {
      params.x = clamp(params.x, min, max);
      return params;
    };
  },

  /**
   * Return a view limiter that constrains the y parameter.
   * @param {number} min The minimum y value.
   * @param {number} max The maximum y value.
   * @return {FlatViewLimiter}
   */
  y: function(min, max) {
    return function limitY(params) {
      params.y = clamp(params.y, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter than constrains the zoom parameter.
   * @param {number} min The minimum zoom value.
   * @param {number} max The maximum zoom value.
   * @return {FlatViewLimiter}
   */
  zoom: function(min, max) {
    return function limitZoom(params) {
      params.zoom = clamp(params.zoom, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that prevents zooming in beyond the given
   * resolution.
   * @param {number} size The image width in pixels.
   * @return {FlatViewLimiter}
   */
  resolution: function(size) {
    return function limitResolution(params) {
      if (params.width <= 0 || params.height <= 0) {
        return params;
      }
      var width = params.width;
      var minZoom = pixelRatio() * width / size;
      params.zoom = clamp(params.zoom, minZoom, Infinity);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the values of the x parameter that
   * are inside the viewport.
   * @param {number} min The minimum x value.
   * @param {number} max The maximum x value.
   * @return {FlatViewLimiter}
   */
  visibleX: function(min, max) {
    return function limitVisibleX(params) {
      // Calculate the zoom value that makes the specified range fully visible.
      var maxZoom = max - min;

      // Clamp zoom to the maximum value.
      if (params.zoom > maxZoom) {
        params.zoom = maxZoom;
      }

      // Bound X such that the image is visible up to the range edges.
      var minX = min + 0.5 * params.zoom;
      var maxX = max - 0.5 * params.zoom;
      params.x = clamp(params.x, minX, maxX);

      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the values of the y parameter that
   * are inside the viewport.
   * @param {number} min The minimum y value.
   * @param {number} max The maximum y value.
   * @return {FlatViewLimiter}
   */
  visibleY: function(min, max) {
    return function limitVisibleY(params) {

      // Do nothing for a null viewport.
      if (params.width <= 0 || params.height <= 0) {
        return params;
      }

      // Calculate the X to Y conversion factor.
      var viewportAspectRatio = params.width / params.height;
      var factor = viewportAspectRatio / params.mediaAspectRatio;

      // Calculate the zoom value that makes the specified range fully visible.
      var maxZoom = (max - min) * factor;

      // Clamp zoom to the maximum value.
      if (params.zoom > maxZoom) {
        params.zoom = maxZoom;
      }

      // Bound Y such that the image is visible up to the range edges.
      var minY = min + 0.5 * params.zoom / factor;
      var maxY = max - 0.5 * params.zoom / factor;
      params.y = clamp(params.y, minY, maxY);

      return params;
    };
  },


  /**
   * Returns a view limiter that constrains the zoom parameter such that
   * zooming out is prevented beyond the point at which the image is fully
   * visible. Unless the image and the viewport have the same aspect ratio,
   * this will cause bands to appear around the image.
   * @return {FlatViewLimiter}
   */
  letterbox: function() {
    return function limitLetterbox(params) {
      if(params.width <= 0 || params.height <= 0) {
        return params;
      }
      var viewportAspectRatio = params.width / params.height;

      var fullWidthZoom = 1.0;
      var fullHeightZoom = viewportAspectRatio / params.mediaAspectRatio;

      // If the image is wider than the viewport, limit the horizontal zoom to
      // the image width.
      if (params.mediaAspectRatio >= viewportAspectRatio) {
        params.zoom = Math.min(params.zoom, fullWidthZoom);
      }

      // If the image is narrower than the viewport, limit the vertical zoom to
      // the image height.
      if (params.mediaAspectRatio <= viewportAspectRatio) {
        params.zoom = Math.min(params.zoom, fullHeightZoom);
      }

      // If the full image width is visible, limit x to the central point.
      // Else, bound x such that image is visible up to the horizontal edges.
      var minX, maxX;
      if (params.zoom > fullWidthZoom) {
        minX = maxX = 0.5;
      } else {
        minX = 0.0 + 0.5 * params.zoom / fullWidthZoom;
        maxX = 1.0 - 0.5 * params.zoom / fullWidthZoom;
      }

      // If the full image height is visible, limit y to the central point.
      // Else, bound y such that image is visible up to the vertical edges.
      var minY, maxY;
      if (params.zoom > fullHeightZoom) {
        minY = maxY = 0.5;
      } else {
        minY = 0.0 + 0.5 * params.zoom / fullHeightZoom;
        maxY = 1.0 - 0.5 * params.zoom / fullHeightZoom;
      }

      // Clamp x and y into the calculated bounds.
      params.x = clamp(params.x, minX, maxX);
      params.y = clamp(params.y, minY, maxY);

      return params;
    };
  }

};


FlatView.type = FlatView.prototype.type = 'flat';


module.exports = FlatView;

},{"../util/clamp":75,"../util/clearOwnProperties":76,"../util/pixelRatio":95,"../util/real":98,"gl-matrix":3,"minimal-event-emitter":14}],103:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var mat4 = require('gl-matrix').mat4;
var vec4 = require('gl-matrix').vec4;
var pixelRatio = require('../util/pixelRatio');
var convertFov = require('../util/convertFov');
var mod = require('../util/mod');
var real = require('../util/real');
var clamp = require('../util/clamp');
var decimal = require('../util/decimal');
var compose = require('../util/compose');
var clearOwnProperties = require('../util/clearOwnProperties');

// Default viewport dimensions.
// Start with zero to ensure that those values are handled correctly.
var defaultWidth = 0;
var defaultHeight = 0;

// Default view parameters.
var defaultYaw = 0;
var defaultPitch = 0;
var defaultRoll = 0;
var defaultFov = Math.PI/4;
var defaultProjectionCenterX = 0;
var defaultProjectionCenterY = 0;

// A fov of exactly 0 or π breaks some computations, so we constrain it to the
// [fovLimitEpsilon, π - fovLimitEpsilon] interval. We use 6 decimal places for
// the epsilon value to avoid broken rendering due to loss of precision in
// floating point computations.
var fovLimitEpsilon = 0.000001;


/**
 * @interface RectilinearViewParams
 *
 * A camera configuration for a {@link RectilinearView}.
 *
 * @property {number} yaw The yaw angle, in the [-π, π] range.
 *     When `yaw < 0`, the view rotates to the left.
 *     When `yaw > 0`, the view rotates to the right.
 *
 * @property {number} pitch The pitch angle, in the [-π, π] range.
 *     When `pitch < 0`, the view rotates downwards.
 *     When `pitch > 0`, the view rotates upwards.
 *
 * @property {number} roll The roll angle, in the [-π, π] range.
 *     When `roll < 0`, the view rotates clockwise.
 *     When `roll > 0`, the view rotates counter-clockwise.
 *
 * @property {fov} fov The vertical field of view, in the [0, π] range.
 */


/**
 * @interface RectilinearViewCoords
 *
 * The position of a point in a 360° image.
 *
 * @property {number} yaw The yaw angle, in the [-π, π] range.
 * @property {number} pitch The pitch angle, in the [-π, π] range.
 */


/**
 * @typedef {function} RectilinearViewLimiter
 *
 * View limiter for a {@link RectilinearView}.
 *
 * A view limiter is a function that receives a {@link RectilinearViewParams}
 * object, optionally modifies it in place, and returns it. It can be used to
 * enforce constraints on the view parameters.
 *
 * See {@link RectilinearView.limit} for commonly used limiters. They may be
 * composed together or with user-defined limiters with {@link util.compose}.
 *
 * @param {RectilinearViewParams} params
 * @return {RectilinearViewParams}
 */

/**
 * @class RectilinearView
 * @implements View
 * @classdesc
 *
 * A {@link View} implementing a rectilinear projection for 360° images.
 *
 * @param {RectilinearViewParams=} params The initial view parameters. If
 *     unspecified, defaults to `{yaw: 0, pitch: 0, roll: 0, fov: Math.PI/4 }`.
 * @param {RectilinearViewLimiter=} limiter The view limiter. If unspecified,
 *     no view limiting is applied. See {@link RectilinearView.limit} for
 *     commonly used limiters.
 */
function RectilinearView(params, limiter) {
  // The initial values for the view parameters.
  this._yaw = params && params.yaw != null ? params.yaw : defaultYaw;
  this._pitch = params && params.pitch != null ? params.pitch : defaultPitch;
  this._roll = params && params.roll != null ? params.roll : defaultRoll;
  this._fov = params && params.fov != null ? params.fov : defaultFov;
  this._width = params && params.width != null ?
    params.width : defaultWidth;
  this._height = params && params.height != null ?
    params.height : defaultHeight;
  this._projectionCenterX = params && params.projectionCenterX != null ?
    params.projectionCenterX : defaultProjectionCenterX;
  this._projectionCenterY = params && params.projectionCenterY != null ?
    params.projectionCenterY : defaultProjectionCenterY;

  // The initial value for the view limiter.
  this._limiter = limiter || null;

  // The last calculated projection matrix and its inverse.
  this._projMatrix = mat4.create();
  this._invProjMatrix = mat4.create();

  // The last calculated view frustum.
  this._frustum = [
    vec4.create(), // left
    vec4.create(), // right
    vec4.create(), // bottom
    vec4.create(), // top
    vec4.create()  // camera
  ];

  // Whether the projection matrices and the view frustum need to be updated.
  this._projectionChanged = true;

  // Temporary variables used for calculations.
  this._params = {};
  this._fovs = {};
  this._tmpVec = vec4.create();

  // Force view limiting on initial parameters.
  this._update();
}

eventEmitter(RectilinearView);


/**
 * Destructor.
 */
RectilinearView.prototype.destroy = function() {
  clearOwnProperties(this);
};


/**
 * Get the yaw angle.
 * @return {number}
 */
RectilinearView.prototype.yaw = function() {
  return this._yaw;
};


/**
 * Get the pitch angle.
 * @return {number}
 */
RectilinearView.prototype.pitch = function() {
  return this._pitch;
};


/**
 * Get the roll angle.
 * @return {number}
 */
RectilinearView.prototype.roll = function() {
  return this._roll;
};


RectilinearView.prototype.projectionCenterX = function() {
  return this._projectionCenterX;
};


RectilinearView.prototype.projectionCenterY = function() {
  return this._projectionCenterY;
};


/**
 * Get the fov value.
 * @return {number}
 */
RectilinearView.prototype.fov = function() {
  return this._fov;
};


/**
 * Get the viewport width.
 * @return {number}
 */
RectilinearView.prototype.width = function() {
  return this._width;
};


/**
 * Get the viewport height.
 * @return {number}
 */
RectilinearView.prototype.height = function() {
  return this._height;
};


/**
 * Get the viewport dimensions. If an argument is supplied, it is filled in with
 * the result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {Size=} size
 * @return {Size}
 */
RectilinearView.prototype.size = function(size) {
  size = size || {};
  size.width = this._width;
  size.height = this._height;
  return size;
};


/**
 * Get the view parameters. If an argument is supplied, it is filled in with the
 * result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {RectilinearViewParams=} obj
 * @return {RectilinearViewParams}
 */
RectilinearView.prototype.parameters = function(params) {
  params = params || {};
  params.yaw = this._yaw;
  params.pitch = this._pitch;
  params.roll = this._roll;
  params.fov = this._fov;
  return params;
};


/**
 * Get the view limiter, or null if unset.
 * @return {?RectilinearViewLimiter}
 */
RectilinearView.prototype.limiter = function() {
  return this._limiter;
};


/**
 * Set the yaw angle.
 * @param {number} yaw
 */
RectilinearView.prototype.setYaw = function(yaw) {
  this._resetParams();
  this._params.yaw = yaw;
  this._update(this._params);
};


/**
 * Set the pitch angle.
 * @param {number} pitch
 */
RectilinearView.prototype.setPitch = function(pitch) {
  this._resetParams();
  this._params.pitch = pitch;
  this._update(this._params);
};


/**
 * Set the roll angle.
 * @param {number} roll
 */
RectilinearView.prototype.setRoll = function(roll) {
  this._resetParams();
  this._params.roll = roll;
  this._update(this._params);
};


/**
 * Set the fov value.
 * @param {number} fov
 */
RectilinearView.prototype.setFov = function(fov) {
  this._resetParams();
  this._params.fov = fov;
  this._update(this._params);
};


RectilinearView.prototype.setProjectionCenterX = function(projectionCenterX) {
  this._resetParams();
  this._params.projectionCenterX = projectionCenterX;
  this._update(this._params);
};


RectilinearView.prototype.setProjectionCenterY = function(projectionCenterY) {
  this._resetParams();
  this._params.projectionCenterY = projectionCenterY;
  this._update(this._params);
};


/**
 * Add yawOffset to the current yaw value.
 * @param {number} yawOffset
 */
RectilinearView.prototype.offsetYaw = function(yawOffset) {
  this.setYaw(this._yaw + yawOffset);
};


/**
 * Add pitchOffset to the current pitch value.
 * @param {number} pitchOffset
 */
RectilinearView.prototype.offsetPitch = function(pitchOffset) {
  this.setPitch(this._pitch + pitchOffset);
};


/**
 * Add rollOffset to the current roll value.
 * @param {number} rollOffset
 */
RectilinearView.prototype.offsetRoll = function(rollOffset) {
  this.setRoll(this._roll + rollOffset);
};


/**
 * Add fovOffset to the current fov value.
 * @param {number} fovOffset
 */
RectilinearView.prototype.offsetFov = function(fovOffset) {
  this.setFov(this._fov + fovOffset);
};


/**
 * Set the viewport dimensions.
 * @param {Size} size
 */
RectilinearView.prototype.setSize = function(size) {
  this._resetParams();
  this._params.width = size.width;
  this._params.height = size.height;
  this._update(this._params);
};


/**
 * Set the view parameters. Unspecified parameters are left unchanged.
 * @param {RectilinearViewParameters} params
 */
RectilinearView.prototype.setParameters = function(params) {
  this._resetParams();
  this._params.yaw = params.yaw;
  this._params.pitch = params.pitch;
  this._params.roll = params.roll;
  this._params.fov = params.fov;
  this._params.projectionCenterX = params.projectionCenterX;
  this._params.projectionCenterY = params.projectionCenterY;
  this._update(this._params);
};


/**
 * Set the view limiter.
 * @param {?RectilinearViewLimiter} limiter The new limiter, or null to unset.
 */
RectilinearView.prototype.setLimiter = function(limiter) {
  this._limiter = limiter || null;
  this._update();
};


RectilinearView.prototype._resetParams = function() {
  var params = this._params;
  params.yaw = null;
  params.pitch = null;
  params.roll = null;
  params.fov = null;
  params.width = null;
  params.height = null;
};


RectilinearView.prototype._update = function(params) {

  // Avoid object allocation when no parameters are supplied.
  if (params == null) {
    this._resetParams();
    params = this._params;
  }

  // Save old parameters for later comparison.
  var oldYaw = this._yaw;
  var oldPitch = this._pitch;
  var oldRoll = this._roll;
  var oldFov = this._fov;
  var oldProjectionCenterX = this._projectionCenterX;
  var oldProjectionCenterY = this._projectionCenterY;
  var oldWidth = this._width;
  var oldHeight = this._height;

  // Fill in object with the new set of parameters to pass into the limiter.
  params.yaw = params.yaw != null ? params.yaw : oldYaw;
  params.pitch = params.pitch != null ? params.pitch : oldPitch;
  params.roll = params.roll != null ? params.roll : oldRoll;
  params.fov = params.fov != null ? params.fov : oldFov;
  params.width = params.width != null ? params.width : oldWidth;
  params.height = params.height != null ? params.height : oldHeight;
  params.projectionCenterX = params.projectionCenterX != null ?
    params.projectionCenterX : oldProjectionCenterX;
  params.projectionCenterY = params.projectionCenterY != null ?
    params.projectionCenterY : oldProjectionCenterY;

  // Apply view limiting when defined.
  if (this._limiter) {
    params = this._limiter(params);
    if (!params) {
      throw new Error('Bad view limiter');
    }
  }

  // Normalize parameters.
  params = this._normalize(params);

  // Grab the limited parameters.
  var newYaw = params.yaw;
  var newPitch = params.pitch;
  var newRoll = params.roll;
  var newFov = params.fov;
  var newWidth = params.width;
  var newHeight = params.height;
  var newProjectionCenterX = params.projectionCenterX;
  var newProjectionCenterY = params.projectionCenterY;

  // Consistency check.
  if (!real(newYaw) || !real(newPitch) || !real(newRoll) ||
      !real(newFov) || !real(newWidth) || !real(newHeight) ||
      !real(newProjectionCenterX) || !real(newProjectionCenterY)) {
    throw new Error('Bad view - suspect a broken limiter');
  }

  // Update parameters.
  this._yaw = newYaw;
  this._pitch = newPitch;
  this._roll = newRoll;
  this._fov = newFov;
  this._width = newWidth;
  this._height = newHeight;
  this._projectionCenterX = newProjectionCenterX;
  this._projectionCenterY = newProjectionCenterY;

  // Check whether the parameters changed and emit the corresponding events.
  if (newYaw !== oldYaw || newPitch !== oldPitch || newRoll !== oldRoll ||
      newFov !== oldFov || newWidth !== oldWidth || newHeight !== oldHeight ||
      newProjectionCenterX !== oldProjectionCenterX ||
      newProjectionCenterY !== oldProjectionCenterY) {
    this._projectionChanged = true;
    this.emit('change');
  }
  if (newWidth !== oldWidth || newHeight !== oldHeight) {
    this.emit('resize');
  }

};


RectilinearView.prototype._normalize = function(params) {

  this._normalizeCoordinates(params);

  // Make sure that neither the horizontal nor the vertical fields of view
  // exceed π - fovLimitEpsilon.
  var hfovPi = convertFov.htov(Math.PI, params.width, params.height);
  var maxFov = isNaN(hfovPi) ? Math.PI : Math.min(Math.PI, hfovPi);
  params.fov = clamp(params.fov, fovLimitEpsilon, maxFov - fovLimitEpsilon);

  return params;
};


RectilinearView.prototype._normalizeCoordinates = function(params) {
  // Constrain yaw, pitch and roll to the [-π, π] interval.
  if ('yaw' in params) {
    params.yaw = mod(params.yaw - Math.PI, -2*Math.PI) + Math.PI;
  }
  if ('pitch' in params) {
    params.pitch = mod(params.pitch - Math.PI, -2*Math.PI) + Math.PI;
  }
  if ('roll' in params) {
    params.roll = mod(params.roll - Math.PI, -2*Math.PI) + Math.PI;
  }
  return params;
};


/**
 * Normalize view coordinates so that they are the closest to the current view.
 * Useful for tweening the view through the shortest path. If a result argument
 * is supplied, it is filled in with the result and returned. Otherwise, a fresh
 * object is filled in and returned.
 *
 * @param {RectilinearViewCoords} coords The view coordinates.
 * @param {RectilinearViewCoords} result The result argument for the normalized
 *     view coordinates.
 */
RectilinearView.prototype.normalizeToClosest = function(coords, result) {

  var viewYaw = this._yaw;
  var viewPitch = this._pitch;

  var coordYaw = coords.yaw;
  var coordPitch = coords.pitch;

  // Check if the yaw is closer after subtracting or adding a full circle.
  var prevYaw = coordYaw - 2*Math.PI;
  var nextYaw = coordYaw + 2*Math.PI;
  if (Math.abs(prevYaw - viewYaw) < Math.abs(coordYaw - viewYaw)) {
    coordYaw = prevYaw;
  }
  else if (Math.abs(nextYaw - viewYaw) < Math.abs(coordYaw - viewYaw)) {
    coordYaw = nextYaw;
  }

  // Check if the pitch is closer after subtracting or adding a full circle.
  var prevPitch = coordPitch - 2*Math.PI;
  var nextPitch = coordPitch + 2*Math.PI;
  if (Math.abs(prevPitch - viewPitch) < Math.abs(coordPitch - viewPitch)) {
    coordPitch = prevPitch;
  }
  else if (Math.abs(prevPitch - viewPitch) < Math.abs(coordPitch - viewPitch)) {
    coordPitch = nextPitch;
  }

  result = result || {};
  result.yaw = coordYaw;
  result.pitch = coordPitch;
  return result;

};


RectilinearView.prototype.updateWithControlParameters = function(parameters) {
  // axisScaledX and axisScaledY are scaled according to their own axis
  // x and y are scaled by the same value

  // If the viewport dimensions are zero, assume a square viewport
  // when converting from hfov to vfov.
  var vfov = this._fov;
  var hfov = convertFov.vtoh(vfov, this._width, this._height);
  if (isNaN(hfov)) {
    hfov = vfov;
  }

  // TODO: revisit this after we rethink the control parameters.
  this.offsetYaw(parameters.axisScaledX * hfov + parameters.x * 2 * hfov + parameters.yaw);
  this.offsetPitch(parameters.axisScaledY * vfov + parameters.y * 2 * hfov + parameters.pitch);
  this.offsetRoll(-parameters.roll);
  this.offsetFov(parameters.zoom * vfov);
};


RectilinearView.prototype._updateProjection = function() {
  var projMatrix = this._projMatrix;
  var invProjMatrix = this._invProjMatrix;
  var frustum = this._frustum;

  if (this._projectionChanged) {
    var width = this._width;
    var height = this._height;

    var vfov = this._fov;
    var hfov = convertFov.vtoh(vfov, width, height);
    var aspect = width / height;

    var projectionCenterX = this._projectionCenterX;
    var projectionCenterY = this._projectionCenterY;

    if (projectionCenterX !== 0 || projectionCenterY !== 0) {
      var offsetAngleX = Math.atan(projectionCenterX * 2 * Math.tan(hfov/2));
      var offsetAngleY = Math.atan(projectionCenterY * 2 * Math.tan(vfov/2));
      var fovs = this._fovs;
      fovs.leftDegrees = (hfov/2 + offsetAngleX) * 180/Math.PI;
      fovs.rightDegrees = (hfov/2 - offsetAngleX) * 180/Math.PI;
      fovs.upDegrees = (vfov/2 + offsetAngleY) * 180/Math.PI;
      fovs.downDegrees = (vfov/2 - offsetAngleY) * 180/Math.PI;
      mat4.perspectiveFromFieldOfView(projMatrix, fovs, -1, 1);
    } else {
      mat4.perspective(projMatrix, vfov, aspect, -1, 1);
    }

    mat4.rotateZ(projMatrix, projMatrix, this._roll);
    mat4.rotateX(projMatrix, projMatrix, this._pitch);
    mat4.rotateY(projMatrix, projMatrix, this._yaw);

    mat4.invert(invProjMatrix, projMatrix);

    this._matrixToFrustum(projMatrix, frustum);

    this._projectionChanged = false;
  }
};


RectilinearView.prototype._matrixToFrustum = function(p, f) {
  // Extract frustum planes from projection matrix.
  // http://www8.cs.umu.se/kurser/5DV051/HT12/lab/plane_extraction.pdf
  vec4.set(f[0], p[3] + p[0], p[7] + p[4], p[11] + p[8],  0); // left
  vec4.set(f[1], p[3] - p[0], p[7] - p[4], p[11] - p[8],  0); // right
  vec4.set(f[2], p[3] + p[1], p[7] + p[5], p[11] + p[9],  0); // top
  vec4.set(f[3], p[3] - p[1], p[7] - p[5], p[11] - p[9],  0); // bottom
  vec4.set(f[4], p[3] + p[2], p[7] + p[6], p[11] + p[10], 0); // camera
};


/**
 * Returns the projection matrix for the current view.
 * @returns {mat4}
 */
RectilinearView.prototype.projection = function() {
  this._updateProjection();
  return this._projMatrix;
};


/**
 * Returns the inverse projection matrix for the current view.
 * @returns {mat4}
 */
RectilinearView.prototype.inverseProjection = function() {
  this._updateProjection();
  return this._invProjMatrix;
};


/**
 * Return whether the view frustum intersects the given rectangle.
 *
 * This function may return false positives, but never false negatives.
 * It is used for frustum culling, i.e., excluding invisible tiles from the
 * rendering process.
 *
 * @param {vec2[]} rectangle The vertices of the rectangle.
 */
RectilinearView.prototype.intersects = function(rectangle) {
  this._updateProjection();

  var frustum = this._frustum;
  var vertex = this._tmpVec;

  // Check whether the rectangle is on the outer side of any of the frustum
  // planes. This is a sufficient condition, though not necessary, for the
  // rectangle to be completely outside the frustum.
  for (var i = 0; i < frustum.length; i++) {
    var plane = frustum[i];
    var inside = false;
    for (var j = 0; j < rectangle.length; j++) {
      var corner = rectangle[j];
      vec4.set(vertex, corner[0], corner[1], corner[2], 0);
      if (vec4.dot(plane, vertex) >= 0) {
        inside = true;
      }
    }
    if (!inside) {
      return false;
    }
  }
  return true;
};


/**
 * Select the level that should be used to render the view.
 * @param {Level[]} levelList the list of levels from which to select.
 * @return {Level} the selected level.
 */
RectilinearView.prototype.selectLevel = function(levelList) {

  // Multiply the viewport width by the device pixel ratio to get the required
  // horizontal resolution in pixels.
  //
  // Calculate the fraction of a cube face that would be visible given the
  // current vertical field of view. Then, for each level, multiply by the
  // level height to get the height in pixels of the portion that would be
  // visible.
  //
  // Search for the smallest level that satifies the the required height,
  // falling back on the largest level if none do.

  var requiredPixels = pixelRatio() * this._height;
  var coverFactor = Math.tan(0.5 * this._fov);

  for (var i = 0; i < levelList.length; i++) {
    var level = levelList[i];
    if (coverFactor * level.height() >= requiredPixels) {
      return level;
    }
  }

  return levelList[levelList.length - 1];

};


/**
 * Convert view parameters into screen position. If a result argument is
 * provided, it is filled in and returned. Otherwise, a fresh object is filled
 * in and returned.
 *
 * @param {RectilinearViewCoords} coords The view coordinates.
 * @param {Coords=} result The result argument for the screen coordinates.
 * @return {Coords}
 */
RectilinearView.prototype.coordinatesToScreen = function(coords, result) {
  var ray = this._tmpVec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Undefined on a null viewport.
  if (width <= 0 || height <= 0) {
    result.x = null;
    result.y = null;
    return null;
  }

  // Compute view ray pointing into the (yaw, pitch) direction.
  var yaw = coords.yaw;
  var pitch = coords.pitch;
  var x = Math.sin(yaw) * Math.cos(pitch);
  var y = -Math.sin(pitch);
  var z = -Math.cos(yaw) * Math.cos(pitch);
  vec4.set(ray, x, y, z, 1);

  // Project view ray onto clip space.
  vec4.transformMat4(ray, ray, this.projection());

  // w in clip space equals -z in camera space.
  if (ray[3] >= 0) {
    // Point is in front of camera.
    // Convert to viewport coordinates.
    result.x = width * (ray[0] / ray[3] + 1) / 2;
    result.y = height * (1 - ray[1] / ray[3]) / 2;
  } else {
    // Point is behind camera.
    result.x = null;
    result.y = null;
    return null;
  }

  return result;
};


/**
 * Convert screen coordinates into view coordinates. If a result argument is
 * provided, it is filled in with the result and returned. Otherwise, a fresh
 * object is filled in and returned.
 *
 * @param {Coords} coords The screen coordinates.
 * @param {RectilinearViewCoords=} result The view coordinates.
 * @return {RectilinearViewCoords}
 */
RectilinearView.prototype.screenToCoordinates = function(coords, result) {
  var ray = this._tmpVec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Convert viewport coordinates to clip space.
  var vecx = 2 * coords.x / width - 1;
  var vecy = 1 - 2 * coords.y / height;
  vec4.set(ray, vecx, vecy, 1, 1);

  // Project back to world space.
  vec4.transformMat4(ray, ray, this.inverseProjection());

  // Convert to spherical coordinates.
  var r = Math.sqrt(ray[0] * ray[0] + ray[1] * ray[1] + ray[2] * ray[2]);
  result.yaw = Math.atan2(ray[0], -ray[2]);
  result.pitch = Math.acos(ray[1] / r) - Math.PI/2;

  this._normalizeCoordinates(result);

  return result;
};


/**
 * Calculate the perspective transform required to position an element with
 * perspective.
 *
 * @param {RectilinearViewCoords} coords The view coordinates.
 * @param {number} radius Radius of the sphere embedding the element.
 * @param {string} extraTransforms Extra transformations to be applied after
 *     the element is positioned. This may be used to rotate the element.
 * @return {string} The CSS 3D transform to be applied to the element.
 */
RectilinearView.prototype.coordinatesToPerspectiveTransform = function(
    coords, radius, extraTransforms) {
  extraTransforms = extraTransforms || "";

  var height = this._height;
  var width = this._width;
  var fov = this._fov;
  var perspective = 0.5 * height / Math.tan(fov / 2);

  var transform = '';

  // Center hotspot in screen.
  transform += 'translateX(' + decimal(width/2) + 'px) ';
  transform += 'translateY(' + decimal(height/2) + 'px) ';
  transform += 'translateX(-50%) translateY(-50%) ';

  // Set the perspective depth.
  transform += 'perspective(' + decimal(perspective) + 'px) ';
  transform += 'translateZ(' + decimal(perspective) + 'px) ';

  // Set the camera rotation.
  transform += 'rotateZ(' + decimal(-this._roll) + 'rad) ';
  transform += 'rotateX(' + decimal(-this._pitch) + 'rad) ';
  transform += 'rotateY(' + decimal(this._yaw) + 'rad) ';

  // Set the hotspot rotation.
  transform += 'rotateY(' + decimal(-coords.yaw) + 'rad) ';
  transform += 'rotateX(' + decimal(coords.pitch) + 'rad) ';

  // Move back to sphere.
  transform += 'translateZ(' + decimal(-radius) + 'px) ';

  // Apply the extra transformations
  transform += extraTransforms + ' ';

  return transform;
};


/**
 * Factory functions for view limiters. See {@link RectilinearViewLimiter}.
 * @namespace
 */
RectilinearView.limit = {

  /**
   * Returns a view limiter that constrains the yaw angle.
   * @param {number} min The minimum yaw value.
   * @param {number} max The maximum yaw value.
   * @return {RectilinearViewLimiter}
   */
  yaw: function(min, max) {
    return function limitYaw(params) {
      params.yaw = clamp(params.yaw, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the pitch angle.
   * @param {number} min The minimum pitch value.
   * @param {number} max The maximum pitch value.
   * @return {RectilinearViewLimiter}
   */
  pitch: function(min, max) {
    return function limitPitch(params) {
      params.pitch = clamp(params.pitch, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the roll angle.
   * @param {number} min The minimum roll value.
   * @param {number} max The maximum roll value.
   * @return {RectilinearViewLimiter}
   */
  roll: function(min, max) {
    return function limitRoll(params) {
      params.roll = clamp(params.roll, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the horizontal field of view.
   * @param {number} min The minimum horizontal field of view.
   * @param {number} max The maximum horizontal field of view.
   * @return {RectilinearViewLimiter}
   */
  hfov: function(min, max) {
    return function limitHfov(params) {
      var width = params.width;
      var height = params.height;
      if (width > 0 && height > 0) {
        var vmin = convertFov.htov(min, width, height);
        var vmax = convertFov.htov(max, width, height);
        params.fov = clamp(params.fov, vmin, vmax);
      }
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the vertical field of view.
   * @param {number} min The minimum vertical field of view.
   * @param {number} max The maximum vertical field of view.
   * @return {RectilinearViewLimiter}
   */
  vfov: function(min, max) {
    return function limitVfov(params) {
      params.fov = clamp(params.fov, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that prevents zooming in beyond the given
   * resolution.
   * @param {number} size The cube face width in pixels or, equivalently, one
   *     fourth of the equirectangular width in pixels.
   * @return {RectilinearViewLimiter}
   */
  resolution: function(size) {
    return function limitResolution(params) {
      var height = params.height;
      if (height) {
        var requiredPixels = pixelRatio() * height;
        var minFov = 2 * Math.atan(requiredPixels / size);
        params.fov = clamp(params.fov, minFov, Infinity);
      }
      return params;
    };
  },

  /**
   * Returns a view limiter that limits the horizontal and vertical field of
   * view, prevents zooming in past the image resolution, and limits the pitch
   * range to prevent the camera wrapping around at the poles. These are the
   * most common view constraints for a 360° panorama.
   * @param {number} maxResolution The cube face width in pixels or,
   *     equivalently, one fourth of the equirectangular width in pixels.
   * @param {number} maxVFov The maximum vertical field of view.
   * @param {number} [maxHFov=maxVFov] The maximum horizontal field of view.
   * @return {RectilinearViewLimiter}
   */
  traditional: function(maxResolution, maxVFov, maxHFov) {
    maxHFov = maxHFov != null ? maxHFov : maxVFov;

    return compose(
      RectilinearView.limit.resolution(maxResolution),
      RectilinearView.limit.vfov(0, maxVFov),
      RectilinearView.limit.hfov(0, maxHFov),
      RectilinearView.limit.pitch(-Math.PI/2, Math.PI/2));
  }

};


RectilinearView.type = RectilinearView.prototype.type = 'rectilinear';


module.exports = RectilinearView;

},{"../util/clamp":75,"../util/clearOwnProperties":76,"../util/compose":78,"../util/convertFov":79,"../util/decimal":80,"../util/mod":91,"../util/pixelRatio":95,"../util/real":98,"gl-matrix":3,"minimal-event-emitter":14}]},{},[54])(54)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYm93c2VyL2VzNS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9janMvbWF0Mi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL21hdDJkLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9janMvbWF0My5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL21hdDQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy9xdWF0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9janMvcXVhdDIuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy92ZWMyLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9janMvdmVjMy5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL3ZlYzQuanMiLCJub2RlX21vZHVsZXMvaGFtbWVyanMvaGFtbWVyLmpzIiwibm9kZV9tb2R1bGVzL21pbmltYWwtZXZlbnQtZW1pdHRlci9pbmRleC5qcyIsInNyYy9Ib3RzcG90LmpzIiwic3JjL0hvdHNwb3RDb250YWluZXIuanMiLCJzcmMvTGF5ZXIuanMiLCJzcmMvTmV0d29ya0Vycm9yLmpzIiwic3JjL1JlbmRlckxvb3AuanMiLCJzcmMvU2NlbmUuanMiLCJzcmMvVGV4dHVyZVN0b3JlLmpzIiwic3JjL1RpbGVTZWFyY2hlci5qcyIsInNyYy9UaW1lci5qcyIsInNyYy9WaWV3ZXIuanMiLCJzcmMvYXNzZXRzL0R5bmFtaWMuanMiLCJzcmMvYXNzZXRzL1N0YXRpYy5qcyIsInNyYy9hdXRvcm90YXRlLmpzIiwic3JjL2NvbGxlY3Rpb25zL0xydU1hcC5qcyIsInNyYy9jb2xsZWN0aW9ucy9McnVTZXQuanMiLCJzcmMvY29sbGVjdGlvbnMvTWFwLmpzIiwic3JjL2NvbGxlY3Rpb25zL1NldC5qcyIsInNyYy9jb2xsZWN0aW9ucy9Xb3JrUG9vbC5qcyIsInNyYy9jb2xsZWN0aW9ucy9Xb3JrUXVldWUuanMiLCJzcmMvY29sb3JFZmZlY3RzLmpzIiwic3JjL2NvbnRyb2xzL0NvbXBvc2VyLmpzIiwic3JjL2NvbnRyb2xzL0NvbnRyb2xDdXJzb3IuanMiLCJzcmMvY29udHJvbHMvQ29udHJvbHMuanMiLCJzcmMvY29udHJvbHMvRHJhZy5qcyIsInNyYy9jb250cm9scy9EeW5hbWljcy5qcyIsInNyYy9jb250cm9scy9FbGVtZW50UHJlc3MuanMiLCJzcmMvY29udHJvbHMvSGFtbWVyR2VzdHVyZXMuanMiLCJzcmMvY29udHJvbHMvS2V5LmpzIiwic3JjL2NvbnRyb2xzL1BpbmNoWm9vbS5qcyIsInNyYy9jb250cm9scy9RdHZyLmpzIiwic3JjL2NvbnRyb2xzL1Njcm9sbFpvb20uanMiLCJzcmMvY29udHJvbHMvVmVsb2NpdHkuanMiLCJzcmMvY29udHJvbHMvcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHMuanMiLCJzcmMvY29udHJvbHMvdXRpbC5qcyIsInNyYy9nZW9tZXRyaWVzL0N1YmUuanMiLCJzcmMvZ2VvbWV0cmllcy9FcXVpcmVjdC5qcyIsInNyYy9nZW9tZXRyaWVzL0ZsYXQuanMiLCJzcmMvZ2VvbWV0cmllcy9MZXZlbC5qcyIsInNyYy9nZW9tZXRyaWVzL2NvbW1vbi5qcyIsInNyYy9pbmRleC5qcyIsInNyYy9sb2FkZXJzL0h0bWxJbWFnZS5qcyIsInNyYy9yZW5kZXJlcnMvV2ViR2xCYXNlLmpzIiwic3JjL3JlbmRlcmVycy9XZWJHbENvbW1vbi5qcyIsInNyYy9yZW5kZXJlcnMvV2ViR2xDdWJlLmpzIiwic3JjL3JlbmRlcmVycy9XZWJHbEVxdWlyZWN0LmpzIiwic3JjL3JlbmRlcmVycy9XZWJHbEZsYXQuanMiLCJzcmMvcmVuZGVyZXJzL3JlZ2lzdGVyRGVmYXVsdFJlbmRlcmVycy5qcyIsInNyYy9zaGFkZXJzL2ZyYWdtZW50RXF1aXJlY3QuanMiLCJzcmMvc2hhZGVycy9mcmFnbWVudE5vcm1hbC5qcyIsInNyYy9zaGFkZXJzL3ZlcnRleEVxdWlyZWN0LmpzIiwic3JjL3NoYWRlcnMvdmVydGV4Tm9ybWFsLmpzIiwic3JjL3NvdXJjZXMvSW1hZ2VVcmwuanMiLCJzcmMvc291cmNlcy9TaW5nbGVBc3NldC5qcyIsInNyYy9zdGFnZXMvUmVuZGVyZXJSZWdpc3RyeS5qcyIsInNyYy9zdGFnZXMvU3RhZ2UuanMiLCJzcmMvc3RhZ2VzL1dlYkdsLmpzIiwic3JjL3V0aWwvYXN5bmMuanMiLCJzcmMvdXRpbC9jYWxjUmVjdC5qcyIsInNyYy91dGlsL2NhbmNlbGl6ZS5qcyIsInNyYy91dGlsL2NoYWluLmpzIiwic3JjL3V0aWwvY2xhbXAuanMiLCJzcmMvdXRpbC9jbGVhck93blByb3BlcnRpZXMuanMiLCJzcmMvdXRpbC9jbXAuanMiLCJzcmMvdXRpbC9jb21wb3NlLmpzIiwic3JjL3V0aWwvY29udmVydEZvdi5qcyIsInNyYy91dGlsL2RlY2ltYWwuanMiLCJzcmMvdXRpbC9kZWZhdWx0cy5qcyIsInNyYy91dGlsL2RlZmVyLmpzIiwic3JjL3V0aWwvZGVnVG9SYWQuanMiLCJzcmMvdXRpbC9kZWxheS5qcyIsInNyYy91dGlsL2RvbS5qcyIsInNyYy91dGlsL2V4dGVuZC5qcyIsInNyYy91dGlsL2dsb2JhbC5qcyIsInNyYy91dGlsL2hhc2guanMiLCJzcmMvdXRpbC9pbmhlcml0cy5qcyIsInNyYy91dGlsL2lzcG90LmpzIiwic3JjL3V0aWwvbW9kLmpzIiwic3JjL3V0aWwvbm9vcC5qcyIsInNyYy91dGlsL25vdy5qcyIsInNyYy91dGlsL29uY2UuanMiLCJzcmMvdXRpbC9waXhlbFJhdGlvLmpzIiwic3JjL3V0aWwvcG9zaXRpb25BYnNvbHV0ZWx5LmpzIiwic3JjL3V0aWwvcmFkVG9EZWcuanMiLCJzcmMvdXRpbC9yZWFsLmpzIiwic3JjL3V0aWwvcmV0cnkuanMiLCJzcmMvdXRpbC90d2Vlbi5qcyIsInNyYy91dGlsL3R5cGUuanMiLCJzcmMvdmlld3MvRmxhdC5qcyIsInNyYy92aWV3cy9SZWN0aWxpbmVhci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzllQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3AxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5M0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNodEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDejNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy91QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcnFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5ib3dzZXI9dCgpOmUuYm93c2VyPXQoKX0odGhpcywoZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gcihuKXtpZih0W25dKXJldHVybiB0W25dLmV4cG9ydHM7dmFyIGk9dFtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsciksaS5sPSEwLGkuZXhwb3J0c31yZXR1cm4gci5tPWUsci5jPXQsci5kPWZ1bmN0aW9uKGUsdCxuKXtyLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6bn0pfSxyLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sci50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1yKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoci5yKG4pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgaSBpbiBlKXIuZChuLGksZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxpKSk7cmV0dXJuIG59LHIubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gci5kKHQsXCJhXCIsdCksdH0sci5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxyLnA9XCJcIixyKHIucz05MCl9KHsxNzpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIG49cigxOCksaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9cmV0dXJuIGUuZ2V0Rmlyc3RNYXRjaD1mdW5jdGlvbihlLHQpe3ZhciByPXQubWF0Y2goZSk7cmV0dXJuIHImJnIubGVuZ3RoPjAmJnJbMV18fFwiXCJ9LGUuZ2V0U2Vjb25kTWF0Y2g9ZnVuY3Rpb24oZSx0KXt2YXIgcj10Lm1hdGNoKGUpO3JldHVybiByJiZyLmxlbmd0aD4xJiZyWzJdfHxcIlwifSxlLm1hdGNoQW5kUmV0dXJuQ29uc3Q9ZnVuY3Rpb24oZSx0LHIpe2lmKGUudGVzdCh0KSlyZXR1cm4gcn0sZS5nZXRXaW5kb3dzVmVyc2lvbk5hbWU9ZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2VcIk5UXCI6cmV0dXJuXCJOVFwiO2Nhc2VcIlhQXCI6cmV0dXJuXCJYUFwiO2Nhc2VcIk5UIDUuMFwiOnJldHVyblwiMjAwMFwiO2Nhc2VcIk5UIDUuMVwiOnJldHVyblwiWFBcIjtjYXNlXCJOVCA1LjJcIjpyZXR1cm5cIjIwMDNcIjtjYXNlXCJOVCA2LjBcIjpyZXR1cm5cIlZpc3RhXCI7Y2FzZVwiTlQgNi4xXCI6cmV0dXJuXCI3XCI7Y2FzZVwiTlQgNi4yXCI6cmV0dXJuXCI4XCI7Y2FzZVwiTlQgNi4zXCI6cmV0dXJuXCI4LjFcIjtjYXNlXCJOVCAxMC4wXCI6cmV0dXJuXCIxMFwiO2RlZmF1bHQ6cmV0dXJufX0sZS5nZXRNYWNPU1ZlcnNpb25OYW1lPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3BsaXQoXCIuXCIpLnNwbGljZSgwLDIpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfHwwfSkpO2lmKHQucHVzaCgwKSwxMD09PXRbMF0pc3dpdGNoKHRbMV0pe2Nhc2UgNTpyZXR1cm5cIkxlb3BhcmRcIjtjYXNlIDY6cmV0dXJuXCJTbm93IExlb3BhcmRcIjtjYXNlIDc6cmV0dXJuXCJMaW9uXCI7Y2FzZSA4OnJldHVyblwiTW91bnRhaW4gTGlvblwiO2Nhc2UgOTpyZXR1cm5cIk1hdmVyaWNrc1wiO2Nhc2UgMTA6cmV0dXJuXCJZb3NlbWl0ZVwiO2Nhc2UgMTE6cmV0dXJuXCJFbCBDYXBpdGFuXCI7Y2FzZSAxMjpyZXR1cm5cIlNpZXJyYVwiO2Nhc2UgMTM6cmV0dXJuXCJIaWdoIFNpZXJyYVwiO2Nhc2UgMTQ6cmV0dXJuXCJNb2phdmVcIjtjYXNlIDE1OnJldHVyblwiQ2F0YWxpbmFcIjtkZWZhdWx0OnJldHVybn19LGUuZ2V0QW5kcm9pZFZlcnNpb25OYW1lPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3BsaXQoXCIuXCIpLnNwbGljZSgwLDIpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfHwwfSkpO2lmKHQucHVzaCgwKSwhKDE9PT10WzBdJiZ0WzFdPDUpKXJldHVybiAxPT09dFswXSYmdFsxXTw2P1wiQ3VwY2FrZVwiOjE9PT10WzBdJiZ0WzFdPj02P1wiRG9udXRcIjoyPT09dFswXSYmdFsxXTwyP1wiRWNsYWlyXCI6Mj09PXRbMF0mJjI9PT10WzFdP1wiRnJveW9cIjoyPT09dFswXSYmdFsxXT4yP1wiR2luZ2VyYnJlYWRcIjozPT09dFswXT9cIkhvbmV5Y29tYlwiOjQ9PT10WzBdJiZ0WzFdPDE/XCJJY2UgQ3JlYW0gU2FuZHdpY2hcIjo0PT09dFswXSYmdFsxXTw0P1wiSmVsbHkgQmVhblwiOjQ9PT10WzBdJiZ0WzFdPj00P1wiS2l0S2F0XCI6NT09PXRbMF0/XCJMb2xsaXBvcFwiOjY9PT10WzBdP1wiTWFyc2htYWxsb3dcIjo3PT09dFswXT9cIk5vdWdhdFwiOjg9PT10WzBdP1wiT3Jlb1wiOjk9PT10WzBdP1wiUGllXCI6dm9pZCAwfSxlLmdldFZlcnNpb25QcmVjaXNpb249ZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3BsaXQoXCIuXCIpLmxlbmd0aH0sZS5jb21wYXJlVmVyc2lvbnM9ZnVuY3Rpb24odCxyLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgaT1lLmdldFZlcnNpb25QcmVjaXNpb24odCkscz1lLmdldFZlcnNpb25QcmVjaXNpb24ociksYT1NYXRoLm1heChpLHMpLG89MCx1PWUubWFwKFt0LHJdLChmdW5jdGlvbih0KXt2YXIgcj1hLWUuZ2V0VmVyc2lvblByZWNpc2lvbih0KSxuPXQrbmV3IEFycmF5KHIrMSkuam9pbihcIi4wXCIpO3JldHVybiBlLm1hcChuLnNwbGl0KFwiLlwiKSwoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBBcnJheSgyMC1lLmxlbmd0aCkuam9pbihcIjBcIikrZX0pKS5yZXZlcnNlKCl9KSk7Zm9yKG4mJihvPWEtTWF0aC5taW4oaSxzKSksYS09MTthPj1vOyl7aWYodVswXVthXT51WzFdW2FdKXJldHVybiAxO2lmKHVbMF1bYV09PT11WzFdW2FdKXtpZihhPT09bylyZXR1cm4gMDthLT0xfWVsc2UgaWYodVswXVthXTx1WzFdW2FdKXJldHVybi0xfX0sZS5tYXA9ZnVuY3Rpb24oZSx0KXt2YXIgcixuPVtdO2lmKEFycmF5LnByb3RvdHlwZS5tYXApcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChlLHQpO2ZvcihyPTA7cjxlLmxlbmd0aDtyKz0xKW4ucHVzaCh0KGVbcl0pKTtyZXR1cm4gbn0sZS5maW5kPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbjtpZihBcnJheS5wcm90b3R5cGUuZmluZClyZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChlLHQpO2ZvcihyPTAsbj1lLmxlbmd0aDtyPG47cis9MSl7dmFyIGk9ZVtyXTtpZih0KGkscikpcmV0dXJuIGl9fSxlLmFzc2lnbj1mdW5jdGlvbihlKXtmb3IodmFyIHQscixuPWUsaT1hcmd1bWVudHMubGVuZ3RoLHM9bmV3IEFycmF5KGk+MT9pLTE6MCksYT0xO2E8aTthKyspc1thLTFdPWFyZ3VtZW50c1thXTtpZihPYmplY3QuYXNzaWduKXJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCxbZV0uY29uY2F0KHMpKTt2YXIgbz1mdW5jdGlvbigpe3ZhciBlPXNbdF07XCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lJiZPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbih0KXtuW3RdPWVbdF19KSl9O2Zvcih0PTAscj1zLmxlbmd0aDt0PHI7dCs9MSlvKCk7cmV0dXJuIGV9LGUuZ2V0QnJvd3NlckFsaWFzPWZ1bmN0aW9uKGUpe3JldHVybiBuLkJST1dTRVJfQUxJQVNFU19NQVBbZV19LGUuZ2V0QnJvd3NlclR5cGVCeUFsaWFzPWZ1bmN0aW9uKGUpe3JldHVybiBuLkJST1dTRVJfTUFQW2VdfHxcIlwifSxlfSgpO3QuZGVmYXVsdD1pLGUuZXhwb3J0cz10LmRlZmF1bHR9LDE4OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5FTkdJTkVfTUFQPXQuT1NfTUFQPXQuUExBVEZPUk1TX01BUD10LkJST1dTRVJfTUFQPXQuQlJPV1NFUl9BTElBU0VTX01BUD12b2lkIDA7dC5CUk9XU0VSX0FMSUFTRVNfTUFQPXtcIkFtYXpvbiBTaWxrXCI6XCJhbWF6b25fc2lsa1wiLFwiQW5kcm9pZCBCcm93c2VyXCI6XCJhbmRyb2lkXCIsQmFkYTpcImJhZGFcIixCbGFja0JlcnJ5OlwiYmxhY2tiZXJyeVwiLENocm9tZTpcImNocm9tZVwiLENocm9taXVtOlwiY2hyb21pdW1cIixFbGVjdHJvbjpcImVsZWN0cm9uXCIsRXBpcGhhbnk6XCJlcGlwaGFueVwiLEZpcmVmb3g6XCJmaXJlZm94XCIsRm9jdXM6XCJmb2N1c1wiLEdlbmVyaWM6XCJnZW5lcmljXCIsXCJHb29nbGUgU2VhcmNoXCI6XCJnb29nbGVfc2VhcmNoXCIsR29vZ2xlYm90OlwiZ29vZ2xlYm90XCIsXCJJbnRlcm5ldCBFeHBsb3JlclwiOlwiaWVcIixcIkstTWVsZW9uXCI6XCJrX21lbGVvblwiLE1heHRob246XCJtYXh0aG9uXCIsXCJNaWNyb3NvZnQgRWRnZVwiOlwiZWRnZVwiLFwiTVogQnJvd3NlclwiOlwibXpcIixcIk5BVkVSIFdoYWxlIEJyb3dzZXJcIjpcIm5hdmVyXCIsT3BlcmE6XCJvcGVyYVwiLFwiT3BlcmEgQ29hc3RcIjpcIm9wZXJhX2NvYXN0XCIsUGhhbnRvbUpTOlwicGhhbnRvbWpzXCIsUHVmZmluOlwicHVmZmluXCIsUXVwWmlsbGE6XCJxdXB6aWxsYVwiLFFROlwicXFcIixRUUxpdGU6XCJxcWxpdGVcIixTYWZhcmk6XCJzYWZhcmlcIixTYWlsZmlzaDpcInNhaWxmaXNoXCIsXCJTYW1zdW5nIEludGVybmV0IGZvciBBbmRyb2lkXCI6XCJzYW1zdW5nX2ludGVybmV0XCIsU2VhTW9ua2V5Olwic2VhbW9ua2V5XCIsU2xlaXBuaXI6XCJzbGVpcG5pclwiLFN3aW5nOlwic3dpbmdcIixUaXplbjpcInRpemVuXCIsXCJVQyBCcm93c2VyXCI6XCJ1Y1wiLFZpdmFsZGk6XCJ2aXZhbGRpXCIsXCJXZWJPUyBCcm93c2VyXCI6XCJ3ZWJvc1wiLFdlQ2hhdDpcIndlY2hhdFwiLFwiWWFuZGV4IEJyb3dzZXJcIjpcInlhbmRleFwiLFJva3U6XCJyb2t1XCJ9O3QuQlJPV1NFUl9NQVA9e2FtYXpvbl9zaWxrOlwiQW1hem9uIFNpbGtcIixhbmRyb2lkOlwiQW5kcm9pZCBCcm93c2VyXCIsYmFkYTpcIkJhZGFcIixibGFja2JlcnJ5OlwiQmxhY2tCZXJyeVwiLGNocm9tZTpcIkNocm9tZVwiLGNocm9taXVtOlwiQ2hyb21pdW1cIixlbGVjdHJvbjpcIkVsZWN0cm9uXCIsZXBpcGhhbnk6XCJFcGlwaGFueVwiLGZpcmVmb3g6XCJGaXJlZm94XCIsZm9jdXM6XCJGb2N1c1wiLGdlbmVyaWM6XCJHZW5lcmljXCIsZ29vZ2xlYm90OlwiR29vZ2xlYm90XCIsZ29vZ2xlX3NlYXJjaDpcIkdvb2dsZSBTZWFyY2hcIixpZTpcIkludGVybmV0IEV4cGxvcmVyXCIsa19tZWxlb246XCJLLU1lbGVvblwiLG1heHRob246XCJNYXh0aG9uXCIsZWRnZTpcIk1pY3Jvc29mdCBFZGdlXCIsbXo6XCJNWiBCcm93c2VyXCIsbmF2ZXI6XCJOQVZFUiBXaGFsZSBCcm93c2VyXCIsb3BlcmE6XCJPcGVyYVwiLG9wZXJhX2NvYXN0OlwiT3BlcmEgQ29hc3RcIixwaGFudG9tanM6XCJQaGFudG9tSlNcIixwdWZmaW46XCJQdWZmaW5cIixxdXB6aWxsYTpcIlF1cFppbGxhXCIscXE6XCJRUSBCcm93c2VyXCIscXFsaXRlOlwiUVEgQnJvd3NlciBMaXRlXCIsc2FmYXJpOlwiU2FmYXJpXCIsc2FpbGZpc2g6XCJTYWlsZmlzaFwiLHNhbXN1bmdfaW50ZXJuZXQ6XCJTYW1zdW5nIEludGVybmV0IGZvciBBbmRyb2lkXCIsc2VhbW9ua2V5OlwiU2VhTW9ua2V5XCIsc2xlaXBuaXI6XCJTbGVpcG5pclwiLHN3aW5nOlwiU3dpbmdcIix0aXplbjpcIlRpemVuXCIsdWM6XCJVQyBCcm93c2VyXCIsdml2YWxkaTpcIlZpdmFsZGlcIix3ZWJvczpcIldlYk9TIEJyb3dzZXJcIix3ZWNoYXQ6XCJXZUNoYXRcIix5YW5kZXg6XCJZYW5kZXggQnJvd3NlclwifTt0LlBMQVRGT1JNU19NQVA9e3RhYmxldDpcInRhYmxldFwiLG1vYmlsZTpcIm1vYmlsZVwiLGRlc2t0b3A6XCJkZXNrdG9wXCIsdHY6XCJ0dlwifTt0Lk9TX01BUD17V2luZG93c1Bob25lOlwiV2luZG93cyBQaG9uZVwiLFdpbmRvd3M6XCJXaW5kb3dzXCIsTWFjT1M6XCJtYWNPU1wiLGlPUzpcImlPU1wiLEFuZHJvaWQ6XCJBbmRyb2lkXCIsV2ViT1M6XCJXZWJPU1wiLEJsYWNrQmVycnk6XCJCbGFja0JlcnJ5XCIsQmFkYTpcIkJhZGFcIixUaXplbjpcIlRpemVuXCIsTGludXg6XCJMaW51eFwiLENocm9tZU9TOlwiQ2hyb21lIE9TXCIsUGxheVN0YXRpb240OlwiUGxheVN0YXRpb24gNFwiLFJva3U6XCJSb2t1XCJ9O3QuRU5HSU5FX01BUD17RWRnZUhUTUw6XCJFZGdlSFRNTFwiLEJsaW5rOlwiQmxpbmtcIixUcmlkZW50OlwiVHJpZGVudFwiLFByZXN0bzpcIlByZXN0b1wiLEdlY2tvOlwiR2Vja29cIixXZWJLaXQ6XCJXZWJLaXRcIn19LDkwOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoOTEpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0scz1yKDE4KTtmdW5jdGlvbiBhKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX12YXIgbz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9dmFyIHQscixuO3JldHVybiBlLmdldFBhcnNlcj1mdW5jdGlvbihlLHQpe2lmKHZvaWQgMD09PXQmJih0PSExKSxcInN0cmluZ1wiIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoXCJVc2VyQWdlbnQgc2hvdWxkIGJlIGEgc3RyaW5nXCIpO3JldHVybiBuZXcgaS5kZWZhdWx0KGUsdCl9LGUucGFyc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBpLmRlZmF1bHQoZSkuZ2V0UmVzdWx0KCl9LHQ9ZSxuPVt7a2V5OlwiQlJPV1NFUl9NQVBcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5CUk9XU0VSX01BUH19LHtrZXk6XCJFTkdJTkVfTUFQXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuRU5HSU5FX01BUH19LHtrZXk6XCJPU19NQVBcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5PU19NQVB9fSx7a2V5OlwiUExBVEZPUk1TX01BUFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBzLlBMQVRGT1JNU19NQVB9fV0sKHI9bnVsbCkmJmEodC5wcm90b3R5cGUsciksbiYmYSh0LG4pLGV9KCk7dC5kZWZhdWx0PW8sZS5leHBvcnRzPXQuZGVmYXVsdH0sOTE6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuPXUocig5MikpLGk9dShyKDkzKSkscz11KHIoOTQpKSxhPXUocig5NSkpLG89dShyKDE3KSk7ZnVuY3Rpb24gdShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19dmFyIGQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9ITEpLG51bGw9PWV8fFwiXCI9PT1lKXRocm93IG5ldyBFcnJvcihcIlVzZXJBZ2VudCBwYXJhbWV0ZXIgY2FuJ3QgYmUgZW1wdHlcIik7dGhpcy5fdWE9ZSx0aGlzLnBhcnNlZFJlc3VsdD17fSwhMCE9PXQmJnRoaXMucGFyc2UoKX12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5nZXRVQT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl91YX0sdC50ZXN0PWZ1bmN0aW9uKGUpe3JldHVybiBlLnRlc3QodGhpcy5fdWEpfSx0LnBhcnNlQnJvd3Nlcj1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcj17fTt2YXIgdD1vLmRlZmF1bHQuZmluZChuLmRlZmF1bHQsKGZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGVzdClyZXR1cm4gdC50ZXN0KGUpO2lmKHQudGVzdCBpbnN0YW5jZW9mIEFycmF5KXJldHVybiB0LnRlc3Quc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIGUudGVzdCh0KX0pKTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyJ3MgdGVzdCBmdW5jdGlvbiBpcyBub3QgdmFsaWRcIil9KSk7cmV0dXJuIHQmJih0aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyPXQuZGVzY3JpYmUodGhpcy5nZXRVQSgpKSksdGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcn0sdC5nZXRCcm93c2VyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyc2VkUmVzdWx0LmJyb3dzZXI/dGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcjp0aGlzLnBhcnNlQnJvd3NlcigpfSx0LmdldEJyb3dzZXJOYW1lPWZ1bmN0aW9uKGUpe3JldHVybiBlP1N0cmluZyh0aGlzLmdldEJyb3dzZXIoKS5uYW1lKS50b0xvd2VyQ2FzZSgpfHxcIlwiOnRoaXMuZ2V0QnJvd3NlcigpLm5hbWV8fFwiXCJ9LHQuZ2V0QnJvd3NlclZlcnNpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRCcm93c2VyKCkudmVyc2lvbn0sdC5nZXRPUz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnNlZFJlc3VsdC5vcz90aGlzLnBhcnNlZFJlc3VsdC5vczp0aGlzLnBhcnNlT1MoKX0sdC5wYXJzZU9TPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnBhcnNlZFJlc3VsdC5vcz17fTt2YXIgdD1vLmRlZmF1bHQuZmluZChpLmRlZmF1bHQsKGZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGVzdClyZXR1cm4gdC50ZXN0KGUpO2lmKHQudGVzdCBpbnN0YW5jZW9mIEFycmF5KXJldHVybiB0LnRlc3Quc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIGUudGVzdCh0KX0pKTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyJ3MgdGVzdCBmdW5jdGlvbiBpcyBub3QgdmFsaWRcIil9KSk7cmV0dXJuIHQmJih0aGlzLnBhcnNlZFJlc3VsdC5vcz10LmRlc2NyaWJlKHRoaXMuZ2V0VUEoKSkpLHRoaXMucGFyc2VkUmVzdWx0Lm9zfSx0LmdldE9TTmFtZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLmdldE9TKCkubmFtZTtyZXR1cm4gZT9TdHJpbmcodCkudG9Mb3dlckNhc2UoKXx8XCJcIjp0fHxcIlwifSx0LmdldE9TVmVyc2lvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldE9TKCkudmVyc2lvbn0sdC5nZXRQbGF0Zm9ybT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybT90aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybTp0aGlzLnBhcnNlUGxhdGZvcm0oKX0sdC5nZXRQbGF0Zm9ybVR5cGU9ZnVuY3Rpb24oZSl7dm9pZCAwPT09ZSYmKGU9ITEpO3ZhciB0PXRoaXMuZ2V0UGxhdGZvcm0oKS50eXBlO3JldHVybiBlP1N0cmluZyh0KS50b0xvd2VyQ2FzZSgpfHxcIlwiOnR8fFwiXCJ9LHQucGFyc2VQbGF0Zm9ybT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYXJzZWRSZXN1bHQucGxhdGZvcm09e307dmFyIHQ9by5kZWZhdWx0LmZpbmQocy5kZWZhdWx0LChmdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRlc3QpcmV0dXJuIHQudGVzdChlKTtpZih0LnRlc3QgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm4gdC50ZXN0LnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBlLnRlc3QodCl9KSk7dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIHRlc3QgZnVuY3Rpb24gaXMgbm90IHZhbGlkXCIpfSkpO3JldHVybiB0JiYodGhpcy5wYXJzZWRSZXN1bHQucGxhdGZvcm09dC5kZXNjcmliZSh0aGlzLmdldFVBKCkpKSx0aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybX0sdC5nZXRFbmdpbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lP3RoaXMucGFyc2VkUmVzdWx0LmVuZ2luZTp0aGlzLnBhcnNlRW5naW5lKCl9LHQuZ2V0RW5naW5lTmFtZT1mdW5jdGlvbihlKXtyZXR1cm4gZT9TdHJpbmcodGhpcy5nZXRFbmdpbmUoKS5uYW1lKS50b0xvd2VyQ2FzZSgpfHxcIlwiOnRoaXMuZ2V0RW5naW5lKCkubmFtZXx8XCJcIn0sdC5wYXJzZUVuZ2luZT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lPXt9O3ZhciB0PW8uZGVmYXVsdC5maW5kKGEuZGVmYXVsdCwoZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC50ZXN0KXJldHVybiB0LnRlc3QoZSk7aWYodC50ZXN0IGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuIHQudGVzdC5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gZS50ZXN0KHQpfSkpO3Rocm93IG5ldyBFcnJvcihcIkJyb3dzZXIncyB0ZXN0IGZ1bmN0aW9uIGlzIG5vdCB2YWxpZFwiKX0pKTtyZXR1cm4gdCYmKHRoaXMucGFyc2VkUmVzdWx0LmVuZ2luZT10LmRlc2NyaWJlKHRoaXMuZ2V0VUEoKSkpLHRoaXMucGFyc2VkUmVzdWx0LmVuZ2luZX0sdC5wYXJzZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnNlQnJvd3NlcigpLHRoaXMucGFyc2VPUygpLHRoaXMucGFyc2VQbGF0Zm9ybSgpLHRoaXMucGFyc2VFbmdpbmUoKSx0aGlzfSx0LmdldFJlc3VsdD1mdW5jdGlvbigpe3JldHVybiBvLmRlZmF1bHQuYXNzaWduKHt9LHRoaXMucGFyc2VkUmVzdWx0KX0sdC5zYXRpc2ZpZXM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPXt9LG49MCxpPXt9LHM9MDtpZihPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgYT1lW3RdO1wic3RyaW5nXCI9PXR5cGVvZiBhPyhpW3RdPWEscys9MSk6XCJvYmplY3RcIj09dHlwZW9mIGEmJihyW3RdPWEsbis9MSl9KSksbj4wKXt2YXIgYT1PYmplY3Qua2V5cyhyKSx1PW8uZGVmYXVsdC5maW5kKGEsKGZ1bmN0aW9uKGUpe3JldHVybiB0LmlzT1MoZSl9KSk7aWYodSl7dmFyIGQ9dGhpcy5zYXRpc2ZpZXMoclt1XSk7aWYodm9pZCAwIT09ZClyZXR1cm4gZH12YXIgYz1vLmRlZmF1bHQuZmluZChhLChmdW5jdGlvbihlKXtyZXR1cm4gdC5pc1BsYXRmb3JtKGUpfSkpO2lmKGMpe3ZhciBmPXRoaXMuc2F0aXNmaWVzKHJbY10pO2lmKHZvaWQgMCE9PWYpcmV0dXJuIGZ9fWlmKHM+MCl7dmFyIGw9T2JqZWN0LmtleXMoaSksaD1vLmRlZmF1bHQuZmluZChsLChmdW5jdGlvbihlKXtyZXR1cm4gdC5pc0Jyb3dzZXIoZSwhMCl9KSk7aWYodm9pZCAwIT09aClyZXR1cm4gdGhpcy5jb21wYXJlVmVyc2lvbihpW2hdKX19LHQuaXNCcm93c2VyPWZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09dCYmKHQ9ITEpO3ZhciByPXRoaXMuZ2V0QnJvd3Nlck5hbWUoKS50b0xvd2VyQ2FzZSgpLG49ZS50b0xvd2VyQ2FzZSgpLGk9by5kZWZhdWx0LmdldEJyb3dzZXJUeXBlQnlBbGlhcyhuKTtyZXR1cm4gdCYmaSYmKG49aS50b0xvd2VyQ2FzZSgpKSxuPT09cn0sdC5jb21wYXJlVmVyc2lvbj1mdW5jdGlvbihlKXt2YXIgdD1bMF0scj1lLG49ITEsaT10aGlzLmdldEJyb3dzZXJWZXJzaW9uKCk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGkpcmV0dXJuXCI+XCI9PT1lWzBdfHxcIjxcIj09PWVbMF0/KHI9ZS5zdWJzdHIoMSksXCI9XCI9PT1lWzFdPyhuPSEwLHI9ZS5zdWJzdHIoMikpOnQ9W10sXCI+XCI9PT1lWzBdP3QucHVzaCgxKTp0LnB1c2goLTEpKTpcIj1cIj09PWVbMF0/cj1lLnN1YnN0cigxKTpcIn5cIj09PWVbMF0mJihuPSEwLHI9ZS5zdWJzdHIoMSkpLHQuaW5kZXhPZihvLmRlZmF1bHQuY29tcGFyZVZlcnNpb25zKGkscixuKSk+LTF9LHQuaXNPUz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nZXRPU05hbWUoITApPT09U3RyaW5nKGUpLnRvTG93ZXJDYXNlKCl9LHQuaXNQbGF0Zm9ybT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nZXRQbGF0Zm9ybVR5cGUoITApPT09U3RyaW5nKGUpLnRvTG93ZXJDYXNlKCl9LHQuaXNFbmdpbmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZ2V0RW5naW5lTmFtZSghMCk9PT1TdHJpbmcoZSkudG9Mb3dlckNhc2UoKX0sdC5pcz1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0hMSksdGhpcy5pc0Jyb3dzZXIoZSx0KXx8dGhpcy5pc09TKGUpfHx0aGlzLmlzUGxhdGZvcm0oZSl9LHQuc29tZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiB2b2lkIDA9PT1lJiYoZT1bXSksZS5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4gdC5pcyhlKX0pKX0sZX0oKTt0LmRlZmF1bHQ9ZCxlLmV4cG9ydHM9dC5kZWZhdWx0fSw5MjpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIG4saT0obj1yKDE3KSkmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59O3ZhciBzPS92ZXJzaW9uXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGE9W3t0ZXN0OlsvZ29vZ2xlYm90L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiR29vZ2xlYm90XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2dvb2dsZWJvdFxcLyhcXGQrKFxcLlxcZCspKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL29wZXJhL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiT3BlcmFcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86b3BlcmEpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL29wclxcL3xvcGlvcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk9wZXJhXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Om9wcnxvcGlvcylbXFxzL10oXFxTKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9TYW1zdW5nQnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlNhbXN1bmcgSW50ZXJuZXQgZm9yIEFuZHJvaWRcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86U2Ftc3VuZ0Jyb3dzZXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL1doYWxlL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiTkFWRVIgV2hhbGUgQnJvd3NlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzp3aGFsZSlbXFxzL10oXFxkKyg/OlxcLlxcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9NWkJyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJNWiBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Ok1aQnJvd3NlcilbXFxzL10oXFxkKyg/OlxcLlxcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9mb2N1cy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkZvY3VzXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmZvY3VzKVtcXHMvXShcXGQrKD86XFwuXFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3N3aW5nL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU3dpbmdcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86c3dpbmcpW1xccy9dKFxcZCsoPzpcXC5cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvY29hc3QvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJPcGVyYSBDb2FzdFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpjb2FzdClbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvb3B0XFwvXFxkKyg/Oi4/Xz9cXGQrKSsvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJPcGVyYSBUb3VjaFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpvcHQpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3lhYnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIllhbmRleCBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnlhYnJvd3NlcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvdWNicm93c2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiVUMgQnJvd3NlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzp1Y2Jyb3dzZXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL01heHRob258bXhpb3MvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJNYXh0aG9uXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Ok1heHRob258bXhpb3MpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2VwaXBoYW55L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiRXBpcGhhbnlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86ZXBpcGhhbnkpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3B1ZmZpbi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlB1ZmZpblwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpwdWZmaW4pW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NsZWlwbmlyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2xlaXBuaXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86c2xlaXBuaXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2stbWVsZW9uL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiSy1NZWxlb25cIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86ay1tZWxlb24pW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL21pY3JvbWVzc2VuZ2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiV2VDaGF0XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Om1pY3JvbWVzc2VuZ2VyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9xcWJyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6L3FxYnJvd3NlcmxpdGUvaS50ZXN0KGUpP1wiUVEgQnJvd3NlciBMaXRlXCI6XCJRUSBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnFxYnJvd3NlcmxpdGV8cXFicm93c2VyKVsvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9tc2llfHRyaWRlbnQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJJbnRlcm5ldCBFeHBsb3JlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzptc2llIHxydjopKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL1xcc2VkZ1xcLy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk1pY3Jvc29mdCBFZGdlXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL1xcc2VkZ1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9lZGcoW2VhXXxpb3MpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiTWljcm9zb2Z0IEVkZ2VcIn0scj1pLmRlZmF1bHQuZ2V0U2Vjb25kTWF0Y2goL2VkZyhbZWFdfGlvcylcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvdml2YWxkaS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlZpdmFsZGlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvdml2YWxkaVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zZWFtb25rZXkvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTZWFNb25rZXlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvc2VhbW9ua2V5XFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NhaWxmaXNoL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2FpbGZpc2hcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvc2FpbGZpc2hcXHM/YnJvd3NlclxcLyhcXGQrKFxcLlxcZCspPykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zaWxrL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQW1hem9uIFNpbGtcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvc2lsa1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9waGFudG9tL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiUGhhbnRvbUpTXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3BoYW50b21qc1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zbGltZXJqcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlNsaW1lckpTXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3NsaW1lcmpzXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2JsYWNrYmVycnl8XFxiYmJcXGQrL2ksL3JpbVxcc3RhYmxldC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkJsYWNrQmVycnlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvYmxhY2tiZXJyeVtcXGRdK1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy8od2VifGhwdylbbzBdcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIldlYk9TIEJyb3dzZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvdyg/OmViKT9bbzBdc2Jyb3dzZXJcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvYmFkYS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkJhZGFcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvZG9sZmluXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3RpemVuL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiVGl6ZW5cIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86dGl6ZW5cXHM/KT9icm93c2VyXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3F1cHppbGxhL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiUXVwWmlsbGFcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86cXVwemlsbGEpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiRmlyZWZveFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpmaXJlZm94fGljZXdlYXNlbHxmeGlvcylbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvZWxlY3Ryb24vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJFbGVjdHJvblwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzplbGVjdHJvbilcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvTWl1aUJyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJNaXVpXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Ok1pdWlCcm93c2VyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9jaHJvbWl1bS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkNocm9taXVtXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmNocm9taXVtKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9jaHJvbWV8Y3Jpb3N8Y3Jtby9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkNocm9tZVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpjaHJvbWV8Y3Jpb3N8Y3JtbylcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvR1NBL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiR29vZ2xlIFNlYXJjaFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpHU0EpXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpmdW5jdGlvbihlKXt2YXIgdD0hZS50ZXN0KC9saWtlIGFuZHJvaWQvaSkscj1lLnRlc3QoL2FuZHJvaWQvaSk7cmV0dXJuIHQmJnJ9LGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQW5kcm9pZCBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9wbGF5c3RhdGlvbiA0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiUGxheVN0YXRpb24gNFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc2FmYXJpfGFwcGxld2Via2l0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2FmYXJpXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy8uKi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD0tMSE9PWUuc2VhcmNoKFwiXFxcXChcIik/L14oLiopXFwvKC4qKVsgXFx0XVxcKCguKikvOi9eKC4qKVxcLyguKikgLztyZXR1cm57bmFtZTppLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCh0LGUpLHZlcnNpb246aS5kZWZhdWx0LmdldFNlY29uZE1hdGNoKHQsZSl9fX1dO3QuZGVmYXVsdD1hLGUuZXhwb3J0cz10LmRlZmF1bHR9LDkzOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoMTcpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0scz1yKDE4KTt2YXIgYT1be3Rlc3Q6Wy9Sb2t1XFwvRFZQL10sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL1Jva3VcXC9EVlAtKFxcZCtcXC5cXGQrKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLlJva3UsdmVyc2lvbjp0fX19LHt0ZXN0Olsvd2luZG93cyBwaG9uZS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvd2luZG93cyBwaG9uZSAoPzpvcyk/XFxzPyhcXGQrKFxcLlxcZCspKikvaSxlKTtyZXR1cm57bmFtZTpzLk9TX01BUC5XaW5kb3dzUGhvbmUsdmVyc2lvbjp0fX19LHt0ZXN0Olsvd2luZG93cyAvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL1dpbmRvd3MgKChOVHxYUCkoIFxcZFxcZD8uXFxkKT8pL2ksZSkscj1pLmRlZmF1bHQuZ2V0V2luZG93c1ZlcnNpb25OYW1lKHQpO3JldHVybntuYW1lOnMuT1NfTUFQLldpbmRvd3MsdmVyc2lvbjp0LHZlcnNpb25OYW1lOnJ9fX0se3Rlc3Q6Wy9NYWNpbnRvc2goLio/KSBGeGlPUyguKj8pXFwvL10sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6cy5PU19NQVAuaU9TfSxyPWkuZGVmYXVsdC5nZXRTZWNvbmRNYXRjaCgvKFZlcnNpb25cXC8pKFxcZFtcXGQuXSspLyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9tYWNpbnRvc2gvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL21hYyBvcyB4IChcXGQrKFxcLj9fP1xcZCspKykvaSxlKS5yZXBsYWNlKC9bX1xcc10vZyxcIi5cIikscj1pLmRlZmF1bHQuZ2V0TWFjT1NWZXJzaW9uTmFtZSh0KSxuPXtuYW1lOnMuT1NfTUFQLk1hY09TLHZlcnNpb246dH07cmV0dXJuIHImJihuLnZlcnNpb25OYW1lPXIpLG59fSx7dGVzdDpbLyhpcG9kfGlwaG9uZXxpcGFkKS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvb3MgKFxcZCsoW19cXHNdXFxkKykqKSBsaWtlIG1hYyBvcyB4L2ksZSkucmVwbGFjZSgvW19cXHNdL2csXCIuXCIpO3JldHVybntuYW1lOnMuT1NfTUFQLmlPUyx2ZXJzaW9uOnR9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9IWUudGVzdCgvbGlrZSBhbmRyb2lkL2kpLHI9ZS50ZXN0KC9hbmRyb2lkL2kpO3JldHVybiB0JiZyfSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvYW5kcm9pZFtcXHMvLV0oXFxkKyhcXC5cXGQrKSopL2ksZSkscj1pLmRlZmF1bHQuZ2V0QW5kcm9pZFZlcnNpb25OYW1lKHQpLG49e25hbWU6cy5PU19NQVAuQW5kcm9pZCx2ZXJzaW9uOnR9O3JldHVybiByJiYobi52ZXJzaW9uTmFtZT1yKSxufX0se3Rlc3Q6Wy8od2VifGhwdylbbzBdcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86d2VifGhwdylbbzBdc1xcLyhcXGQrKFxcLlxcZCspKikvaSxlKSxyPXtuYW1lOnMuT1NfTUFQLldlYk9TfTtyZXR1cm4gdCYmdC5sZW5ndGgmJihyLnZlcnNpb249dCkscn19LHt0ZXN0OlsvYmxhY2tiZXJyeXxcXGJiYlxcZCsvaSwvcmltXFxzdGFibGV0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9yaW1cXHN0YWJsZXRcXHNvc1xccyhcXGQrKFxcLlxcZCspKikvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2JsYWNrYmVycnlcXGQrXFwvKFxcZCsoW19cXHNdXFxkKykqKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvXFxiYmIoXFxkKykvaSxlKTtyZXR1cm57bmFtZTpzLk9TX01BUC5CbGFja0JlcnJ5LHZlcnNpb246dH19fSx7dGVzdDpbL2JhZGEvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2JhZGFcXC8oXFxkKyhcXC5cXGQrKSopL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuQmFkYSx2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy90aXplbi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvdGl6ZW5bL1xcc10oXFxkKyhcXC5cXGQrKSopL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuVGl6ZW4sdmVyc2lvbjp0fX19LHt0ZXN0OlsvbGludXgvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57bmFtZTpzLk9TX01BUC5MaW51eH19fSx7dGVzdDpbL0NyT1MvXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybntuYW1lOnMuT1NfTUFQLkNocm9tZU9TfX19LHt0ZXN0OlsvUGxheVN0YXRpb24gNC9dLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9QbGF5U3RhdGlvbiA0Wy9cXHNdKFxcZCsoXFwuXFxkKykqKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLlBsYXlTdGF0aW9uNCx2ZXJzaW9uOnR9fX1dO3QuZGVmYXVsdD1hLGUuZXhwb3J0cz10LmRlZmF1bHR9LDk0OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoMTcpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0scz1yKDE4KTt2YXIgYT1be3Rlc3Q6Wy9nb29nbGVib3QvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcImJvdFwiLHZlbmRvcjpcIkdvb2dsZVwifX19LHt0ZXN0OlsvaHVhd2VpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oY2FuLWwwMSkvaSxlKSYmXCJOb3ZhXCIscj17dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlLHZlbmRvcjpcIkh1YXdlaVwifTtyZXR1cm4gdCYmKHIubW9kZWw9dCkscn19LHt0ZXN0OlsvbmV4dXNcXHMqKD86N3w4fDl8MTApLiovaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0LHZlbmRvcjpcIk5leHVzXCJ9fX0se3Rlc3Q6Wy9pcGFkL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldCx2ZW5kb3I6XCJBcHBsZVwiLG1vZGVsOlwiaVBhZFwifX19LHt0ZXN0OlsvTWFjaW50b3NoKC4qPykgRnhpT1MoLio/KVxcLy9dLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldCx2ZW5kb3I6XCJBcHBsZVwiLG1vZGVsOlwiaVBhZFwifX19LHt0ZXN0Olsva2Z0dCBidWlsZC9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXQsdmVuZG9yOlwiQW1hem9uXCIsbW9kZWw6XCJLaW5kbGUgRmlyZSBIRCA3XCJ9fX0se3Rlc3Q6Wy9zaWxrL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldCx2ZW5kb3I6XCJBbWF6b25cIn19fSx7dGVzdDpbL3RhYmxldCg/ISBwYykvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0fX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3ZhciB0PWUudGVzdCgvaXBvZHxpcGhvbmUvaSkscj1lLnRlc3QoL2xpa2UgKGlwb2R8aXBob25lKS9pKTtyZXR1cm4gdCYmIXJ9LGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oaXBvZHxpcGhvbmUpL2ksZSk7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZSx2ZW5kb3I6XCJBcHBsZVwiLG1vZGVsOnR9fX0se3Rlc3Q6Wy9uZXh1c1xccypbMC02XS4qL2ksL2dhbGF4eSBuZXh1cy9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGUsdmVuZG9yOlwiTmV4dXNcIn19fSx7dGVzdDpbL1teLV1tb2JpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZX19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cImJsYWNrYmVycnlcIj09PWUuZ2V0QnJvd3Nlck5hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGUsdmVuZG9yOlwiQmxhY2tCZXJyeVwifX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwiYmFkYVwiPT09ZS5nZXRCcm93c2VyTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZX19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cIndpbmRvd3MgcGhvbmVcIj09PWUuZ2V0QnJvd3Nlck5hbWUoKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlLHZlbmRvcjpcIk1pY3Jvc29mdFwifX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3ZhciB0PU51bWJlcihTdHJpbmcoZS5nZXRPU1ZlcnNpb24oKSkuc3BsaXQoXCIuXCIpWzBdKTtyZXR1cm5cImFuZHJvaWRcIj09PWUuZ2V0T1NOYW1lKCEwKSYmdD49M30sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0fX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwiYW5kcm9pZFwiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGV9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJtYWNvc1wiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5kZXNrdG9wLHZlbmRvcjpcIkFwcGxlXCJ9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJ3aW5kb3dzXCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLmRlc2t0b3B9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJsaW51eFwiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5kZXNrdG9wfX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwicGxheXN0YXRpb24gNFwiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50dn19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cInJva3VcIj09PWUuZ2V0T1NOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudHZ9fX1dO3QuZGVmYXVsdD1hLGUuZXhwb3J0cz10LmRlZmF1bHR9LDk1OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoMTcpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0scz1yKDE4KTt2YXIgYT1be3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJtaWNyb3NvZnQgZWRnZVwiPT09ZS5nZXRCcm93c2VyTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKGUpe2lmKC9cXHNlZGdcXC8vaS50ZXN0KGUpKXJldHVybntuYW1lOnMuRU5HSU5FX01BUC5CbGlua307dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2VkZ2VcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJue25hbWU6cy5FTkdJTkVfTUFQLkVkZ2VIVE1MLHZlcnNpb246dH19fSx7dGVzdDpbL3RyaWRlbnQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6cy5FTkdJTkVfTUFQLlRyaWRlbnR9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3RyaWRlbnRcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVybiBlLnRlc3QoL3ByZXN0by9pKX0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6cy5FTkdJTkVfTUFQLlByZXN0b30scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvcHJlc3RvXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpmdW5jdGlvbihlKXt2YXIgdD1lLnRlc3QoL2dlY2tvL2kpLHI9ZS50ZXN0KC9saWtlIGdlY2tvL2kpO3JldHVybiB0JiYhcn0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6cy5FTkdJTkVfTUFQLkdlY2tvfSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9nZWNrb1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy8oYXBwbGUpP3dlYmtpdFxcLzUzN1xcLjM2L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue25hbWU6cy5FTkdJTkVfTUFQLkJsaW5rfX19LHt0ZXN0OlsvKGFwcGxlKT93ZWJraXQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6cy5FTkdJTkVfTUFQLldlYktpdH0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvd2Via2l0XFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fV07dC5kZWZhdWx0PWEsZS5leHBvcnRzPXQuZGVmYXVsdH19KX0pKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2V0TWF0cml4QXJyYXlUeXBlID0gc2V0TWF0cml4QXJyYXlUeXBlO1xuZXhwb3J0cy50b1JhZGlhbiA9IHRvUmFkaWFuO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG5leHBvcnRzLlJBTkRPTSA9IGV4cG9ydHMuQVJSQVlfVFlQRSA9IGV4cG9ydHMuRVBTSUxPTiA9IHZvaWQgMDtcblxuLyoqXHJcbiAqIENvbW1vbiB1dGlsaXRpZXNcclxuICogQG1vZHVsZSBnbE1hdHJpeFxyXG4gKi9cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG52YXIgRVBTSUxPTiA9IDAuMDAwMDAxO1xuZXhwb3J0cy5FUFNJTE9OID0gRVBTSUxPTjtcbnZhciBBUlJBWV9UWVBFID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmV4cG9ydHMuQVJSQVlfVFlQRSA9IEFSUkFZX1RZUEU7XG52YXIgUkFORE9NID0gTWF0aC5yYW5kb207XG4vKipcclxuICogU2V0cyB0aGUgdHlwZSBvZiBhcnJheSB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZlY3RvcnMgYW5kIG1hdHJpY2VzXHJcbiAqXHJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5Q29uc3RydWN0b3IgfCBBcnJheUNvbnN0cnVjdG9yfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XHJcbiAqL1xuXG5leHBvcnRzLlJBTkRPTSA9IFJBTkRPTTtcblxuZnVuY3Rpb24gc2V0TWF0cml4QXJyYXlUeXBlKHR5cGUpIHtcbiAgZXhwb3J0cy5BUlJBWV9UWVBFID0gQVJSQVlfVFlQRSA9IHR5cGU7XG59XG5cbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuLyoqXHJcbiAqIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBBbmdsZSBpbiBEZWdyZWVzXHJcbiAqL1xuXG5mdW5jdGlvbiB0b1JhZGlhbihhKSB7XG4gIHJldHVybiBhICogZGVncmVlO1xufVxuLyoqXHJcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHZhbHVlLCB3aXRoaW4gYW4gYWJzb2x1dGVcclxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzc1xyXG4gKiB0aGFuIG9yIGVxdWFsIHRvIDEuMCwgYW5kIGEgcmVsYXRpdmUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIGxhcmdlciB2YWx1ZXMpXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCBudW1iZXIgdG8gdGVzdC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xufVxuXG5pZiAoIU1hdGguaHlwb3QpIE1hdGguaHlwb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB5ID0gMCxcbiAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB5ICs9IGFyZ3VtZW50c1tpXSAqIGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoeSk7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnZlYzQgPSBleHBvcnRzLnZlYzMgPSBleHBvcnRzLnZlYzIgPSBleHBvcnRzLnF1YXQyID0gZXhwb3J0cy5xdWF0ID0gZXhwb3J0cy5tYXQ0ID0gZXhwb3J0cy5tYXQzID0gZXhwb3J0cy5tYXQyZCA9IGV4cG9ydHMubWF0MiA9IGV4cG9ydHMuZ2xNYXRyaXggPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbmV4cG9ydHMuZ2xNYXRyaXggPSBnbE1hdHJpeDtcblxudmFyIG1hdDIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9tYXQyLmpzXCIpKTtcblxuZXhwb3J0cy5tYXQyID0gbWF0MjtcblxudmFyIG1hdDJkID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWF0MmQuanNcIikpO1xuXG5leHBvcnRzLm1hdDJkID0gbWF0MmQ7XG5cbnZhciBtYXQzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWF0My5qc1wiKSk7XG5cbmV4cG9ydHMubWF0MyA9IG1hdDM7XG5cbnZhciBtYXQ0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWF0NC5qc1wiKSk7XG5cbmV4cG9ydHMubWF0NCA9IG1hdDQ7XG5cbnZhciBxdWF0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vcXVhdC5qc1wiKSk7XG5cbmV4cG9ydHMucXVhdCA9IHF1YXQ7XG5cbnZhciBxdWF0MiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3F1YXQyLmpzXCIpKTtcblxuZXhwb3J0cy5xdWF0MiA9IHF1YXQyO1xuXG52YXIgdmVjMiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3ZlYzIuanNcIikpO1xuXG5leHBvcnRzLnZlYzIgPSB2ZWMyO1xuXG52YXIgdmVjMyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3ZlYzMuanNcIikpO1xuXG5leHBvcnRzLnZlYzMgPSB2ZWMzO1xuXG52YXIgdmVjNCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3ZlYzQuanNcIikpO1xuXG5leHBvcnRzLnZlYzQgPSB2ZWM0O1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZTtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuZXhwb3J0cy5hZGpvaW50ID0gYWRqb2ludDtcbmV4cG9ydHMuZGV0ZXJtaW5hbnQgPSBkZXRlcm1pbmFudDtcbmV4cG9ydHMubXVsdGlwbHkgPSBtdWx0aXBseTtcbmV4cG9ydHMucm90YXRlID0gcm90YXRlO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5mcm9tUm90YXRpb24gPSBmcm9tUm90YXRpb247XG5leHBvcnRzLmZyb21TY2FsaW5nID0gZnJvbVNjYWxpbmc7XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuZnJvYiA9IGZyb2I7XG5leHBvcnRzLkxEVSA9IExEVTtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuZXhwb3J0cy5leGFjdEVxdWFscyA9IGV4YWN0RXF1YWxzO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG5leHBvcnRzLm11bHRpcGx5U2NhbGFyID0gbXVsdGlwbHlTY2FsYXI7XG5leHBvcnRzLm11bHRpcGx5U2NhbGFyQW5kQWRkID0gbXVsdGlwbHlTY2FsYXJBbmRBZGQ7XG5leHBvcnRzLnN1YiA9IGV4cG9ydHMubXVsID0gdm9pZCAwO1xuXG52YXIgZ2xNYXRyaXggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9jb21tb24uanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vKipcclxuICogMngyIE1hdHJpeFxyXG4gKiBAbW9kdWxlIG1hdDJcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcclxuICpcclxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcclxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcclxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IG1hdDIgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMylcclxuICogQHJldHVybnMge21hdDJ9IG91dCBBIG5ldyAyeDIgbWF0cml4XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0xMDtcbiAgb3V0WzNdID0gbTExO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDIgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGVcbiAgLy8gc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMSA9IGFbMV07XG4gICAgb3V0WzFdID0gYVsyXTtcbiAgICBvdXRbMl0gPSBhMTtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMl07XG4gICAgb3V0WzJdID0gYVsxXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBJbnZlcnRzIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHZhciBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMTtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBhMyAqIGRldDtcbiAgb3V0WzFdID0gLWExICogZGV0O1xuICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gIG91dFszXSA9IGEwICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZXNzZWNhcnkgaWYgb3V0ID09IGFcbiAgdmFyIGEwID0gYVswXTtcbiAgb3V0WzBdID0gYVszXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdO1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhMCAqIGMgKyBhMiAqIHM7XG4gIG91dFsxXSA9IGExICogYyArIGEzICogcztcbiAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIHYwID0gdlswXSxcbiAgICAgIHYxID0gdlsxXTtcbiAgb3V0WzBdID0gYTAgKiB2MDtcbiAgb3V0WzFdID0gYTEgKiB2MDtcbiAgb3V0WzJdID0gYTIgKiB2MTtcbiAgb3V0WzNdID0gYTMgKiB2MTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAtcztcbiAgb3V0WzNdID0gYztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcIm1hdDIoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcclxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cclxuICovXG5cblxuZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xufVxuLyoqXHJcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IEwgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBEIHRoZSBkaWFnb25hbCBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IFUgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBpbnB1dCBtYXRyaXggdG8gZmFjdG9yaXplXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIExEVShMLCBELCBVLCBhKSB7XG4gIExbMl0gPSBhWzJdIC8gYVswXTtcbiAgVVswXSA9IGFbMF07XG4gIFVbMV0gPSBhWzFdO1xuICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdO1xuICByZXR1cm4gW0wsIEQsIFVdO1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpO1xufVxuLyoqXHJcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MidzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubXVsID0gbXVsO1xudmFyIHN1YiA9IHN1YnRyYWN0O1xuZXhwb3J0cy5zdWIgPSBzdWI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMuZnJvbVZhbHVlcyA9IGZyb21WYWx1ZXM7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuZXhwb3J0cy5kZXRlcm1pbmFudCA9IGRldGVybWluYW50O1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy5yb3RhdGUgPSByb3RhdGU7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbmV4cG9ydHMuZnJvbVJvdGF0aW9uID0gZnJvbVJvdGF0aW9uO1xuZXhwb3J0cy5mcm9tU2NhbGluZyA9IGZyb21TY2FsaW5nO1xuZXhwb3J0cy5mcm9tVHJhbnNsYXRpb24gPSBmcm9tVHJhbnNsYXRpb247XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuZnJvYiA9IGZyb2I7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuc3VidHJhY3QgPSBzdWJ0cmFjdDtcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXIgPSBtdWx0aXBseVNjYWxhcjtcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXJBbmRBZGQgPSBtdWx0aXBseVNjYWxhckFuZEFkZDtcbmV4cG9ydHMuZXhhY3RFcXVhbHMgPSBleGFjdEVxdWFscztcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5zdWIgPSBleHBvcnRzLm11bCA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLyoqXHJcbiAqIDJ4MyBNYXRyaXhcclxuICogQG1vZHVsZSBtYXQyZFxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQSBtYXQyZCBjb250YWlucyBzaXggZWxlbWVudHMgZGVmaW5lZCBhczpcclxuICogPHByZT5cclxuICogW2EsIGIsXHJcbiAqICBjLCBkLFxyXG4gKiAgdHgsIHR5XVxyXG4gKiA8L3ByZT5cclxuICogVGhpcyBpcyBhIHNob3J0IGZvcm0gZm9yIHRoZSAzeDMgbWF0cml4OlxyXG4gKiA8cHJlPlxyXG4gKiBbYSwgYiwgMCxcclxuICogIGMsIGQsIDAsXHJcbiAqICB0eCwgdHksIDFdXHJcbiAqIDwvcHJlPlxyXG4gKiBUaGUgbGFzdCBjb2x1bW4gaXMgaWdub3JlZCBzbyB0aGUgYXJyYXkgaXMgc2hvcnRlciBhbmQgb3BlcmF0aW9ucyBhcmUgZmFzdGVyLlxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MmRcclxuICpcclxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgfVxuXG4gIG91dFswXSA9IDE7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQyZCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MmQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgbWF0MmQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IG1hdDJkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBDb21wb25lbnQgQSAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gZCBDb21wb25lbnQgRCAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcclxuICogQHJldHVybnMge21hdDJkfSBBIG5ldyBtYXQyZFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tVmFsdWVzKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gIG91dFswXSA9IGE7XG4gIG91dFsxXSA9IGI7XG4gIG91dFsyXSA9IGM7XG4gIG91dFszXSA9IGQ7XG4gIG91dFs0XSA9IHR4O1xuICBvdXRbNV0gPSB0eTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyZCB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBDb21wb25lbnQgQSAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gZCBDb21wb25lbnQgRCAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgYSwgYiwgYywgZCwgdHgsIHR5KSB7XG4gIG91dFswXSA9IGE7XG4gIG91dFsxXSA9IGI7XG4gIG91dFsyXSA9IGM7XG4gIG91dFszXSA9IGQ7XG4gIG91dFs0XSA9IHR4O1xuICBvdXRbNV0gPSB0eTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBJbnZlcnRzIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhYSA9IGFbMF0sXG4gICAgICBhYiA9IGFbMV0sXG4gICAgICBhYyA9IGFbMl0sXG4gICAgICBhZCA9IGFbM107XG4gIHZhciBhdHggPSBhWzRdLFxuICAgICAgYXR5ID0gYVs1XTtcbiAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IGFkICogZGV0O1xuICBvdXRbMV0gPSAtYWIgKiBkZXQ7XG4gIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gIG91dFs0XSA9IChhYyAqIGF0eSAtIGFkICogYXR4KSAqIGRldDtcbiAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cblxuZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyZCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXSxcbiAgICAgIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XTtcbiAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XG4gIG91dFs1XSA9IGExICogYjQgKyBhMyAqIGI1ICsgYTU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdDJkIGJ5IHRoZSBnaXZlbiBhbmdsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYTAgKiBjICsgYTIgKiBzO1xuICBvdXRbMV0gPSBhMSAqIGMgKyBhMyAqIHM7XG4gIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gIG91dFs0XSA9IGE0O1xuICBvdXRbNV0gPSBhNTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKiovXG5cblxuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV07XG4gIHZhciB2MCA9IHZbMF0sXG4gICAgICB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwICogdjA7XG4gIG91dFsxXSA9IGExICogdjA7XG4gIG91dFsyXSA9IGEyICogdjE7XG4gIG91dFszXSA9IGEzICogdjE7XG4gIG91dFs0XSA9IGE0O1xuICBvdXRbNV0gPSBhNTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2xhdGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHRoZSB2ZWMyIHRvIHRyYW5zbGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqKi9cblxuXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV07XG4gIHZhciB2MCA9IHZbMF0sXG4gICAgICB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwO1xuICBvdXRbMV0gPSBhMTtcbiAgb3V0WzJdID0gYTI7XG4gIG91dFszXSA9IGEzO1xuICBvdXRbNF0gPSBhMCAqIHYwICsgYTIgKiB2MSArIGE0O1xuICBvdXRbNV0gPSBhMSAqIHYwICsgYTMgKiB2MSArIGE1O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyZC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IGM7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDJkLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gdlsxXTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDJkLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gdlswXTtcbiAgb3V0WzVdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cblxuZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0MmQoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIsIFwiICsgYVs0XSArIFwiLCBcIiArIGFbNV0gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdLCAxKTtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQyZCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQyZCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdICogc2NhbGU7XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbnZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubXVsID0gbXVsO1xudmFyIHN1YiA9IHN1YnRyYWN0O1xuZXhwb3J0cy5zdWIgPSBzdWI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5mcm9tTWF0NCA9IGZyb21NYXQ0O1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuZnJvbVZhbHVlcyA9IGZyb21WYWx1ZXM7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLmFkam9pbnQgPSBhZGpvaW50O1xuZXhwb3J0cy5kZXRlcm1pbmFudCA9IGRldGVybWluYW50O1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMuZnJvbVRyYW5zbGF0aW9uID0gZnJvbVRyYW5zbGF0aW9uO1xuZXhwb3J0cy5mcm9tUm90YXRpb24gPSBmcm9tUm90YXRpb247XG5leHBvcnRzLmZyb21TY2FsaW5nID0gZnJvbVNjYWxpbmc7XG5leHBvcnRzLmZyb21NYXQyZCA9IGZyb21NYXQyZDtcbmV4cG9ydHMuZnJvbVF1YXQgPSBmcm9tUXVhdDtcbmV4cG9ydHMubm9ybWFsRnJvbU1hdDQgPSBub3JtYWxGcm9tTWF0NDtcbmV4cG9ydHMucHJvamVjdGlvbiA9IHByb2plY3Rpb247XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuZnJvYiA9IGZyb2I7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuc3VidHJhY3QgPSBzdWJ0cmFjdDtcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXIgPSBtdWx0aXBseVNjYWxhcjtcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXJBbmRBZGQgPSBtdWx0aXBseVNjYWxhckFuZEFkZDtcbmV4cG9ydHMuZXhhY3RFcXVhbHMgPSBleGFjdEVxdWFscztcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5zdWIgPSBleHBvcnRzLm11bCA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLyoqXHJcbiAqIDN4MyBNYXRyaXhcclxuICogQG1vZHVsZSBtYXQzXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQzXHJcbiAqXHJcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcGllcyB0aGUgdXBwZXItbGVmdCAzeDMgdmFsdWVzIGludG8gdGhlIGdpdmVuIG1hdDMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgM3gzIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSAgIHRoZSBzb3VyY2UgNHg0IG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21NYXQ0KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzRdO1xuICBvdXRbNF0gPSBhWzVdO1xuICBvdXRbNV0gPSBhWzZdO1xuICBvdXRbNl0gPSBhWzhdO1xuICBvdXRbN10gPSBhWzldO1xuICBvdXRbOF0gPSBhWzEwXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQzIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBtYXQzIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDYpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxyXG4gKiBAcmV0dXJucyB7bWF0M30gQSBuZXcgbWF0M1xyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMTA7XG4gIG91dFs0XSA9IG0xMTtcbiAgb3V0WzVdID0gbTEyO1xuICBvdXRbNl0gPSBtMjA7XG4gIG91dFs3XSA9IG0yMTtcbiAgb3V0WzhdID0gbTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDMgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDYpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTEwO1xuICBvdXRbNF0gPSBtMTE7XG4gIG91dFs1XSA9IG0xMjtcbiAgb3V0WzZdID0gbTIwO1xuICBvdXRbN10gPSBtMjE7XG4gIG91dFs4XSA9IG0yMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBtYXQzIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMTIgPSBhWzVdO1xuICAgIG91dFsxXSA9IGFbM107XG4gICAgb3V0WzJdID0gYVs2XTtcbiAgICBvdXRbM10gPSBhMDE7XG4gICAgb3V0WzVdID0gYVs3XTtcbiAgICBvdXRbNl0gPSBhMDI7XG4gICAgb3V0WzddID0gYTEyO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVszXTtcbiAgICBvdXRbMl0gPSBhWzZdO1xuICAgIG91dFszXSA9IGFbMV07XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzddO1xuICAgIG91dFs2XSA9IGFbMl07XG4gICAgb3V0WzddID0gYVs1XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBJbnZlcnRzIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XTtcbiAgdmFyIGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMTtcbiAgdmFyIGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjA7XG4gIHZhciBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjA7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxO1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IGIwMSAqIGRldDtcbiAgb3V0WzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICBvdXRbMl0gPSAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGRldDtcbiAgb3V0WzNdID0gYjExICogZGV0O1xuICBvdXRbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgb3V0WzVdID0gKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogZGV0O1xuICBvdXRbNl0gPSBiMjEgKiBkZXQ7XG4gIG91dFs3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgb3V0WzhdID0gKGExMSAqIGEwMCAtIGEwMSAqIGExMCkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XTtcbiAgb3V0WzBdID0gYTExICogYTIyIC0gYTEyICogYTIxO1xuICBvdXRbMV0gPSBhMDIgKiBhMjEgLSBhMDEgKiBhMjI7XG4gIG91dFsyXSA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgb3V0WzNdID0gYTEyICogYTIwIC0gYTEwICogYTIyO1xuICBvdXRbNF0gPSBhMDAgKiBhMjIgLSBhMDIgKiBhMjA7XG4gIG91dFs1XSA9IGEwMiAqIGExMCAtIGEwMCAqIGExMjtcbiAgb3V0WzZdID0gYTEwICogYTIxIC0gYTExICogYTIwO1xuICBvdXRbN10gPSBhMDEgKiBhMjAgLSBhMDAgKiBhMjE7XG4gIG91dFs4XSA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIHJldHVybiBhMDAgKiAoYTIyICogYTExIC0gYTEyICogYTIxKSArIGEwMSAqICgtYTIyICogYTEwICsgYTEyICogYTIwKSArIGEwMiAqIChhMjEgKiBhMTAgLSBhMTEgKiBhMjApO1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XTtcbiAgdmFyIGIwMCA9IGJbMF0sXG4gICAgICBiMDEgPSBiWzFdLFxuICAgICAgYjAyID0gYlsyXTtcbiAgdmFyIGIxMCA9IGJbM10sXG4gICAgICBiMTEgPSBiWzRdLFxuICAgICAgYjEyID0gYls1XTtcbiAgdmFyIGIyMCA9IGJbNl0sXG4gICAgICBiMjEgPSBiWzddLFxuICAgICAgYjIyID0gYls4XTtcbiAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICBvdXRbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjE7XG4gIG91dFsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcbiAgb3V0WzNdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwO1xuICBvdXRbNF0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjE7XG4gIG91dFs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcbiAgb3V0WzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xuICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gIG91dFs4XSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2xhdGUgYSBtYXQzIGJ5IHRoZSBnaXZlbiB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XSxcbiAgICAgIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XSxcbiAgICAgIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV07XG4gIG91dFswXSA9IGEwMDtcbiAgb3V0WzFdID0gYTAxO1xuICBvdXRbMl0gPSBhMDI7XG4gIG91dFszXSA9IGExMDtcbiAgb3V0WzRdID0gYTExO1xuICBvdXRbNV0gPSBhMTI7XG4gIG91dFs2XSA9IHggKiBhMDAgKyB5ICogYTEwICsgYTIwO1xuICBvdXRbN10gPSB4ICogYTAxICsgeSAqIGExMSArIGEyMTtcbiAgb3V0WzhdID0geCAqIGEwMiArIHkgKiBhMTIgKyBhMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdDMgYnkgdGhlIGdpdmVuIGFuZ2xlXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV0sXG4gICAgICBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF0sXG4gICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBjICogYTAwICsgcyAqIGExMDtcbiAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gIG91dFsyXSA9IGMgKiBhMDIgKyBzICogYTEyO1xuICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgb3V0WzRdID0gYyAqIGExMSAtIHMgKiBhMDE7XG4gIG91dFs1XSA9IGMgKiBhMTIgLSBzICogYTAyO1xuICBvdXRbNl0gPSBhMjA7XG4gIG91dFs3XSA9IGEyMTtcbiAgb3V0WzhdID0gYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICoqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXTtcbiAgb3V0WzBdID0geCAqIGFbMF07XG4gIG91dFsxXSA9IHggKiBhWzFdO1xuICBvdXRbMl0gPSB4ICogYVsyXTtcbiAgb3V0WzNdID0geSAqIGFbM107XG4gIG91dFs0XSA9IHkgKiBhWzRdO1xuICBvdXRbNV0gPSB5ICogYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0My50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IHZbMF07XG4gIG91dFs3XSA9IHZbMV07XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0My5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gLXM7XG4gIG91dFs0XSA9IGM7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0My5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHZbMV07XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29waWVzIHRoZSB2YWx1ZXMgZnJvbSBhIG1hdDJkIGludG8gYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNvcHlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKiovXG5cblxuZnVuY3Rpb24gZnJvbU1hdDJkKG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSBhWzJdO1xuICBvdXRbNF0gPSBhWzNdO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSBhWzRdO1xuICBvdXRbN10gPSBhWzVdO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYSAzeDMgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHl4ID0geSAqIHgyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB6eCA9IHogKiB4MjtcbiAgdmFyIHp5ID0geiAqIHkyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbM10gPSB5eCAtIHd6O1xuICBvdXRbNl0gPSB6eCArIHd5O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzddID0genkgLSB3eDtcbiAgb3V0WzJdID0genggLSB3eTtcbiAgb3V0WzVdID0genkgKyB3eDtcbiAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBhIDN4MyBub3JtYWwgbWF0cml4ICh0cmFuc3Bvc2UgaW52ZXJzZSkgZnJvbSB0aGUgNHg0IG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cclxuICpcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxGcm9tTWF0NChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIHZhciBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIHZhciBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICBvdXRbMV0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gIG91dFszXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgMkQgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHlvdXIgZ2wgY29udGV4dFxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiBnbCBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcHJvamVjdGlvbihvdXQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgb3V0WzBdID0gMiAvIHdpZHRoO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtMiAvIGhlaWdodDtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gLTE7XG4gIG91dFs3XSA9IDE7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJtYXQzKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIiwgXCIgKyBhWzhdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcclxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cclxuICovXG5cblxuZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0sIGFbN10sIGFbOF0pO1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgb3V0WzRdID0gYVs0XSAqIGI7XG4gIG91dFs1XSA9IGFbNV0gKiBiO1xuICBvdXRbNl0gPSBhWzZdICogYjtcbiAgb3V0WzddID0gYVs3XSAqIGI7XG4gIG91dFs4XSA9IGFbOF0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDMncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdICogc2NhbGU7XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdICogc2NhbGU7XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdICogc2NhbGU7XG4gIG91dFs3XSA9IGFbN10gKyBiWzddICogc2NhbGU7XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJiBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgYVs4XSA9PT0gYls4XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV0sXG4gICAgICBhNiA9IGFbNl0sXG4gICAgICBhNyA9IGFbN10sXG4gICAgICBhOCA9IGFbOF07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM10sXG4gICAgICBiNCA9IGJbNF0sXG4gICAgICBiNSA9IGJbNV0sXG4gICAgICBiNiA9IGJbNl0sXG4gICAgICBiNyA9IGJbN10sXG4gICAgICBiOCA9IGJbOF07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiYgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJiBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiYgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmIE1hdGguYWJzKGE4IC0gYjgpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE4KSwgTWF0aC5hYnMoYjgpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubXVsID0gbXVsO1xudmFyIHN1YiA9IHN1YnRyYWN0O1xuZXhwb3J0cy5zdWIgPSBzdWI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuZnJvbVZhbHVlcyA9IGZyb21WYWx1ZXM7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLmFkam9pbnQgPSBhZGpvaW50O1xuZXhwb3J0cy5kZXRlcm1pbmFudCA9IGRldGVybWluYW50O1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMucm90YXRlWCA9IHJvdGF0ZVg7XG5leHBvcnRzLnJvdGF0ZVkgPSByb3RhdGVZO1xuZXhwb3J0cy5yb3RhdGVaID0gcm90YXRlWjtcbmV4cG9ydHMuZnJvbVRyYW5zbGF0aW9uID0gZnJvbVRyYW5zbGF0aW9uO1xuZXhwb3J0cy5mcm9tU2NhbGluZyA9IGZyb21TY2FsaW5nO1xuZXhwb3J0cy5mcm9tUm90YXRpb24gPSBmcm9tUm90YXRpb247XG5leHBvcnRzLmZyb21YUm90YXRpb24gPSBmcm9tWFJvdGF0aW9uO1xuZXhwb3J0cy5mcm9tWVJvdGF0aW9uID0gZnJvbVlSb3RhdGlvbjtcbmV4cG9ydHMuZnJvbVpSb3RhdGlvbiA9IGZyb21aUm90YXRpb247XG5leHBvcnRzLmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uID0gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb247XG5leHBvcnRzLmZyb21RdWF0MiA9IGZyb21RdWF0MjtcbmV4cG9ydHMuZ2V0VHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbjtcbmV4cG9ydHMuZ2V0U2NhbGluZyA9IGdldFNjYWxpbmc7XG5leHBvcnRzLmdldFJvdGF0aW9uID0gZ2V0Um90YXRpb247XG5leHBvcnRzLmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUgPSBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlO1xuZXhwb3J0cy5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luID0gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbjtcbmV4cG9ydHMuZnJvbVF1YXQgPSBmcm9tUXVhdDtcbmV4cG9ydHMuZnJ1c3R1bSA9IGZydXN0dW07XG5leHBvcnRzLnBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmU7XG5leHBvcnRzLnBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3ID0gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXc7XG5leHBvcnRzLm9ydGhvID0gb3J0aG87XG5leHBvcnRzLmxvb2tBdCA9IGxvb2tBdDtcbmV4cG9ydHMudGFyZ2V0VG8gPSB0YXJnZXRUbztcbmV4cG9ydHMuc3RyID0gc3RyO1xuZXhwb3J0cy5mcm9iID0gZnJvYjtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuZXhwb3J0cy5tdWx0aXBseVNjYWxhciA9IG11bHRpcGx5U2NhbGFyO1xuZXhwb3J0cy5tdWx0aXBseVNjYWxhckFuZEFkZCA9IG11bHRpcGx5U2NhbGFyQW5kQWRkO1xuZXhwb3J0cy5leGFjdEVxdWFscyA9IGV4YWN0RXF1YWxzO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG5leHBvcnRzLnN1YiA9IGV4cG9ydHMubXVsID0gdm9pZCAwO1xuXG52YXIgZ2xNYXRyaXggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9jb21tb24uanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vKipcclxuICogNHg0IE1hdHJpeDxicj5Gb3JtYXQ6IGNvbHVtbi1tYWpvciwgd2hlbiB0eXBlZCBvdXQgaXQgbG9va3MgbGlrZSByb3ctbWFqb3I8YnI+VGhlIG1hdHJpY2VzIGFyZSBiZWluZyBwb3N0IG11bHRpcGxpZWQuXHJcbiAqIEBtb2R1bGUgbWF0NFxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IG1hdDQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMyBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMSBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcclxuICogQHJldHVybnMge21hdDR9IEEgbmV3IG1hdDRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTAzO1xuICBvdXRbNF0gPSBtMTA7XG4gIG91dFs1XSA9IG0xMTtcbiAgb3V0WzZdID0gbTEyO1xuICBvdXRbN10gPSBtMTM7XG4gIG91dFs4XSA9IG0yMDtcbiAgb3V0WzldID0gbTIxO1xuICBvdXRbMTBdID0gbTIyO1xuICBvdXRbMTFdID0gbTIzO1xuICBvdXRbMTJdID0gbTMwO1xuICBvdXRbMTNdID0gbTMxO1xuICBvdXRbMTRdID0gbTMyO1xuICBvdXRbMTVdID0gbTMzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA1KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA4KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjMgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdO1xuICAgIHZhciBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddO1xuICAgIHZhciBhMjMgPSBhWzExXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYTAxO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYTAyO1xuICAgIG91dFs5XSA9IGExMjtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGEwMztcbiAgICBvdXRbMTNdID0gYTEzO1xuICAgIG91dFsxNF0gPSBhMjM7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYVsxXTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYVsyXTtcbiAgICBvdXRbOV0gPSBhWzZdO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGFbM107XG4gICAgb3V0WzEzXSA9IGFbN107XG4gICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogSW52ZXJ0cyBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTtcbiAgb3V0WzBdID0gYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpO1xuICBvdXRbMV0gPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gIG91dFsyXSA9IGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKTtcbiAgb3V0WzNdID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbNF0gPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gIG91dFs1XSA9IGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKTtcbiAgb3V0WzZdID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbN10gPSBhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMik7XG4gIG91dFs4XSA9IGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKTtcbiAgb3V0WzldID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICBvdXRbMTBdID0gYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpO1xuICBvdXRbMTFdID0gLShhMDAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICBvdXRbMTNdID0gYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpO1xuICBvdXRbMTRdID0gLShhMDAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICBvdXRbMTVdID0gYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIHZhciBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIHZhciBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTsgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG5cbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzNdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls0XTtcbiAgYjEgPSBiWzVdO1xuICBiMiA9IGJbNl07XG4gIGIzID0gYls3XTtcbiAgb3V0WzRdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFs1XSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbNl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzddID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls4XTtcbiAgYjEgPSBiWzldO1xuICBiMiA9IGJbMTBdO1xuICBiMyA9IGJbMTFdO1xuICBvdXRbOF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzldID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsxMF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzExXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbMTJdO1xuICBiMSA9IGJbMTNdO1xuICBiMiA9IGJbMTRdO1xuICBiMyA9IGJbMTVdO1xuICBvdXRbMTJdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxM10gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzE0XSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbMTVdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdLFxuICAgICAgeiA9IHZbMl07XG4gIHZhciBhMDAsIGEwMSwgYTAyLCBhMDM7XG4gIHZhciBhMTAsIGExMSwgYTEyLCBhMTM7XG4gIHZhciBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgaWYgKGEgPT09IG91dCkge1xuICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICB9IGVsc2Uge1xuICAgIGEwMCA9IGFbMF07XG4gICAgYTAxID0gYVsxXTtcbiAgICBhMDIgPSBhWzJdO1xuICAgIGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTtcbiAgICBhMTEgPSBhWzVdO1xuICAgIGExMiA9IGFbNl07XG4gICAgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdO1xuICAgIGEyMSA9IGFbOV07XG4gICAgYTIyID0gYVsxMF07XG4gICAgYTIzID0gYVsxMV07XG4gICAgb3V0WzBdID0gYTAwO1xuICAgIG91dFsxXSA9IGEwMTtcbiAgICBvdXRbMl0gPSBhMDI7XG4gICAgb3V0WzNdID0gYTAzO1xuICAgIG91dFs0XSA9IGExMDtcbiAgICBvdXRbNV0gPSBhMTE7XG4gICAgb3V0WzZdID0gYTEyO1xuICAgIG91dFs3XSA9IGExMztcbiAgICBvdXRbOF0gPSBhMjA7XG4gICAgb3V0WzldID0gYTIxO1xuICAgIG91dFsxMF0gPSBhMjI7XG4gICAgb3V0WzExXSA9IGEyMztcbiAgICBvdXRbMTJdID0gYTAwICogeCArIGExMCAqIHkgKyBhMjAgKiB6ICsgYVsxMl07XG4gICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICBvdXRbMTVdID0gYTAzICogeCArIGExMyAqIHkgKyBhMjMgKiB6ICsgYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMyBub3QgdXNpbmcgdmVjdG9yaXphdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKiovXG5cblxuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdLFxuICAgICAgeiA9IHZbMl07XG4gIG91dFswXSA9IGFbMF0gKiB4O1xuICBvdXRbMV0gPSBhWzFdICogeDtcbiAgb3V0WzJdID0gYVsyXSAqIHg7XG4gIG91dFszXSA9IGFbM10gKiB4O1xuICBvdXRbNF0gPSBhWzRdICogeTtcbiAgb3V0WzVdID0gYVs1XSAqIHk7XG4gIG91dFs2XSA9IGFbNl0gKiB5O1xuICBvdXRbN10gPSBhWzddICogeTtcbiAgb3V0WzhdID0gYVs4XSAqIHo7XG4gIG91dFs5XSA9IGFbOV0gKiB6O1xuICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcbiAgdmFyIGIwMCwgYjAxLCBiMDI7XG4gIHZhciBiMTAsIGIxMSwgYjEyO1xuICB2YXIgYjIwLCBiMjEsIGIyMjtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7XG4gIGEwMCA9IGFbMF07XG4gIGEwMSA9IGFbMV07XG4gIGEwMiA9IGFbMl07XG4gIGEwMyA9IGFbM107XG4gIGExMCA9IGFbNF07XG4gIGExMSA9IGFbNV07XG4gIGExMiA9IGFbNl07XG4gIGExMyA9IGFbN107XG4gIGEyMCA9IGFbOF07XG4gIGEyMSA9IGFbOV07XG4gIGEyMiA9IGFbMTBdO1xuICBhMjMgPSBhWzExXTsgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG5cbiAgYjAwID0geCAqIHggKiB0ICsgYztcbiAgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBiMTAgPSB4ICogeSAqIHQgLSB6ICogcztcbiAgYjExID0geSAqIHkgKiB0ICsgYztcbiAgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIGIyMCA9IHggKiB6ICogdCArIHkgKiBzO1xuICBiMjEgPSB5ICogeiAqIHQgLSB4ICogcztcbiAgYjIyID0geiAqIHogKiB0ICsgYzsgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBhMTAgPSBhWzRdO1xuICB2YXIgYTExID0gYVs1XTtcbiAgdmFyIGExMiA9IGFbNl07XG4gIHZhciBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XTtcbiAgdmFyIGEyMSA9IGFbOV07XG4gIHZhciBhMjIgPSBhWzEwXTtcbiAgdmFyIGEyMyA9IGFbMTFdO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH0gLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG5cbiAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjICsgYTIyICogcztcbiAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XG4gIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICBvdXRbOV0gPSBhMjEgKiBjIC0gYTExICogcztcbiAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xuICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYTAwID0gYVswXTtcbiAgdmFyIGEwMSA9IGFbMV07XG4gIHZhciBhMDIgPSBhWzJdO1xuICB2YXIgYTAzID0gYVszXTtcbiAgdmFyIGEyMCA9IGFbOF07XG4gIHZhciBhMjEgPSBhWzldO1xuICB2YXIgYTIyID0gYVsxMF07XG4gIHZhciBhMjMgPSBhWzExXTtcblxuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuXG4gIG91dFswXSA9IGEwMCAqIGMgLSBhMjAgKiBzO1xuICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gIG91dFszXSA9IGEwMyAqIGMgLSBhMjMgKiBzO1xuICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gIG91dFsxMF0gPSBhMDIgKiBzICsgYTIyICogYztcbiAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdO1xuICB2YXIgYTExID0gYVs1XTtcbiAgdmFyIGExMiA9IGFbNl07XG4gIHZhciBhMTMgPSBhWzddO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSB2WzFdO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gdlsyXTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGF4aXNcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkLCBheGlzKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVhSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IGM7XG4gIG91dFs2XSA9IHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IC1zO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5yb3RhdGVZKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tWVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHM7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21aUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtcztcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgcSwgdikge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICBvdXRbMV0gPSB4eSArIHd6O1xuICBvdXRbMl0gPSB4eiAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4eSAtIHd6O1xuICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICBvdXRbNl0gPSB5eiArIHd4O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4eiArIHd5O1xuICBvdXRbOV0gPSB5eiAtIHd4O1xuICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBmcm9tIGEgZHVhbCBxdWF0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBNYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIER1YWwgUXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7bWF0NH0gbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUXVhdDIob3V0LCBhKSB7XG4gIHZhciB0cmFuc2xhdGlvbiA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddO1xuICB2YXIgbWFnbml0dWRlID0gYnggKiBieCArIGJ5ICogYnkgKyBieiAqIGJ6ICsgYncgKiBidzsgLy9Pbmx5IHNjYWxlIGlmIGl0IG1ha2VzIHNlbnNlXG5cbiAgaWYgKG1hZ25pdHVkZSA+IDApIHtcbiAgICB0cmFuc2xhdGlvblswXSA9IChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5KSAqIDIgLyBtYWduaXR1ZGU7XG4gICAgdHJhbnNsYXRpb25bMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyIC8gbWFnbml0dWRlO1xuICAgIHRyYW5zbGF0aW9uWzJdID0gKGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngpICogMiAvIG1hZ25pdHVkZTtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2xhdGlvblswXSA9IChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5KSAqIDI7XG4gICAgdHJhbnNsYXRpb25bMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyO1xuICAgIHRyYW5zbGF0aW9uWzJdID0gKGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngpICogMjtcbiAgfVxuXG4gIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgYSwgdHJhbnNsYXRpb24pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxyXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLFxyXG4gKiAgdGhlIHJldHVybmVkIHZlY3RvciB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3JcclxuICogIG9yaWdpbmFsbHkgc3VwcGxpZWQuXHJcbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSB0cmFuc2xhdGlvbiBjb21wb25lbnRcclxuICogQHBhcmFtICB7UmVhZG9ubHlNYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxyXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24ob3V0LCBtYXQpIHtcbiAgb3V0WzBdID0gbWF0WzEyXTtcbiAgb3V0WzFdID0gbWF0WzEzXTtcbiAgb3V0WzJdID0gbWF0WzE0XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxyXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVcclxuICogIHdpdGggYSBub3JtYWxpemVkIFF1YXRlcm5pb24gcGFyYW10ZXIsIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZVxyXG4gKiAgdGhlIHNhbWUgYXMgdGhlIHNjYWxpbmcgdmVjdG9yXHJcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFNjYWxpbmcob3V0LCBtYXQpIHtcbiAgdmFyIG0xMSA9IG1hdFswXTtcbiAgdmFyIG0xMiA9IG1hdFsxXTtcbiAgdmFyIG0xMyA9IG1hdFsyXTtcbiAgdmFyIG0yMSA9IG1hdFs0XTtcbiAgdmFyIG0yMiA9IG1hdFs1XTtcbiAgdmFyIG0yMyA9IG1hdFs2XTtcbiAgdmFyIG0zMSA9IG1hdFs4XTtcbiAgdmFyIG0zMiA9IG1hdFs5XTtcbiAgdmFyIG0zMyA9IG1hdFsxMF07XG4gIG91dFswXSA9IE1hdGguaHlwb3QobTExLCBtMTIsIG0xMyk7XG4gIG91dFsxXSA9IE1hdGguaHlwb3QobTIxLCBtMjIsIG0yMyk7XG4gIG91dFsyXSA9IE1hdGguaHlwb3QobTMxLCBtMzIsIG0zMyk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSByb3RhdGlvbmFsIGNvbXBvbmVudFxyXG4gKiAgb2YgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGhcclxuICogIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLCB0aGUgcmV0dXJuZWQgcXVhdGVybmlvbiB3aWxsIGJlIHRoZVxyXG4gKiAgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBRdWF0ZXJuaW9uIHRvIHJlY2VpdmUgdGhlIHJvdGF0aW9uIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFJvdGF0aW9uKG91dCwgbWF0KSB7XG4gIHZhciBzY2FsaW5nID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIGdldFNjYWxpbmcoc2NhbGluZywgbWF0KTtcbiAgdmFyIGlzMSA9IDEgLyBzY2FsaW5nWzBdO1xuICB2YXIgaXMyID0gMSAvIHNjYWxpbmdbMV07XG4gIHZhciBpczMgPSAxIC8gc2NhbGluZ1syXTtcbiAgdmFyIHNtMTEgPSBtYXRbMF0gKiBpczE7XG4gIHZhciBzbTEyID0gbWF0WzFdICogaXMyO1xuICB2YXIgc20xMyA9IG1hdFsyXSAqIGlzMztcbiAgdmFyIHNtMjEgPSBtYXRbNF0gKiBpczE7XG4gIHZhciBzbTIyID0gbWF0WzVdICogaXMyO1xuICB2YXIgc20yMyA9IG1hdFs2XSAqIGlzMztcbiAgdmFyIHNtMzEgPSBtYXRbOF0gKiBpczE7XG4gIHZhciBzbTMyID0gbWF0WzldICogaXMyO1xuICB2YXIgc20zMyA9IG1hdFsxMF0gKiBpczM7XG4gIHZhciB0cmFjZSA9IHNtMTEgKyBzbTIyICsgc20zMztcbiAgdmFyIFMgPSAwO1xuXG4gIGlmICh0cmFjZSA+IDApIHtcbiAgICBTID0gTWF0aC5zcXJ0KHRyYWNlICsgMS4wKSAqIDI7XG4gICAgb3V0WzNdID0gMC4yNSAqIFM7XG4gICAgb3V0WzBdID0gKHNtMjMgLSBzbTMyKSAvIFM7XG4gICAgb3V0WzFdID0gKHNtMzEgLSBzbTEzKSAvIFM7XG4gICAgb3V0WzJdID0gKHNtMTIgLSBzbTIxKSAvIFM7XG4gIH0gZWxzZSBpZiAoc20xMSA+IHNtMjIgJiYgc20xMSA+IHNtMzMpIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIHNtMTEgLSBzbTIyIC0gc20zMykgKiAyO1xuICAgIG91dFszXSA9IChzbTIzIC0gc20zMikgLyBTO1xuICAgIG91dFswXSA9IDAuMjUgKiBTO1xuICAgIG91dFsxXSA9IChzbTEyICsgc20yMSkgLyBTO1xuICAgIG91dFsyXSA9IChzbTMxICsgc20xMykgLyBTO1xuICB9IGVsc2UgaWYgKHNtMjIgPiBzbTMzKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTIyIC0gc20xMSAtIHNtMzMpICogMjtcbiAgICBvdXRbM10gPSAoc20zMSAtIHNtMTMpIC8gUztcbiAgICBvdXRbMF0gPSAoc20xMiArIHNtMjEpIC8gUztcbiAgICBvdXRbMV0gPSAwLjI1ICogUztcbiAgICBvdXRbMl0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgfSBlbHNlIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIHNtMzMgLSBzbTExIC0gc20yMikgKiAyO1xuICAgIG91dFszXSA9IChzbTEyIC0gc20yMSkgLyBTO1xuICAgIG91dFswXSA9IChzbTMxICsgc20xMykgLyBTO1xuICAgIG91dFsxXSA9IChzbTIzICsgc20zMikgLyBTO1xuICAgIG91dFsyXSA9IDAuMjUgKiBTO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZVxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xyXG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xyXG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcyBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUob3V0LCBxLCB2LCBzKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIHZhciBzeCA9IHNbMF07XG4gIHZhciBzeSA9IHNbMV07XG4gIHZhciBzeiA9IHNbMl07XG4gIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBvcmlnaW4pO1xyXG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xyXG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBuZWdhdGl2ZU9yaWdpbik7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcyBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gbyBUaGUgb3JpZ2luIHZlY3RvciBhcm91bmQgd2hpY2ggdG8gc2NhbGUgYW5kIHJvdGF0ZVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4ob3V0LCBxLCB2LCBzLCBvKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIHZhciBzeCA9IHNbMF07XG4gIHZhciBzeSA9IHNbMV07XG4gIHZhciBzeiA9IHNbMl07XG4gIHZhciBveCA9IG9bMF07XG4gIHZhciBveSA9IG9bMV07XG4gIHZhciBveiA9IG9bMl07XG4gIHZhciBvdXQwID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIHZhciBvdXQxID0gKHh5ICsgd3opICogc3g7XG4gIHZhciBvdXQyID0gKHh6IC0gd3kpICogc3g7XG4gIHZhciBvdXQ0ID0gKHh5IC0gd3opICogc3k7XG4gIHZhciBvdXQ1ID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIHZhciBvdXQ2ID0gKHl6ICsgd3gpICogc3k7XG4gIHZhciBvdXQ4ID0gKHh6ICsgd3kpICogc3o7XG4gIHZhciBvdXQ5ID0gKHl6IC0gd3gpICogc3o7XG4gIHZhciBvdXQxMCA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMF0gPSBvdXQwO1xuICBvdXRbMV0gPSBvdXQxO1xuICBvdXRbMl0gPSBvdXQyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSBvdXQ0O1xuICBvdXRbNV0gPSBvdXQ1O1xuICBvdXRbNl0gPSBvdXQ2O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSBvdXQ4O1xuICBvdXRbOV0gPSBvdXQ5O1xuICBvdXRbMTBdID0gb3V0MTA7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXSArIG94IC0gKG91dDAgKiBveCArIG91dDQgKiBveSArIG91dDggKiBveik7XG4gIG91dFsxM10gPSB2WzFdICsgb3kgLSAob3V0MSAqIG94ICsgb3V0NSAqIG95ICsgb3V0OSAqIG96KTtcbiAgb3V0WzE0XSA9IHZbMl0gKyBveiAtIChvdXQyICogb3ggKyBvdXQ2ICogb3kgKyBvdXQxMCAqIG96KTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBhIDR4NCBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXHJcbiAqXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeXggPSB5ICogeDI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHp4ID0geiAqIHgyO1xuICB2YXIgenkgPSB6ICogeTI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gIG91dFsxXSA9IHl4ICsgd3o7XG4gIG91dFsyXSA9IHp4IC0gd3k7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHl4IC0gd3o7XG4gIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICBvdXRbNl0gPSB6eSArIHd4O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6eCArIHd5O1xuICBvdXRbOV0gPSB6eSAtIHd4O1xuICBvdXRbMTBdID0gMSAtIHh4IC0geXk7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJ1c3R1bShvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KTtcbiAgdmFyIHRiID0gMSAvICh0b3AgLSBib3R0b20pO1xuICB2YXIgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSBuZWFyICogMiAqIHJsO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBuZWFyICogMiAqIHRiO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAqIDIgKiBuZjtcbiAgb3V0WzE1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzLlxyXG4gKiBQYXNzaW5nIG51bGwvdW5kZWZpbmVkL25vIHZhbHVlIGZvciBmYXIgd2lsbCBnZW5lcmF0ZSBpbmZpbml0ZSBwcm9qZWN0aW9uIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcclxuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bSwgY2FuIGJlIG51bGwgb3IgSW5maW5pdHlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBwZXJzcGVjdGl2ZShvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgbmY7XG4gIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IGY7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTVdID0gMDtcblxuICBpZiAoZmFyICE9IG51bGwgJiYgZmFyICE9PSBJbmZpbml0eSkge1xuICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzE0XSA9IDIgKiBmYXIgKiBuZWFyICogbmY7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzEwXSA9IC0xO1xuICAgIG91dFsxNF0gPSAtMiAqIG5lYXI7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGZpZWxkIG9mIHZpZXcuXHJcbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBwcm9qZWN0aW9uIG1hdHJpY2VzIHRvIGJlIHVzZWRcclxuICogd2l0aCB0aGUgc3RpbGwgZXhwZXJpZW1lbnRhbCBXZWJWUiBBUEkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtPYmplY3R9IGZvdiBPYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHZhbHVlczogdXBEZWdyZWVzLCBkb3duRGVncmVlcywgbGVmdERlZ3JlZXMsIHJpZ2h0RGVncmVlc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcob3V0LCBmb3YsIG5lYXIsIGZhcikge1xuICB2YXIgdXBUYW4gPSBNYXRoLnRhbihmb3YudXBEZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIGRvd25UYW4gPSBNYXRoLnRhbihmb3YuZG93bkRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgbGVmdFRhbiA9IE1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciByaWdodFRhbiA9IE1hdGgudGFuKGZvdi5yaWdodERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgeFNjYWxlID0gMi4wIC8gKGxlZnRUYW4gKyByaWdodFRhbik7XG4gIHZhciB5U2NhbGUgPSAyLjAgLyAodXBUYW4gKyBkb3duVGFuKTtcbiAgb3V0WzBdID0geFNjYWxlO1xuICBvdXRbMV0gPSAwLjA7XG4gIG91dFsyXSA9IDAuMDtcbiAgb3V0WzNdID0gMC4wO1xuICBvdXRbNF0gPSAwLjA7XG4gIG91dFs1XSA9IHlTY2FsZTtcbiAgb3V0WzZdID0gMC4wO1xuICBvdXRbN10gPSAwLjA7XG4gIG91dFs4XSA9IC0oKGxlZnRUYW4gLSByaWdodFRhbikgKiB4U2NhbGUgKiAwLjUpO1xuICBvdXRbOV0gPSAodXBUYW4gLSBkb3duVGFuKSAqIHlTY2FsZSAqIDAuNTtcbiAgb3V0WzEwXSA9IGZhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzExXSA9IC0xLjA7XG4gIG91dFsxMl0gPSAwLjA7XG4gIG91dFsxM10gPSAwLjA7XG4gIG91dFsxNF0gPSBmYXIgKiBuZWFyIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMTVdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG9ydGhvKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpO1xuICB2YXIgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7XG4gIHZhciBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IC0yICogbHI7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IC0yICogYnQ7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAyICogbmY7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXMuXHJcbiAqIElmIHlvdSB3YW50IGEgbWF0cml4IHRoYXQgYWN0dWFsbHkgbWFrZXMgYW4gb2JqZWN0IGxvb2sgYXQgYW5vdGhlciBvYmplY3QsIHlvdSBzaG91bGQgdXNlIHRhcmdldFRvIGluc3RlYWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbG9va0F0KG91dCwgZXllLCBjZW50ZXIsIHVwKSB7XG4gIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW47XG4gIHZhciBleWV4ID0gZXllWzBdO1xuICB2YXIgZXlleSA9IGV5ZVsxXTtcbiAgdmFyIGV5ZXogPSBleWVbMl07XG4gIHZhciB1cHggPSB1cFswXTtcbiAgdmFyIHVweSA9IHVwWzFdO1xuICB2YXIgdXB6ID0gdXBbMl07XG4gIHZhciBjZW50ZXJ4ID0gY2VudGVyWzBdO1xuICB2YXIgY2VudGVyeSA9IGNlbnRlclsxXTtcbiAgdmFyIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IGdsTWF0cml4LkVQU0lMT04gJiYgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5KG91dCk7XG4gIH1cblxuICB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xuICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xuICBsZW4gPSAxIC8gTWF0aC5oeXBvdCh6MCwgejEsIHoyKTtcbiAgejAgKj0gbGVuO1xuICB6MSAqPSBsZW47XG4gIHoyICo9IGxlbjtcbiAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgbGVuID0gTWF0aC5oeXBvdCh4MCwgeDEsIHgyKTtcblxuICBpZiAoIWxlbikge1xuICAgIHgwID0gMDtcbiAgICB4MSA9IDA7XG4gICAgeDIgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeDAgKj0gbGVuO1xuICAgIHgxICo9IGxlbjtcbiAgICB4MiAqPSBsZW47XG4gIH1cblxuICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuICBsZW4gPSBNYXRoLmh5cG90KHkwLCB5MSwgeTIpO1xuXG4gIGlmICghbGVuKSB7XG4gICAgeTAgPSAwO1xuICAgIHkxID0gMDtcbiAgICB5MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB5MCAqPSBsZW47XG4gICAgeTEgKj0gbGVuO1xuICAgIHkyICo9IGxlbjtcbiAgfVxuXG4gIG91dFswXSA9IHgwO1xuICBvdXRbMV0gPSB5MDtcbiAgb3V0WzJdID0gejA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHgxO1xuICBvdXRbNV0gPSB5MTtcbiAgb3V0WzZdID0gejE7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHgyO1xuICBvdXRbOV0gPSB5MjtcbiAgb3V0WzEwXSA9IHoyO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgbWF0cml4IHRoYXQgbWFrZXMgc29tZXRoaW5nIGxvb2sgYXQgc29tZXRoaW5nIGVsc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdGFyZ2V0VG8ob3V0LCBleWUsIHRhcmdldCwgdXApIHtcbiAgdmFyIGV5ZXggPSBleWVbMF0sXG4gICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICB1cHogPSB1cFsyXTtcbiAgdmFyIHowID0gZXlleCAtIHRhcmdldFswXSxcbiAgICAgIHoxID0gZXlleSAtIHRhcmdldFsxXSxcbiAgICAgIHoyID0gZXlleiAtIHRhcmdldFsyXTtcbiAgdmFyIGxlbiA9IHowICogejAgKyB6MSAqIHoxICsgejIgKiB6MjtcblxuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcbiAgfVxuXG4gIHZhciB4MCA9IHVweSAqIHoyIC0gdXB6ICogejEsXG4gICAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejIsXG4gICAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gIGxlbiA9IHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4MjtcblxuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuXG4gIG91dFswXSA9IHgwO1xuICBvdXRbMV0gPSB4MTtcbiAgb3V0WzJdID0geDI7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHoxICogeDIgLSB6MiAqIHgxO1xuICBvdXRbNV0gPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgb3V0WzZdID0gejAgKiB4MSAtIHoxICogeDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHowO1xuICBvdXRbOV0gPSB6MTtcbiAgb3V0WzEwXSA9IHoyO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IGV5ZXg7XG4gIG91dFsxM10gPSBleWV5O1xuICBvdXRbMTRdID0gZXllejtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJtYXQ0KFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIiwgXCIgKyBhWzhdICsgXCIsIFwiICsgYVs5XSArIFwiLCBcIiArIGFbMTBdICsgXCIsIFwiICsgYVsxMV0gKyBcIiwgXCIgKyBhWzEyXSArIFwiLCBcIiArIGFbMTNdICsgXCIsIFwiICsgYVsxNF0gKyBcIiwgXCIgKyBhWzE1XSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdLCBhWzZdLCBhWzddLCBhWzhdLCBhWzldLCBhWzEwXSwgYVsxMV0sIGFbMTJdLCBhWzEzXSwgYVsxNF0sIGFbMTVdKTtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQ0J3NcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdO1xuICBvdXRbOV0gPSBhWzldICsgYls5XTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF07XG4gIG91dFsxMV0gPSBhWzExXSArIGJbMTFdO1xuICBvdXRbMTJdID0gYVsxMl0gKyBiWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM107XG4gIG91dFsxNF0gPSBhWzE0XSArIGJbMTRdO1xuICBvdXRbMTVdID0gYVsxNV0gKyBiWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgb3V0WzldID0gYVs5XSAtIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSAtIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gLSBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdIC0gYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSAtIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gLSBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdIC0gYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgb3V0WzRdID0gYVs0XSAqIGI7XG4gIG91dFs1XSA9IGFbNV0gKiBiO1xuICBvdXRbNl0gPSBhWzZdICogYjtcbiAgb3V0WzddID0gYVs3XSAqIGI7XG4gIG91dFs4XSA9IGFbOF0gKiBiO1xuICBvdXRbOV0gPSBhWzldICogYjtcbiAgb3V0WzEwXSA9IGFbMTBdICogYjtcbiAgb3V0WzExXSA9IGFbMTFdICogYjtcbiAgb3V0WzEyXSA9IGFbMTJdICogYjtcbiAgb3V0WzEzXSA9IGFbMTNdICogYjtcbiAgb3V0WzE0XSA9IGFbMTRdICogYjtcbiAgb3V0WzE1XSA9IGFbMTVdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQ0J3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XSAqIHNjYWxlO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XSAqIHNjYWxlO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XSAqIHNjYWxlO1xuICBvdXRbN10gPSBhWzddICsgYls3XSAqIHNjYWxlO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XSAqIHNjYWxlO1xuICBvdXRbOV0gPSBhWzldICsgYls5XSAqIHNjYWxlO1xuICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXSAqIHNjYWxlO1xuICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXSAqIHNjYWxlO1xuICBvdXRbMTJdID0gYVsxMl0gKyBiWzEyXSAqIHNjYWxlO1xuICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXSAqIHNjYWxlO1xuICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XSAqIHNjYWxlO1xuICBvdXRbMTVdID0gYVsxNV0gKyBiWzE1XSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF0gJiYgYVs5XSA9PT0gYls5XSAmJiBhWzEwXSA9PT0gYlsxMF0gJiYgYVsxMV0gPT09IGJbMTFdICYmIGFbMTJdID09PSBiWzEyXSAmJiBhWzEzXSA9PT0gYlsxM10gJiYgYVsxNF0gPT09IGJbMTRdICYmIGFbMTVdID09PSBiWzE1XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV0sXG4gICAgICBhNiA9IGFbNl0sXG4gICAgICBhNyA9IGFbN107XG4gIHZhciBhOCA9IGFbOF0sXG4gICAgICBhOSA9IGFbOV0sXG4gICAgICBhMTAgPSBhWzEwXSxcbiAgICAgIGExMSA9IGFbMTFdO1xuICB2YXIgYTEyID0gYVsxMl0sXG4gICAgICBhMTMgPSBhWzEzXSxcbiAgICAgIGExNCA9IGFbMTRdLFxuICAgICAgYTE1ID0gYVsxNV07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM107XG4gIHZhciBiNCA9IGJbNF0sXG4gICAgICBiNSA9IGJbNV0sXG4gICAgICBiNiA9IGJbNl0sXG4gICAgICBiNyA9IGJbN107XG4gIHZhciBiOCA9IGJbOF0sXG4gICAgICBiOSA9IGJbOV0sXG4gICAgICBiMTAgPSBiWzEwXSxcbiAgICAgIGIxMSA9IGJbMTFdO1xuICB2YXIgYjEyID0gYlsxMl0sXG4gICAgICBiMTMgPSBiWzEzXSxcbiAgICAgIGIxNCA9IGJbMTRdLFxuICAgICAgYjE1ID0gYlsxNV07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiYgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJiBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiYgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmIE1hdGguYWJzKGE4IC0gYjgpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE4KSwgTWF0aC5hYnMoYjgpKSAmJiBNYXRoLmFicyhhOSAtIGI5KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOSksIE1hdGguYWJzKGI5KSkgJiYgTWF0aC5hYnMoYTEwIC0gYjEwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTApLCBNYXRoLmFicyhiMTApKSAmJiBNYXRoLmFicyhhMTEgLSBiMTEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMSksIE1hdGguYWJzKGIxMSkpICYmIE1hdGguYWJzKGExMiAtIGIxMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEyKSwgTWF0aC5hYnMoYjEyKSkgJiYgTWF0aC5hYnMoYTEzIC0gYjEzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTMpLCBNYXRoLmFicyhiMTMpKSAmJiBNYXRoLmFicyhhMTQgLSBiMTQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNCksIE1hdGguYWJzKGIxNCkpICYmIE1hdGguYWJzKGExNSAtIGIxNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE1KSwgTWF0aC5hYnMoYjE1KSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0Lm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLm11bCA9IG11bDtcbnZhciBzdWIgPSBzdWJ0cmFjdDtcbmV4cG9ydHMuc3ViID0gc3ViOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMuc2V0QXhpc0FuZ2xlID0gc2V0QXhpc0FuZ2xlO1xuZXhwb3J0cy5nZXRBeGlzQW5nbGUgPSBnZXRBeGlzQW5nbGU7XG5leHBvcnRzLmdldEFuZ2xlID0gZ2V0QW5nbGU7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLnJvdGF0ZVggPSByb3RhdGVYO1xuZXhwb3J0cy5yb3RhdGVZID0gcm90YXRlWTtcbmV4cG9ydHMucm90YXRlWiA9IHJvdGF0ZVo7XG5leHBvcnRzLmNhbGN1bGF0ZVcgPSBjYWxjdWxhdGVXO1xuZXhwb3J0cy5leHAgPSBleHA7XG5leHBvcnRzLmxuID0gbG47XG5leHBvcnRzLnBvdyA9IHBvdztcbmV4cG9ydHMuc2xlcnAgPSBzbGVycDtcbmV4cG9ydHMucmFuZG9tID0gcmFuZG9tO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLmNvbmp1Z2F0ZSA9IGNvbmp1Z2F0ZTtcbmV4cG9ydHMuZnJvbU1hdDMgPSBmcm9tTWF0MztcbmV4cG9ydHMuZnJvbUV1bGVyID0gZnJvbUV1bGVyO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLnNldEF4ZXMgPSBleHBvcnRzLnNxbGVycCA9IGV4cG9ydHMucm90YXRpb25UbyA9IGV4cG9ydHMuZXF1YWxzID0gZXhwb3J0cy5leGFjdEVxdWFscyA9IGV4cG9ydHMubm9ybWFsaXplID0gZXhwb3J0cy5zcXJMZW4gPSBleHBvcnRzLnNxdWFyZWRMZW5ndGggPSBleHBvcnRzLmxlbiA9IGV4cG9ydHMubGVuZ3RoID0gZXhwb3J0cy5sZXJwID0gZXhwb3J0cy5kb3QgPSBleHBvcnRzLnNjYWxlID0gZXhwb3J0cy5tdWwgPSBleHBvcnRzLmFkZCA9IGV4cG9ydHMuc2V0ID0gZXhwb3J0cy5jb3B5ID0gZXhwb3J0cy5mcm9tVmFsdWVzID0gZXhwb3J0cy5jbG9uZSA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxudmFyIG1hdDMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9tYXQzLmpzXCIpKTtcblxudmFyIHZlYzMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi92ZWMzLmpzXCIpKTtcblxudmFyIHZlYzQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi92ZWM0LmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLyoqXHJcbiAqIFF1YXRlcm5pb25cclxuICogQG1vZHVsZSBxdWF0XHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBxdWF0XHJcbiAqXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gIH1cblxuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCBhIHF1YXQgdG8gdGhlIGlkZW50aXR5IHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsXHJcbiAqIHRoZW4gcmV0dXJucyBpdC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBheGlzIHRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqKi9cblxuXG5mdW5jdGlvbiBzZXRBeGlzQW5nbGUob3V0LCBheGlzLCByYWQpIHtcbiAgcmFkID0gcmFkICogMC41O1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIG91dFswXSA9IHMgKiBheGlzWzBdO1xuICBvdXRbMV0gPSBzICogYXhpc1sxXTtcbiAgb3V0WzJdID0gcyAqIGF4aXNbMl07XG4gIG91dFszXSA9IE1hdGguY29zKHJhZCk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2V0cyB0aGUgcm90YXRpb24gYXhpcyBhbmQgYW5nbGUgZm9yIGEgZ2l2ZW5cclxuICogIHF1YXRlcm5pb24uIElmIGEgcXVhdGVybmlvbiBpcyBjcmVhdGVkIHdpdGhcclxuICogIHNldEF4aXNBbmdsZSwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIHNhbWVcclxuICogIHZhbHVlcyBhcyBwcm92aWRpZWQgaW4gdGhlIG9yaWdpbmFsIHBhcmFtZXRlciBsaXN0XHJcbiAqICBPUiBmdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB2YWx1ZXMuXHJcbiAqIEV4YW1wbGU6IFRoZSBxdWF0ZXJuaW9uIGZvcm1lZCBieSBheGlzIFswLCAwLCAxXSBhbmRcclxuICogIGFuZ2xlIC05MCBpcyB0aGUgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBmb3JtZWQgYnlcclxuICogIFswLCAwLCAxXSBhbmQgMjcwLiBUaGlzIG1ldGhvZCBmYXZvcnMgdGhlIGxhdHRlci5cclxuICogQHBhcmFtICB7dmVjM30gb3V0X2F4aXMgIFZlY3RvciByZWNlaXZpbmcgdGhlIGF4aXMgb2Ygcm90YXRpb25cclxuICogQHBhcmFtICB7UmVhZG9ubHlRdWF0fSBxICAgICBRdWF0ZXJuaW9uIHRvIGJlIGRlY29tcG9zZWRcclxuICogQHJldHVybiB7TnVtYmVyfSAgICAgQW5nbGUsIGluIHJhZGlhbnMsIG9mIHRoZSByb3RhdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRBeGlzQW5nbGUob3V0X2F4aXMsIHEpIHtcbiAgdmFyIHJhZCA9IE1hdGguYWNvcyhxWzNdKSAqIDIuMDtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQgLyAyLjApO1xuXG4gIGlmIChzID4gZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIG91dF9heGlzWzBdID0gcVswXSAvIHM7XG4gICAgb3V0X2F4aXNbMV0gPSBxWzFdIC8gcztcbiAgICBvdXRfYXhpc1syXSA9IHFbMl0gLyBzO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHMgaXMgemVybywgcmV0dXJuIGFueSBheGlzIChubyByb3RhdGlvbiAtIGF4aXMgZG9lcyBub3QgbWF0dGVyKVxuICAgIG91dF9heGlzWzBdID0gMTtcbiAgICBvdXRfYXhpc1sxXSA9IDA7XG4gICAgb3V0X2F4aXNbMl0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJhZDtcbn1cbi8qKlxyXG4gKiBHZXRzIHRoZSBhbmd1bGFyIGRpc3RhbmNlIGJldHdlZW4gdHdvIHVuaXQgcXVhdGVybmlvbnNcclxuICpcclxuICogQHBhcmFtICB7UmVhZG9ubHlRdWF0fSBhICAgICBPcmlnaW4gdW5pdCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5UXVhdH0gYiAgICAgRGVzdGluYXRpb24gdW5pdCBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm4ge051bWJlcn0gICAgIEFuZ2xlLCBpbiByYWRpYW5zLCBiZXR3ZWVuIHRoZSB0d28gcXVhdGVybmlvbnNcclxuICovXG5cblxuZnVuY3Rpb24gZ2V0QW5nbGUoYSwgYikge1xuICB2YXIgZG90cHJvZHVjdCA9IGRvdChhLCBiKTtcbiAgcmV0dXJuIE1hdGguYWNvcygyICogZG90cHJvZHVjdCAqIGRvdHByb2R1Y3QgLSAxKTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICB2YXIgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdLFxuICAgICAgYncgPSBiWzNdO1xuICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICByYWQgKj0gMC41O1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICB2YXIgYnggPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYncgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieDtcbiAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gIG91dFsyXSA9IGF6ICogYncgLSBheSAqIGJ4O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgdmFyIGJ5ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGJ3ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXggKiBieTtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gIHJhZCAqPSAwLjU7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieiA9IE1hdGguc2luKHJhZCksXG4gICAgICBidyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGF4ICogYncgKyBheSAqIGJ6O1xuICBvdXRbMV0gPSBheSAqIGJ3IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYno7XG4gIG91dFszXSA9IGF3ICogYncgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIFcgY29tcG9uZW50IG9mIGEgcXVhdCBmcm9tIHRoZSBYLCBZLCBhbmQgWiBjb21wb25lbnRzLlxyXG4gKiBBc3N1bWVzIHRoYXQgcXVhdGVybmlvbiBpcyAxIHVuaXQgaW4gbGVuZ3RoLlxyXG4gKiBBbnkgZXhpc3RpbmcgVyBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgVyBjb21wb25lbnQgb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjYWxjdWxhdGVXKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSBNYXRoLnNxcnQoTWF0aC5hYnMoMS4wIC0geCAqIHggLSB5ICogeSAtIHogKiB6KSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBleHBvbmVudGlhbCBvZiBhIHVuaXQgcXVhdGVybmlvbi5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIHRoZSBleHBvbmVudGlhbCBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4cChvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXSxcbiAgICAgIHcgPSBhWzNdO1xuICB2YXIgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICB2YXIgZXQgPSBNYXRoLmV4cCh3KTtcbiAgdmFyIHMgPSByID4gMCA/IGV0ICogTWF0aC5zaW4ocikgLyByIDogMDtcbiAgb3V0WzBdID0geCAqIHM7XG4gIG91dFsxXSA9IHkgKiBzO1xuICBvdXRbMl0gPSB6ICogcztcbiAgb3V0WzNdID0gZXQgKiBNYXRoLmNvcyhyKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIGEgdW5pdCBxdWF0ZXJuaW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgdGhlIGV4cG9uZW50aWFsIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbG4ob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl0sXG4gICAgICB3ID0gYVszXTtcbiAgdmFyIHIgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgdmFyIHQgPSByID4gMCA/IE1hdGguYXRhbjIociwgdykgLyByIDogMDtcbiAgb3V0WzBdID0geCAqIHQ7XG4gIG91dFsxXSA9IHkgKiB0O1xuICBvdXRbMl0gPSB6ICogdDtcbiAgb3V0WzNdID0gMC41ICogTWF0aC5sb2coeCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHcpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgc2NhbGFyIHBvd2VyIG9mIGEgdW5pdCBxdWF0ZXJuaW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgdGhlIGV4cG9uZW50aWFsIG9mXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgcXVhdGVybmlvbiBieVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHBvdyhvdXQsIGEsIGIpIHtcbiAgbG4ob3V0LCBhKTtcbiAgc2NhbGUob3V0LCBvdXQsIGIpO1xuICBleHAob3V0LCBvdXQpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2xlcnAob3V0LCBhLCBiLCB0KSB7XG4gIC8vIGJlbmNobWFya3M6XG4gIC8vICAgIGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tc2xlcnAtaW1wbGVtZW50YXRpb25zXG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl0sXG4gICAgICBidyA9IGJbM107XG4gIHZhciBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTsgLy8gY2FsYyBjb3NpbmVcblxuICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7IC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxuXG4gIGlmIChjb3NvbSA8IDAuMCkge1xuICAgIGNvc29tID0gLWNvc29tO1xuICAgIGJ4ID0gLWJ4O1xuICAgIGJ5ID0gLWJ5O1xuICAgIGJ6ID0gLWJ6O1xuICAgIGJ3ID0gLWJ3O1xuICB9IC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHNcblxuXG4gIGlmICgxLjAgLSBjb3NvbSA+IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICBvbWVnYSA9IE1hdGguYWNvcyhjb3NvbSk7XG4gICAgc2lub20gPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICB9IGVsc2Uge1xuICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgcXVhdGVybmlvbnMgYXJlIHZlcnkgY2xvc2VcbiAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgc2NhbGUwID0gMS4wIC0gdDtcbiAgICBzY2FsZTEgPSB0O1xuICB9IC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcblxuXG4gIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHVuaXQgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByYW5kb20ob3V0KSB7XG4gIC8vIEltcGxlbWVudGF0aW9uIG9mIGh0dHA6Ly9wbGFubmluZy5jcy51aXVjLmVkdS9ub2RlMTk4Lmh0bWxcbiAgLy8gVE9ETzogQ2FsbGluZyByYW5kb20gMyB0aW1lcyBpcyBwcm9iYWJseSBub3QgdGhlIGZhc3Rlc3Qgc29sdXRpb25cbiAgdmFyIHUxID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIHZhciB1MiA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICB2YXIgdTMgPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgdmFyIHNxcnQxTWludXNVMSA9IE1hdGguc3FydCgxIC0gdTEpO1xuICB2YXIgc3FydFUxID0gTWF0aC5zcXJ0KHUxKTtcbiAgb3V0WzBdID0gc3FydDFNaW51c1UxICogTWF0aC5zaW4oMi4wICogTWF0aC5QSSAqIHUyKTtcbiAgb3V0WzFdID0gc3FydDFNaW51c1UxICogTWF0aC5jb3MoMi4wICogTWF0aC5QSSAqIHUyKTtcbiAgb3V0WzJdID0gc3FydFUxICogTWF0aC5zaW4oMi4wICogTWF0aC5QSSAqIHUzKTtcbiAgb3V0WzNdID0gc3FydFUxICogTWF0aC5jb3MoMi4wICogTWF0aC5QSSAqIHUzKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgaW52ZXJzZSBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGRvdCA9IGEwICogYTAgKyBhMSAqIGExICsgYTIgKiBhMiArIGEzICogYTM7XG4gIHZhciBpbnZEb3QgPSBkb3QgPyAxLjAgLyBkb3QgOiAwOyAvLyBUT0RPOiBXb3VsZCBiZSBmYXN0ZXIgdG8gcmV0dXJuIFswLDAsMCwwXSBpbW1lZGlhdGVseSBpZiBkb3QgPT0gMFxuXG4gIG91dFswXSA9IC1hMCAqIGludkRvdDtcbiAgb3V0WzFdID0gLWExICogaW52RG90O1xuICBvdXRbMl0gPSAtYTIgKiBpbnZEb3Q7XG4gIG91dFszXSA9IGEzICogaW52RG90O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIHF1YXRcclxuICogSWYgdGhlIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0LmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGNvbmp1Z2F0ZSBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbmp1Z2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxyXG4gKlxyXG4gKiBOT1RFOiBUaGUgcmVzdWx0YW50IHF1YXRlcm5pb24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIHlvdSBzaG91bGQgYmUgc3VyZVxyXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSByb3RhdGlvbiBtYXRyaXhcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gZnJvbU1hdDMob3V0LCBtKSB7XG4gIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXG4gIC8vIGFydGljbGUgXCJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvblwiLlxuICB2YXIgZlRyYWNlID0gbVswXSArIG1bNF0gKyBtWzhdO1xuICB2YXIgZlJvb3Q7XG5cbiAgaWYgKGZUcmFjZSA+IDAuMCkge1xuICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzJcbiAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAvLyAyd1xuXG4gICAgb3V0WzNdID0gMC41ICogZlJvb3Q7XG4gICAgZlJvb3QgPSAwLjUgLyBmUm9vdDsgLy8gMS8oNHcpXG5cbiAgICBvdXRbMF0gPSAobVs1XSAtIG1bN10pICogZlJvb3Q7XG4gICAgb3V0WzFdID0gKG1bNl0gLSBtWzJdKSAqIGZSb290O1xuICAgIG91dFsyXSA9IChtWzFdIC0gbVszXSkgKiBmUm9vdDtcbiAgfSBlbHNlIHtcbiAgICAvLyB8d3wgPD0gMS8yXG4gICAgdmFyIGkgPSAwO1xuICAgIGlmIChtWzRdID4gbVswXSkgaSA9IDE7XG4gICAgaWYgKG1bOF0gPiBtW2kgKiAzICsgaV0pIGkgPSAyO1xuICAgIHZhciBqID0gKGkgKyAxKSAlIDM7XG4gICAgdmFyIGsgPSAoaSArIDIpICUgMztcbiAgICBmUm9vdCA9IE1hdGguc3FydChtW2kgKiAzICsgaV0gLSBtW2ogKiAzICsgal0gLSBtW2sgKiAzICsga10gKyAxLjApO1xuICAgIG91dFtpXSA9IDAuNSAqIGZSb290O1xuICAgIGZSb290ID0gMC41IC8gZlJvb3Q7XG4gICAgb3V0WzNdID0gKG1baiAqIDMgKyBrXSAtIG1bayAqIDMgKyBqXSkgKiBmUm9vdDtcbiAgICBvdXRbal0gPSAobVtqICogMyArIGldICsgbVtpICogMyArIGpdKSAqIGZSb290O1xuICAgIG91dFtrXSA9IChtW2sgKiAzICsgaV0gKyBtW2kgKiAzICsga10pICogZlJvb3Q7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIGV1bGVyIGFuZ2xlIHgsIHksIHouXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3h9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWCBheGlzIGluIGRlZ3JlZXMuXHJcbiAqIEBwYXJhbSB7eX0gQW5nbGUgdG8gcm90YXRlIGFyb3VuZCBZIGF4aXMgaW4gZGVncmVlcy5cclxuICogQHBhcmFtIHt6fSBBbmdsZSB0byByb3RhdGUgYXJvdW5kIFogYXhpcyBpbiBkZWdyZWVzLlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tRXVsZXIob3V0LCB4LCB5LCB6KSB7XG4gIHZhciBoYWxmVG9SYWQgPSAwLjUgKiBNYXRoLlBJIC8gMTgwLjA7XG4gIHggKj0gaGFsZlRvUmFkO1xuICB5ICo9IGhhbGZUb1JhZDtcbiAgeiAqPSBoYWxmVG9SYWQ7XG4gIHZhciBzeCA9IE1hdGguc2luKHgpO1xuICB2YXIgY3ggPSBNYXRoLmNvcyh4KTtcbiAgdmFyIHN5ID0gTWF0aC5zaW4oeSk7XG4gIHZhciBjeSA9IE1hdGguY29zKHkpO1xuICB2YXIgc3ogPSBNYXRoLnNpbih6KTtcbiAgdmFyIGN6ID0gTWF0aC5jb3Moeik7XG4gIG91dFswXSA9IHN4ICogY3kgKiBjeiAtIGN4ICogc3kgKiBzejtcbiAgb3V0WzFdID0gY3ggKiBzeSAqIGN6ICsgc3ggKiBjeSAqIHN6O1xuICBvdXRbMl0gPSBjeCAqIGN5ICogc3ogLSBzeCAqIHN5ICogY3o7XG4gIG91dFszXSA9IGN4ICogY3kgKiBjeiArIHN4ICogc3kgKiBzejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcXVhdGVuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcclxuICovXG5cblxuZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwicXVhdChcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXRlcm5pb24gdG8gY2xvbmVcclxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbnZhciBjbG9uZSA9IHZlYzQuY2xvbmU7XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbnZhciBmcm9tVmFsdWVzID0gdmVjNC5mcm9tVmFsdWVzO1xuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBxdWF0IHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5mcm9tVmFsdWVzID0gZnJvbVZhbHVlcztcbnZhciBjb3B5ID0gdmVjNC5jb3B5O1xuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuY29weSA9IGNvcHk7XG52YXIgc2V0ID0gdmVjNC5zZXQ7XG4vKipcclxuICogQWRkcyB0d28gcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc2V0ID0gc2V0O1xudmFyIGFkZCA9IHZlYzQuYWRkO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmFkZCA9IGFkZDtcbnZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBTY2FsZXMgYSBxdWF0IGJ5IGEgc2NhbGFyIG51bWJlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLm11bCA9IG11bDtcbnZhciBzY2FsZSA9IHZlYzQuc2NhbGU7XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbnZhciBkb3QgPSB2ZWM0LmRvdDtcbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuZG90ID0gZG90O1xudmFyIGxlcnAgPSB2ZWM0LmxlcnA7XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0cy5sZXJwID0gbGVycDtcbnZhciBsZW5ndGggPSB2ZWM0Lmxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoO1xudmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5sZW4gPSBsZW47XG52YXIgc3F1YXJlZExlbmd0aCA9IHZlYzQuc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQuc3F1YXJlZExlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNxdWFyZWRMZW5ndGggPSBzcXVhcmVkTGVuZ3RoO1xudmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogTm9ybWFsaXplIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdGVybmlvbiB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3FyTGVuID0gc3FyTGVuO1xudmFyIG5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplO1xuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgVGhlIGZpcnN0IHF1YXRlcm5pb24uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIFRoZSBzZWNvbmQgcXVhdGVybmlvbi5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbnZhciBleGFjdEVxdWFscyA9IHZlYzQuZXhhY3RFcXVhbHM7XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcXVhdGVybmlvbnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnRzLmV4YWN0RXF1YWxzID0gZXhhY3RFcXVhbHM7XG52YXIgZXF1YWxzID0gdmVjNC5lcXVhbHM7XG4vKipcclxuICogU2V0cyBhIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IHRoZSBzaG9ydGVzdCByb3RhdGlvbiBmcm9tIG9uZVxyXG4gKiB2ZWN0b3IgdG8gYW5vdGhlci5cclxuICpcclxuICogQm90aCB2ZWN0b3JzIGFyZSBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb24uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBpbml0aWFsIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgZGVzdGluYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuXG52YXIgcm90YXRpb25UbyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRtcHZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICB2YXIgeFVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDEsIDAsIDApO1xuICB2YXIgeVVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApO1xuICByZXR1cm4gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBkb3QgPSB2ZWMzLmRvdChhLCBiKTtcblxuICAgIGlmIChkb3QgPCAtMC45OTk5OTkpIHtcbiAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeFVuaXRWZWMzLCBhKTtcbiAgICAgIGlmICh2ZWMzLmxlbih0bXB2ZWMzKSA8IDAuMDAwMDAxKSB2ZWMzLmNyb3NzKHRtcHZlYzMsIHlVbml0VmVjMywgYSk7XG4gICAgICB2ZWMzLm5vcm1hbGl6ZSh0bXB2ZWMzLCB0bXB2ZWMzKTtcbiAgICAgIHNldEF4aXNBbmdsZShvdXQsIHRtcHZlYzMsIE1hdGguUEkpO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2UgaWYgKGRvdCA+IDAuOTk5OTk5KSB7XG4gICAgICBvdXRbMF0gPSAwO1xuICAgICAgb3V0WzFdID0gMDtcbiAgICAgIG91dFsyXSA9IDA7XG4gICAgICBvdXRbM10gPSAxO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCBhLCBiKTtcbiAgICAgIG91dFswXSA9IHRtcHZlYzNbMF07XG4gICAgICBvdXRbMV0gPSB0bXB2ZWMzWzFdO1xuICAgICAgb3V0WzJdID0gdG1wdmVjM1syXTtcbiAgICAgIG91dFszXSA9IDEgKyBkb3Q7XG4gICAgICByZXR1cm4gbm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICB9XG4gIH07XG59KCk7XG4vKipcclxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYyB0aGUgdGhpcmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gZCB0aGUgZm91cnRoIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmV4cG9ydHMucm90YXRpb25UbyA9IHJvdGF0aW9uVG87XG5cbnZhciBzcWxlcnAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZW1wMSA9IGNyZWF0ZSgpO1xuICB2YXIgdGVtcDIgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgICBzbGVycCh0ZW1wMSwgYSwgZCwgdCk7XG4gICAgc2xlcnAodGVtcDIsIGIsIGMsIHQpO1xuICAgIHNsZXJwKG91dCwgdGVtcDEsIHRlbXAyLCAyICogdCAqICgxIC0gdCkpO1xuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KCk7XG4vKipcclxuICogU2V0cyB0aGUgc3BlY2lmaWVkIHF1YXRlcm5pb24gd2l0aCB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW5cclxuICogYXhlcy4gRWFjaCBheGlzIGlzIGEgdmVjMyBhbmQgaXMgZXhwZWN0ZWQgdG8gYmUgdW5pdCBsZW5ndGggYW5kXHJcbiAqIHBlcnBlbmRpY3VsYXIgdG8gYWxsIG90aGVyIHNwZWNpZmllZCBheGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdmlldyAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSByaWdodCB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJyaWdodFwiIGRpcmVjdGlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdXAgICAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwidXBcIiBkaXJlY3Rpb25cclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5leHBvcnRzLnNxbGVycCA9IHNxbGVycDtcblxudmFyIHNldEF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtYXRyID0gbWF0My5jcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIHZpZXcsIHJpZ2h0LCB1cCkge1xuICAgIG1hdHJbMF0gPSByaWdodFswXTtcbiAgICBtYXRyWzNdID0gcmlnaHRbMV07XG4gICAgbWF0cls2XSA9IHJpZ2h0WzJdO1xuICAgIG1hdHJbMV0gPSB1cFswXTtcbiAgICBtYXRyWzRdID0gdXBbMV07XG4gICAgbWF0cls3XSA9IHVwWzJdO1xuICAgIG1hdHJbMl0gPSAtdmlld1swXTtcbiAgICBtYXRyWzVdID0gLXZpZXdbMV07XG4gICAgbWF0cls4XSA9IC12aWV3WzJdO1xuICAgIHJldHVybiBub3JtYWxpemUob3V0LCBmcm9tTWF0MyhvdXQsIG1hdHIpKTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5zZXRBeGVzID0gc2V0QXhlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5mcm9tUm90YXRpb25UcmFuc2xhdGlvblZhbHVlcyA9IGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uVmFsdWVzO1xuZXhwb3J0cy5mcm9tUm90YXRpb25UcmFuc2xhdGlvbiA9IGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uO1xuZXhwb3J0cy5mcm9tVHJhbnNsYXRpb24gPSBmcm9tVHJhbnNsYXRpb247XG5leHBvcnRzLmZyb21Sb3RhdGlvbiA9IGZyb21Sb3RhdGlvbjtcbmV4cG9ydHMuZnJvbU1hdDQgPSBmcm9tTWF0NDtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuZ2V0RHVhbCA9IGdldER1YWw7XG5leHBvcnRzLnNldER1YWwgPSBzZXREdWFsO1xuZXhwb3J0cy5nZXRUcmFuc2xhdGlvbiA9IGdldFRyYW5zbGF0aW9uO1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnJvdGF0ZVggPSByb3RhdGVYO1xuZXhwb3J0cy5yb3RhdGVZID0gcm90YXRlWTtcbmV4cG9ydHMucm90YXRlWiA9IHJvdGF0ZVo7XG5leHBvcnRzLnJvdGF0ZUJ5UXVhdEFwcGVuZCA9IHJvdGF0ZUJ5UXVhdEFwcGVuZDtcbmV4cG9ydHMucm90YXRlQnlRdWF0UHJlcGVuZCA9IHJvdGF0ZUJ5UXVhdFByZXBlbmQ7XG5leHBvcnRzLnJvdGF0ZUFyb3VuZEF4aXMgPSByb3RhdGVBcm91bmRBeGlzO1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLmxlcnAgPSBsZXJwO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLmNvbmp1Z2F0ZSA9IGNvbmp1Z2F0ZTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLmV4YWN0RXF1YWxzID0gZXhhY3RFcXVhbHM7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcbmV4cG9ydHMuc3FyTGVuID0gZXhwb3J0cy5zcXVhcmVkTGVuZ3RoID0gZXhwb3J0cy5sZW4gPSBleHBvcnRzLmxlbmd0aCA9IGV4cG9ydHMuZG90ID0gZXhwb3J0cy5tdWwgPSBleHBvcnRzLnNldFJlYWwgPSBleHBvcnRzLmdldFJlYWwgPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbnZhciBxdWF0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vcXVhdC5qc1wiKSk7XG5cbnZhciBtYXQ0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWF0NC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKlxyXG4gKiBEdWFsIFF1YXRlcm5pb248YnI+XHJcbiAqIEZvcm1hdDogW3JlYWwsIGR1YWxdPGJyPlxyXG4gKiBRdWF0ZXJuaW9uIGZvcm1hdDogWFlaVzxicj5cclxuICogTWFrZSBzdXJlIHRvIGhhdmUgbm9ybWFsaXplZCBkdWFsIHF1YXRlcm5pb25zLCBvdGhlcndpc2UgdGhlIGZ1bmN0aW9ucyBtYXkgbm90IHdvcmsgYXMgaW50ZW5kZWQuPGJyPlxyXG4gKiBAbW9kdWxlIHF1YXQyXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBkdWFsIHF1YXRcclxuICpcclxuICogQHJldHVybnMge3F1YXQyfSBhIG5ldyBkdWFsIHF1YXRlcm5pb24gW3JlYWwgLT4gcm90YXRpb24sIGR1YWwgLT4gdHJhbnNsYXRpb25dXHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgZHEgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg4KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBkcVswXSA9IDA7XG4gICAgZHFbMV0gPSAwO1xuICAgIGRxWzJdID0gMDtcbiAgICBkcVs0XSA9IDA7XG4gICAgZHFbNV0gPSAwO1xuICAgIGRxWzZdID0gMDtcbiAgICBkcVs3XSA9IDA7XG4gIH1cblxuICBkcVszXSA9IDE7XG4gIHJldHVybiBkcTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBkdWFsIHF1YXRlcm5pb24gdG8gY2xvbmVcclxuICogQHJldHVybnMge3F1YXQyfSBuZXcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBkcSA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDgpO1xuICBkcVswXSA9IGFbMF07XG4gIGRxWzFdID0gYVsxXTtcbiAgZHFbMl0gPSBhWzJdO1xuICBkcVszXSA9IGFbM107XG4gIGRxWzRdID0gYVs0XTtcbiAgZHFbNV0gPSBhWzVdO1xuICBkcVs2XSA9IGFbNl07XG4gIGRxWzddID0gYVs3XTtcbiAgcmV0dXJuIGRxO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgZHVhbCBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geDEgWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkxIFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MSBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdzEgVyBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgyIFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MiBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gejIgWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcyIFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gbmV3IGR1YWwgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyh4MSwgeTEsIHoxLCB3MSwgeDIsIHkyLCB6MiwgdzIpIHtcbiAgdmFyIGRxID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOCk7XG4gIGRxWzBdID0geDE7XG4gIGRxWzFdID0geTE7XG4gIGRxWzJdID0gejE7XG4gIGRxWzNdID0gdzE7XG4gIGRxWzRdID0geDI7XG4gIGRxWzVdID0geTI7XG4gIGRxWzZdID0gejI7XG4gIGRxWzddID0gdzI7XG4gIHJldHVybiBkcTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGR1YWwgcXVhdCBmcm9tIHRoZSBnaXZlbiB2YWx1ZXMgKHF1YXQgYW5kIHRyYW5zbGF0aW9uKVxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geDEgWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkxIFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MSBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdzEgVyBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgyIFggY29tcG9uZW50ICh0cmFuc2xhdGlvbilcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkyIFkgY29tcG9uZW50ICh0cmFuc2xhdGlvbilcclxuICogQHBhcmFtIHtOdW1iZXJ9IHoyIFogY29tcG9uZW50ICh0cmFuc2xhdGlvbilcclxuICogQHJldHVybnMge3F1YXQyfSBuZXcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvblZhbHVlcyh4MSwgeTEsIHoxLCB3MSwgeDIsIHkyLCB6Mikge1xuICB2YXIgZHEgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg4KTtcbiAgZHFbMF0gPSB4MTtcbiAgZHFbMV0gPSB5MTtcbiAgZHFbMl0gPSB6MTtcbiAgZHFbM10gPSB3MTtcbiAgdmFyIGF4ID0geDIgKiAwLjUsXG4gICAgICBheSA9IHkyICogMC41LFxuICAgICAgYXogPSB6MiAqIDAuNTtcbiAgZHFbNF0gPSBheCAqIHcxICsgYXkgKiB6MSAtIGF6ICogeTE7XG4gIGRxWzVdID0gYXkgKiB3MSArIGF6ICogeDEgLSBheCAqIHoxO1xuICBkcVs2XSA9IGF6ICogdzEgKyBheCAqIHkxIC0gYXkgKiB4MTtcbiAgZHFbN10gPSAtYXggKiB4MSAtIGF5ICogeTEgLSBheiAqIHoxO1xuICByZXR1cm4gZHE7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIGR1YWwgcXVhdCBmcm9tIGEgcXVhdGVybmlvbiBhbmQgYSB0cmFuc2xhdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBhIG5vcm1hbGl6ZWQgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdCB0cmFubGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB0KSB7XG4gIHZhciBheCA9IHRbMF0gKiAwLjUsXG4gICAgICBheSA9IHRbMV0gKiAwLjUsXG4gICAgICBheiA9IHRbMl0gKiAwLjUsXG4gICAgICBieCA9IHFbMF0sXG4gICAgICBieSA9IHFbMV0sXG4gICAgICBieiA9IHFbMl0sXG4gICAgICBidyA9IHFbM107XG4gIG91dFswXSA9IGJ4O1xuICBvdXRbMV0gPSBieTtcbiAgb3V0WzJdID0gYno7XG4gIG91dFszXSA9IGJ3O1xuICBvdXRbNF0gPSBheCAqIGJ3ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFs1XSA9IGF5ICogYncgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzZdID0gYXogKiBidyArIGF4ICogYnkgLSBheSAqIGJ4O1xuICBvdXRbN10gPSAtYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkdWFsIHF1YXQgZnJvbSBhIHRyYW5zbGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB0IHRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdCkge1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSB0WzBdICogMC41O1xuICBvdXRbNV0gPSB0WzFdICogMC41O1xuICBvdXRbNl0gPSB0WzJdICogMC41O1xuICBvdXRbN10gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkdWFsIHF1YXQgZnJvbSBhIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgdGhlIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHEpIHtcbiAgb3V0WzBdID0gcVswXTtcbiAgb3V0WzFdID0gcVsxXTtcbiAgb3V0WzJdID0gcVsyXTtcbiAgb3V0WzNdID0gcVszXTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGR1YWwgcXVhdCBmcm9tIGEgbWF0cml4ICg0eDQpXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXhcclxuICogQHJldHVybnMge3F1YXQyfSBkdWFsIHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21NYXQ0KG91dCwgYSkge1xuICAvL1RPRE8gT3B0aW1pemUgdGhpc1xuICB2YXIgb3V0ZXIgPSBxdWF0LmNyZWF0ZSgpO1xuICBtYXQ0LmdldFJvdGF0aW9uKG91dGVyLCBhKTtcbiAgdmFyIHQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgbWF0NC5nZXRUcmFuc2xhdGlvbih0LCBhKTtcbiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBvdXRlciwgdCk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIGR1YWwgcXVhdCB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIHNvdXJjZSBkdWFsIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgZHVhbCBxdWF0IHRvIHRoZSBpZGVudGl0eSBkdWFsIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBkdWFsIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MSBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geTEgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHoxIFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3MSBXIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geDIgWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkyIFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MiBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdzIgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIHgxLCB5MSwgejEsIHcxLCB4MiwgeTIsIHoyLCB3Mikge1xuICBvdXRbMF0gPSB4MTtcbiAgb3V0WzFdID0geTE7XG4gIG91dFsyXSA9IHoxO1xuICBvdXRbM10gPSB3MTtcbiAgb3V0WzRdID0geDI7XG4gIG91dFs1XSA9IHkyO1xuICBvdXRbNl0gPSB6MjtcbiAgb3V0WzddID0gdzI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2V0cyB0aGUgcmVhbCBwYXJ0IG9mIGEgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSAge3F1YXR9IG91dCByZWFsIHBhcnRcclxuICogQHBhcmFtICB7UmVhZG9ubHlRdWF0Mn0gYSBEdWFsIFF1YXRlcm5pb25cclxuICogQHJldHVybiB7cXVhdH0gcmVhbCBwYXJ0XHJcbiAqL1xuXG5cbnZhciBnZXRSZWFsID0gcXVhdC5jb3B5O1xuLyoqXHJcbiAqIEdldHMgdGhlIGR1YWwgcGFydCBvZiBhIGR1YWwgcXVhdFxyXG4gKiBAcGFyYW0gIHtxdWF0fSBvdXQgZHVhbCBwYXJ0XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5UXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm4ge3F1YXR9IGR1YWwgcGFydFxyXG4gKi9cblxuZXhwb3J0cy5nZXRSZWFsID0gZ2V0UmVhbDtcblxuZnVuY3Rpb24gZ2V0RHVhbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVs0XTtcbiAgb3V0WzFdID0gYVs1XTtcbiAgb3V0WzJdID0gYVs2XTtcbiAgb3V0WzNdID0gYVs3XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIHJlYWwgY29tcG9uZW50IG9mIGEgZHVhbCBxdWF0IHRvIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcmVhbCBwYXJ0XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgc2V0UmVhbCA9IHF1YXQuY29weTtcbi8qKlxyXG4gKiBTZXQgdGhlIGR1YWwgY29tcG9uZW50IG9mIGEgZHVhbCBxdWF0IHRvIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgZHVhbCBwYXJ0XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zZXRSZWFsID0gc2V0UmVhbDtcblxuZnVuY3Rpb24gc2V0RHVhbChvdXQsIHEpIHtcbiAgb3V0WzRdID0gcVswXTtcbiAgb3V0WzVdID0gcVsxXTtcbiAgb3V0WzZdID0gcVsyXTtcbiAgb3V0WzddID0gcVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXRzIHRoZSB0cmFuc2xhdGlvbiBvZiBhIG5vcm1hbGl6ZWQgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSAge3ZlYzN9IG91dCB0cmFuc2xhdGlvblxyXG4gKiBAcGFyYW0gIHtSZWFkb25seVF1YXQyfSBhIER1YWwgUXVhdGVybmlvbiB0byBiZSBkZWNvbXBvc2VkXHJcbiAqIEByZXR1cm4ge3ZlYzN9IHRyYW5zbGF0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG91dCwgYSkge1xuICB2YXIgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdO1xuICBvdXRbMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyO1xuICBvdXRbMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyO1xuICBvdXRbMl0gPSAoYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCkgKiAyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zbGF0ZXMgYSBkdWFsIHF1YXQgYnkgdGhlIGdpdmVuIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICB2YXIgYXgxID0gYVswXSxcbiAgICAgIGF5MSA9IGFbMV0sXG4gICAgICBhejEgPSBhWzJdLFxuICAgICAgYXcxID0gYVszXSxcbiAgICAgIGJ4MSA9IHZbMF0gKiAwLjUsXG4gICAgICBieTEgPSB2WzFdICogMC41LFxuICAgICAgYnoxID0gdlsyXSAqIDAuNSxcbiAgICAgIGF4MiA9IGFbNF0sXG4gICAgICBheTIgPSBhWzVdLFxuICAgICAgYXoyID0gYVs2XSxcbiAgICAgIGF3MiA9IGFbN107XG4gIG91dFswXSA9IGF4MTtcbiAgb3V0WzFdID0gYXkxO1xuICBvdXRbMl0gPSBhejE7XG4gIG91dFszXSA9IGF3MTtcbiAgb3V0WzRdID0gYXcxICogYngxICsgYXkxICogYnoxIC0gYXoxICogYnkxICsgYXgyO1xuICBvdXRbNV0gPSBhdzEgKiBieTEgKyBhejEgKiBieDEgLSBheDEgKiBiejEgKyBheTI7XG4gIG91dFs2XSA9IGF3MSAqIGJ6MSArIGF4MSAqIGJ5MSAtIGF5MSAqIGJ4MSArIGF6MjtcbiAgb3V0WzddID0gLWF4MSAqIGJ4MSAtIGF5MSAqIGJ5MSAtIGF6MSAqIGJ6MSArIGF3MjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGFyb3VuZCB0aGUgWCBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBob3cgZmFyIHNob3VsZCB0aGUgcm90YXRpb24gYmVcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYXgxID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSxcbiAgICAgIGF5MSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnosXG4gICAgICBhejEgPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LFxuICAgICAgYXcxID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcXVhdC5yb3RhdGVYKG91dCwgYSwgcmFkKTtcbiAgYnggPSBvdXRbMF07XG4gIGJ5ID0gb3V0WzFdO1xuICBieiA9IG91dFsyXTtcbiAgYncgPSBvdXRbM107XG4gIG91dFs0XSA9IGF4MSAqIGJ3ICsgYXcxICogYnggKyBheTEgKiBieiAtIGF6MSAqIGJ5O1xuICBvdXRbNV0gPSBheTEgKiBidyArIGF3MSAqIGJ5ICsgYXoxICogYnggLSBheDEgKiBiejtcbiAgb3V0WzZdID0gYXoxICogYncgKyBhdzEgKiBieiArIGF4MSAqIGJ5IC0gYXkxICogYng7XG4gIG91dFs3XSA9IGF3MSAqIGJ3IC0gYXgxICogYnggLSBheTEgKiBieSAtIGF6MSAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYXJvdW5kIHRoZSBZIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGhvdyBmYXIgc2hvdWxkIHRoZSByb3RhdGlvbiBiZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIHZhciBieCA9IC1hWzBdLFxuICAgICAgYnkgPSAtYVsxXSxcbiAgICAgIGJ6ID0gLWFbMl0sXG4gICAgICBidyA9IGFbM10sXG4gICAgICBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN10sXG4gICAgICBheDEgPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5LFxuICAgICAgYXkxID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieixcbiAgICAgIGF6MSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngsXG4gICAgICBhdzEgPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICBxdWF0LnJvdGF0ZVkob3V0LCBhLCByYWQpO1xuICBieCA9IG91dFswXTtcbiAgYnkgPSBvdXRbMV07XG4gIGJ6ID0gb3V0WzJdO1xuICBidyA9IG91dFszXTtcbiAgb3V0WzRdID0gYXgxICogYncgKyBhdzEgKiBieCArIGF5MSAqIGJ6IC0gYXoxICogYnk7XG4gIG91dFs1XSA9IGF5MSAqIGJ3ICsgYXcxICogYnkgKyBhejEgKiBieCAtIGF4MSAqIGJ6O1xuICBvdXRbNl0gPSBhejEgKiBidyArIGF3MSAqIGJ6ICsgYXgxICogYnkgLSBheTEgKiBieDtcbiAgb3V0WzddID0gYXcxICogYncgLSBheDEgKiBieCAtIGF5MSAqIGJ5IC0gYXoxICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBhcm91bmQgdGhlIFogYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgaG93IGZhciBzaG91bGQgdGhlIHJvdGF0aW9uIGJlXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgdmFyIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXSxcbiAgICAgIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XSxcbiAgICAgIGF4MSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnksXG4gICAgICBheTEgPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6LFxuICAgICAgYXoxID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCxcbiAgICAgIGF3MSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHF1YXQucm90YXRlWihvdXQsIGEsIHJhZCk7XG4gIGJ4ID0gb3V0WzBdO1xuICBieSA9IG91dFsxXTtcbiAgYnogPSBvdXRbMl07XG4gIGJ3ID0gb3V0WzNdO1xuICBvdXRbNF0gPSBheDEgKiBidyArIGF3MSAqIGJ4ICsgYXkxICogYnogLSBhejEgKiBieTtcbiAgb3V0WzVdID0gYXkxICogYncgKyBhdzEgKiBieSArIGF6MSAqIGJ4IC0gYXgxICogYno7XG4gIG91dFs2XSA9IGF6MSAqIGJ3ICsgYXcxICogYnogKyBheDEgKiBieSAtIGF5MSAqIGJ4O1xuICBvdXRbN10gPSBhdzEgKiBidyAtIGF4MSAqIGJ4IC0gYXkxICogYnkgLSBhejEgKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGJ5IGEgZ2l2ZW4gcXVhdGVybmlvbiAoYSAqIHEpXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byByb3RhdGUgYnlcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlQnlRdWF0QXBwZW5kKG91dCwgYSwgcSkge1xuICB2YXIgcXggPSBxWzBdLFxuICAgICAgcXkgPSBxWzFdLFxuICAgICAgcXogPSBxWzJdLFxuICAgICAgcXcgPSBxWzNdLFxuICAgICAgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICBvdXRbMF0gPSBheCAqIHF3ICsgYXcgKiBxeCArIGF5ICogcXogLSBheiAqIHF5O1xuICBvdXRbMV0gPSBheSAqIHF3ICsgYXcgKiBxeSArIGF6ICogcXggLSBheCAqIHF6O1xuICBvdXRbMl0gPSBheiAqIHF3ICsgYXcgKiBxeiArIGF4ICogcXkgLSBheSAqIHF4O1xuICBvdXRbM10gPSBhdyAqIHF3IC0gYXggKiBxeCAtIGF5ICogcXkgLSBheiAqIHF6O1xuICBheCA9IGFbNF07XG4gIGF5ID0gYVs1XTtcbiAgYXogPSBhWzZdO1xuICBhdyA9IGFbN107XG4gIG91dFs0XSA9IGF4ICogcXcgKyBhdyAqIHF4ICsgYXkgKiBxeiAtIGF6ICogcXk7XG4gIG91dFs1XSA9IGF5ICogcXcgKyBhdyAqIHF5ICsgYXogKiBxeCAtIGF4ICogcXo7XG4gIG91dFs2XSA9IGF6ICogcXcgKyBhdyAqIHF6ICsgYXggKiBxeSAtIGF5ICogcXg7XG4gIG91dFs3XSA9IGF3ICogcXcgLSBheCAqIHF4IC0gYXkgKiBxeSAtIGF6ICogcXo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBieSBhIGdpdmVuIHF1YXRlcm5pb24gKHEgKiBhKVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byByb3RhdGUgYnlcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZUJ5UXVhdFByZXBlbmQob3V0LCBxLCBhKSB7XG4gIHZhciBxeCA9IHFbMF0sXG4gICAgICBxeSA9IHFbMV0sXG4gICAgICBxeiA9IHFbMl0sXG4gICAgICBxdyA9IHFbM10sXG4gICAgICBieCA9IGFbMF0sXG4gICAgICBieSA9IGFbMV0sXG4gICAgICBieiA9IGFbMl0sXG4gICAgICBidyA9IGFbM107XG4gIG91dFswXSA9IHF4ICogYncgKyBxdyAqIGJ4ICsgcXkgKiBieiAtIHF6ICogYnk7XG4gIG91dFsxXSA9IHF5ICogYncgKyBxdyAqIGJ5ICsgcXogKiBieCAtIHF4ICogYno7XG4gIG91dFsyXSA9IHF6ICogYncgKyBxdyAqIGJ6ICsgcXggKiBieSAtIHF5ICogYng7XG4gIG91dFszXSA9IHF3ICogYncgLSBxeCAqIGJ4IC0gcXkgKiBieSAtIHF6ICogYno7XG4gIGJ4ID0gYVs0XTtcbiAgYnkgPSBhWzVdO1xuICBieiA9IGFbNl07XG4gIGJ3ID0gYVs3XTtcbiAgb3V0WzRdID0gcXggKiBidyArIHF3ICogYnggKyBxeSAqIGJ6IC0gcXogKiBieTtcbiAgb3V0WzVdID0gcXkgKiBidyArIHF3ICogYnkgKyBxeiAqIGJ4IC0gcXggKiBiejtcbiAgb3V0WzZdID0gcXogKiBidyArIHF3ICogYnogKyBxeCAqIGJ5IC0gcXkgKiBieDtcbiAgb3V0WzddID0gcXcgKiBidyAtIHF4ICogYnggLSBxeSAqIGJ5IC0gcXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGFyb3VuZCBhIGdpdmVuIGF4aXMuIERvZXMgdGhlIG5vcm1hbGlzYXRpb24gYXV0b21hdGljYWxseVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBob3cgZmFyIHRoZSByb3RhdGlvbiBzaG91bGQgYmVcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlQXJvdW5kQXhpcyhvdXQsIGEsIGF4aXMsIHJhZCkge1xuICAvL1NwZWNpYWwgY2FzZSBmb3IgcmFkID0gMFxuICBpZiAoTWF0aC5hYnMocmFkKSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gY29weShvdXQsIGEpO1xuICB9XG5cbiAgdmFyIGF4aXNMZW5ndGggPSBNYXRoLmh5cG90KGF4aXNbMF0sIGF4aXNbMV0sIGF4aXNbMl0pO1xuICByYWQgPSByYWQgKiAwLjU7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGJ4ID0gcyAqIGF4aXNbMF0gLyBheGlzTGVuZ3RoO1xuICB2YXIgYnkgPSBzICogYXhpc1sxXSAvIGF4aXNMZW5ndGg7XG4gIHZhciBieiA9IHMgKiBheGlzWzJdIC8gYXhpc0xlbmd0aDtcbiAgdmFyIGJ3ID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGF4MSA9IGFbMF0sXG4gICAgICBheTEgPSBhWzFdLFxuICAgICAgYXoxID0gYVsyXSxcbiAgICAgIGF3MSA9IGFbM107XG4gIG91dFswXSA9IGF4MSAqIGJ3ICsgYXcxICogYnggKyBheTEgKiBieiAtIGF6MSAqIGJ5O1xuICBvdXRbMV0gPSBheTEgKiBidyArIGF3MSAqIGJ5ICsgYXoxICogYnggLSBheDEgKiBiejtcbiAgb3V0WzJdID0gYXoxICogYncgKyBhdzEgKiBieiArIGF4MSAqIGJ5IC0gYXkxICogYng7XG4gIG91dFszXSA9IGF3MSAqIGJ3IC0gYXgxICogYnggLSBheTEgKiBieSAtIGF6MSAqIGJ6O1xuICB2YXIgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddO1xuICBvdXRbNF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbNV0gPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbNl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICBvdXRbN10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIGR1YWwgcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gZHVhbCBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYXgwID0gYVswXSxcbiAgICAgIGF5MCA9IGFbMV0sXG4gICAgICBhejAgPSBhWzJdLFxuICAgICAgYXcwID0gYVszXSxcbiAgICAgIGJ4MSA9IGJbNF0sXG4gICAgICBieTEgPSBiWzVdLFxuICAgICAgYnoxID0gYls2XSxcbiAgICAgIGJ3MSA9IGJbN10sXG4gICAgICBheDEgPSBhWzRdLFxuICAgICAgYXkxID0gYVs1XSxcbiAgICAgIGF6MSA9IGFbNl0sXG4gICAgICBhdzEgPSBhWzddLFxuICAgICAgYngwID0gYlswXSxcbiAgICAgIGJ5MCA9IGJbMV0sXG4gICAgICBiejAgPSBiWzJdLFxuICAgICAgYncwID0gYlszXTtcbiAgb3V0WzBdID0gYXgwICogYncwICsgYXcwICogYngwICsgYXkwICogYnowIC0gYXowICogYnkwO1xuICBvdXRbMV0gPSBheTAgKiBidzAgKyBhdzAgKiBieTAgKyBhejAgKiBieDAgLSBheDAgKiBiejA7XG4gIG91dFsyXSA9IGF6MCAqIGJ3MCArIGF3MCAqIGJ6MCArIGF4MCAqIGJ5MCAtIGF5MCAqIGJ4MDtcbiAgb3V0WzNdID0gYXcwICogYncwIC0gYXgwICogYngwIC0gYXkwICogYnkwIC0gYXowICogYnowO1xuICBvdXRbNF0gPSBheDAgKiBidzEgKyBhdzAgKiBieDEgKyBheTAgKiBiejEgLSBhejAgKiBieTEgKyBheDEgKiBidzAgKyBhdzEgKiBieDAgKyBheTEgKiBiejAgLSBhejEgKiBieTA7XG4gIG91dFs1XSA9IGF5MCAqIGJ3MSArIGF3MCAqIGJ5MSArIGF6MCAqIGJ4MSAtIGF4MCAqIGJ6MSArIGF5MSAqIGJ3MCArIGF3MSAqIGJ5MCArIGF6MSAqIGJ4MCAtIGF4MSAqIGJ6MDtcbiAgb3V0WzZdID0gYXowICogYncxICsgYXcwICogYnoxICsgYXgwICogYnkxIC0gYXkwICogYngxICsgYXoxICogYncwICsgYXcxICogYnowICsgYXgxICogYnkwIC0gYXkxICogYngwO1xuICBvdXRbN10gPSBhdzAgKiBidzEgLSBheDAgKiBieDEgLSBheTAgKiBieTEgLSBhejAgKiBiejEgKyBhdzEgKiBidzAgLSBheDEgKiBieDAgLSBheTEgKiBieTAgLSBhejEgKiBiejA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Mi5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbnZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBTY2FsZXMgYSBkdWFsIHF1YXQgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdCB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIGR1YWwgcXVhdCBieVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubXVsID0gbXVsO1xuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgb3V0WzZdID0gYVs2XSAqIGI7XG4gIG91dFs3XSA9IGFbN10gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBkdWFsIHF1YXQncyAoVGhlIGRvdCBwcm9kdWN0IG9mIHRoZSByZWFsIHBhcnRzKVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgZG90ID0gcXVhdC5kb3Q7XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBkdWFsIHF1YXRzJ3NcclxuICogTk9URTogVGhlIHJlc3VsdGluZyBkdWFsIHF1YXRlcm5pb25zIHdvbid0IGFsd2F5cyBiZSBub3JtYWxpemVkIChUaGUgZXJyb3IgaXMgbW9zdCBub3RpY2VhYmxlIHdoZW4gdCA9IDAuNSlcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cbmV4cG9ydHMuZG90ID0gZG90O1xuXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgbXQgPSAxIC0gdDtcbiAgaWYgKGRvdChhLCBiKSA8IDApIHQgPSAtdDtcbiAgb3V0WzBdID0gYVswXSAqIG10ICsgYlswXSAqIHQ7XG4gIG91dFsxXSA9IGFbMV0gKiBtdCArIGJbMV0gKiB0O1xuICBvdXRbMl0gPSBhWzJdICogbXQgKyBiWzJdICogdDtcbiAgb3V0WzNdID0gYVszXSAqIG10ICsgYlszXSAqIHQ7XG4gIG91dFs0XSA9IGFbNF0gKiBtdCArIGJbNF0gKiB0O1xuICBvdXRbNV0gPSBhWzVdICogbXQgKyBiWzVdICogdDtcbiAgb3V0WzZdID0gYVs2XSAqIG10ICsgYls2XSAqIHQ7XG4gIG91dFs3XSA9IGFbN10gKiBtdCArIGJbN10gKiB0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBkdWFsIHF1YXQuIElmIHRoZXkgYXJlIG5vcm1hbGl6ZWQsIGNvbmp1Z2F0ZSBpcyBjaGVhcGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0IHRvIGNhbGN1bGF0ZSBpbnZlcnNlIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIHNxbGVuID0gc3F1YXJlZExlbmd0aChhKTtcbiAgb3V0WzBdID0gLWFbMF0gLyBzcWxlbjtcbiAgb3V0WzFdID0gLWFbMV0gLyBzcWxlbjtcbiAgb3V0WzJdID0gLWFbMl0gLyBzcWxlbjtcbiAgb3V0WzNdID0gYVszXSAvIHNxbGVuO1xuICBvdXRbNF0gPSAtYVs0XSAvIHNxbGVuO1xuICBvdXRbNV0gPSAtYVs1XSAvIHNxbGVuO1xuICBvdXRbNl0gPSAtYVs2XSAvIHNxbGVuO1xuICBvdXRbN10gPSBhWzddIC8gc3FsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgZHVhbCBxdWF0XHJcbiAqIElmIHRoZSBkdWFsIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0Mi5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHF1YXQgdG8gY2FsY3VsYXRlIGNvbmp1Z2F0ZSBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb25qdWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IC1hWzRdO1xuICBvdXRbNV0gPSAtYVs1XTtcbiAgb3V0WzZdID0gLWFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgZHVhbCBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBkdWFsIHF1YXQgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIGxlbmd0aCA9IHF1YXQubGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdDIubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoO1xudmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIGR1YWwgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0IHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5sZW4gPSBsZW47XG52YXIgc3F1YXJlZExlbmd0aCA9IHF1YXQuc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQyLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zcXVhcmVkTGVuZ3RoID0gc3F1YXJlZExlbmd0aDtcbnZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIGR1YWwgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIGR1YWwgcXVhdGVybmlvbiB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNxckxlbiA9IHNxckxlbjtcblxuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgbWFnbml0dWRlID0gc3F1YXJlZExlbmd0aChhKTtcblxuICBpZiAobWFnbml0dWRlID4gMCkge1xuICAgIG1hZ25pdHVkZSA9IE1hdGguc3FydChtYWduaXR1ZGUpO1xuICAgIHZhciBhMCA9IGFbMF0gLyBtYWduaXR1ZGU7XG4gICAgdmFyIGExID0gYVsxXSAvIG1hZ25pdHVkZTtcbiAgICB2YXIgYTIgPSBhWzJdIC8gbWFnbml0dWRlO1xuICAgIHZhciBhMyA9IGFbM10gLyBtYWduaXR1ZGU7XG4gICAgdmFyIGIwID0gYVs0XTtcbiAgICB2YXIgYjEgPSBhWzVdO1xuICAgIHZhciBiMiA9IGFbNl07XG4gICAgdmFyIGIzID0gYVs3XTtcbiAgICB2YXIgYV9kb3RfYiA9IGEwICogYjAgKyBhMSAqIGIxICsgYTIgKiBiMiArIGEzICogYjM7XG4gICAgb3V0WzBdID0gYTA7XG4gICAgb3V0WzFdID0gYTE7XG4gICAgb3V0WzJdID0gYTI7XG4gICAgb3V0WzNdID0gYTM7XG4gICAgb3V0WzRdID0gKGIwIC0gYTAgKiBhX2RvdF9iKSAvIG1hZ25pdHVkZTtcbiAgICBvdXRbNV0gPSAoYjEgLSBhMSAqIGFfZG90X2IpIC8gbWFnbml0dWRlO1xuICAgIG91dFs2XSA9IChiMiAtIGEyICogYV9kb3RfYikgLyBtYWduaXR1ZGU7XG4gICAgb3V0WzddID0gKGIzIC0gYTMgKiBhX2RvdF9iKSAvIG1hZ25pdHVkZTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGR1YWwgcXVhdGVuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBkdWFsIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZHVhbCBxdWF0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInF1YXQyKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBkdWFsIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBmaXJzdCBkdWFsIHF1YXRlcm5pb24uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYiB0aGUgc2Vjb25kIGR1YWwgcXVhdGVybmlvbi5cclxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGR1YWwgcXVhdGVybmlvbnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBkdWFsIHF1YXRlcm5pb25zIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBmaXJzdCBkdWFsIHF1YXQuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYiB0aGUgc2Vjb25kIGR1YWwgcXVhdC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGR1YWwgcXVhdHMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV0sXG4gICAgICBhNiA9IGFbNl0sXG4gICAgICBhNyA9IGFbN107XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM10sXG4gICAgICBiNCA9IGJbNF0sXG4gICAgICBiNSA9IGJbNV0sXG4gICAgICBiNiA9IGJbNl0sXG4gICAgICBiNyA9IGJbN107XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiYgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJiBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiYgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuZnJvbVZhbHVlcyA9IGZyb21WYWx1ZXM7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuc3VidHJhY3QgPSBzdWJ0cmFjdDtcbmV4cG9ydHMubXVsdGlwbHkgPSBtdWx0aXBseTtcbmV4cG9ydHMuZGl2aWRlID0gZGl2aWRlO1xuZXhwb3J0cy5jZWlsID0gY2VpbDtcbmV4cG9ydHMuZmxvb3IgPSBmbG9vcjtcbmV4cG9ydHMubWluID0gbWluO1xuZXhwb3J0cy5tYXggPSBtYXg7XG5leHBvcnRzLnJvdW5kID0gcm91bmQ7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLnNjYWxlQW5kQWRkID0gc2NhbGVBbmRBZGQ7XG5leHBvcnRzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5leHBvcnRzLnNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREaXN0YW5jZTtcbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoO1xuZXhwb3J0cy5zcXVhcmVkTGVuZ3RoID0gc3F1YXJlZExlbmd0aDtcbmV4cG9ydHMubmVnYXRlID0gbmVnYXRlO1xuZXhwb3J0cy5pbnZlcnNlID0gaW52ZXJzZTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5kb3QgPSBkb3Q7XG5leHBvcnRzLmNyb3NzID0gY3Jvc3M7XG5leHBvcnRzLmxlcnAgPSBsZXJwO1xuZXhwb3J0cy5yYW5kb20gPSByYW5kb207XG5leHBvcnRzLnRyYW5zZm9ybU1hdDIgPSB0cmFuc2Zvcm1NYXQyO1xuZXhwb3J0cy50cmFuc2Zvcm1NYXQyZCA9IHRyYW5zZm9ybU1hdDJkO1xuZXhwb3J0cy50cmFuc2Zvcm1NYXQzID0gdHJhbnNmb3JtTWF0MztcbmV4cG9ydHMudHJhbnNmb3JtTWF0NCA9IHRyYW5zZm9ybU1hdDQ7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMuYW5nbGUgPSBhbmdsZTtcbmV4cG9ydHMuemVybyA9IHplcm87XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuZXhhY3RFcXVhbHMgPSBleGFjdEVxdWFscztcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5mb3JFYWNoID0gZXhwb3J0cy5zcXJMZW4gPSBleHBvcnRzLnNxckRpc3QgPSBleHBvcnRzLmRpc3QgPSBleHBvcnRzLmRpdiA9IGV4cG9ydHMubXVsID0gZXhwb3J0cy5zdWIgPSBleHBvcnRzLmxlbiA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLyoqXHJcbiAqIDIgRGltZW5zaW9uYWwgVmVjdG9yXHJcbiAqIEBtb2R1bGUgdmVjMlxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcclxuICpcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHkpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBmbG9vclxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIHJvdW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuXG5mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICByZXR1cm4geCAqIHggKyB5ICogeTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG4vKipcclxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cblxuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59XG4vKipcclxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xyXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gIHZhciB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbiAgb3V0WzBdID0gb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQyZChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXHJcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxyXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xyXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlIGEgMkQgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IFRoZSByZWNlaXZpbmcgdmVjMlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgdmVjMiBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIGIsIHJhZCkge1xuICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIHZhciBwMCA9IGFbMF0gLSBiWzBdLFxuICAgICAgcDEgPSBhWzFdIC0gYlsxXSxcbiAgICAgIHNpbkMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgY29zQyA9IE1hdGguY29zKHJhZCk7IC8vcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSBwMCAqIGNvc0MgLSBwMSAqIHNpbkMgKyBiWzBdO1xuICBvdXRbMV0gPSBwMCAqIHNpbkMgKyBwMSAqIGNvc0MgKyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gMkQgdmVjdG9yc1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcclxuICovXG5cblxuZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgeDEgPSBhWzBdLFxuICAgICAgeTEgPSBhWzFdLFxuICAgICAgeDIgPSBiWzBdLFxuICAgICAgeTIgPSBiWzFdLFxuICAgICAgLy8gbWFnIGlzIHRoZSBwcm9kdWN0IG9mIHRoZSBtYWduaXR1ZGVzIG9mIGEgYW5kIGJcbiAgbWFnID0gTWF0aC5zcXJ0KHgxICogeDEgKyB5MSAqIHkxKSAqIE1hdGguc3FydCh4MiAqIHgyICsgeTIgKiB5MiksXG4gICAgICAvLyBtYWcgJiYuLiBzaG9ydCBjaXJjdWl0cyBpZiBtYWcgPT0gMFxuICBjb3NpbmUgPSBtYWcgJiYgKHgxICogeDIgKyB5MSAqIHkyKSAvIG1hZzsgLy8gTWF0aC5taW4oTWF0aC5tYXgoY29zaW5lLCAtMSksIDEpIGNsYW1wcyB0aGUgY29zaW5lIGJldHdlZW4gLTEgYW5kIDFcblxuICByZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSk7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB6ZXJvXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gemVybyhvdXQpIHtcbiAgb3V0WzBdID0gMC4wO1xuICBvdXRbMV0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzIoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5sZW4gPSBsZW47XG52YXIgc3ViID0gc3VidHJhY3Q7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3ViID0gc3ViO1xudmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5tdWwgPSBtdWw7XG52YXIgZGl2ID0gZGl2aWRlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmRpdiA9IGRpdjtcbnZhciBkaXN0ID0gZGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWREaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmRpc3QgPSBkaXN0O1xudmFyIHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zcXJEaXN0ID0gc3FyRGlzdDtcbnZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNxckxlbiA9IHNxckxlbjtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAyO1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdO1xuICAgICAgYVtpICsgMV0gPSB2ZWNbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KCk7XG5cbmV4cG9ydHMuZm9yRWFjaCA9IGZvckVhY2g7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLmRpdmlkZSA9IGRpdmlkZTtcbmV4cG9ydHMuY2VpbCA9IGNlaWw7XG5leHBvcnRzLmZsb29yID0gZmxvb3I7XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubWF4ID0gbWF4O1xuZXhwb3J0cy5yb3VuZCA9IHJvdW5kO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5zY2FsZUFuZEFkZCA9IHNjYWxlQW5kQWRkO1xuZXhwb3J0cy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuZXhwb3J0cy5zcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG5leHBvcnRzLnNxdWFyZWRMZW5ndGggPSBzcXVhcmVkTGVuZ3RoO1xuZXhwb3J0cy5uZWdhdGUgPSBuZWdhdGU7XG5leHBvcnRzLmludmVyc2UgPSBpbnZlcnNlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmRvdCA9IGRvdDtcbmV4cG9ydHMuY3Jvc3MgPSBjcm9zcztcbmV4cG9ydHMubGVycCA9IGxlcnA7XG5leHBvcnRzLmhlcm1pdGUgPSBoZXJtaXRlO1xuZXhwb3J0cy5iZXppZXIgPSBiZXppZXI7XG5leHBvcnRzLnJhbmRvbSA9IHJhbmRvbTtcbmV4cG9ydHMudHJhbnNmb3JtTWF0NCA9IHRyYW5zZm9ybU1hdDQ7XG5leHBvcnRzLnRyYW5zZm9ybU1hdDMgPSB0cmFuc2Zvcm1NYXQzO1xuZXhwb3J0cy50cmFuc2Zvcm1RdWF0ID0gdHJhbnNmb3JtUXVhdDtcbmV4cG9ydHMucm90YXRlWCA9IHJvdGF0ZVg7XG5leHBvcnRzLnJvdGF0ZVkgPSByb3RhdGVZO1xuZXhwb3J0cy5yb3RhdGVaID0gcm90YXRlWjtcbmV4cG9ydHMuYW5nbGUgPSBhbmdsZTtcbmV4cG9ydHMuemVybyA9IHplcm87XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuZXhhY3RFcXVhbHMgPSBleGFjdEVxdWFscztcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5mb3JFYWNoID0gZXhwb3J0cy5zcXJMZW4gPSBleHBvcnRzLmxlbiA9IGV4cG9ydHMuc3FyRGlzdCA9IGV4cG9ydHMuZGlzdCA9IGV4cG9ydHMuZGl2ID0gZXhwb3J0cy5tdWwgPSBleHBvcnRzLnN1YiA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLyoqXHJcbiAqIDMgRGltZW5zaW9uYWwgVmVjdG9yXHJcbiAqIEBtb2R1bGUgdmVjM1xyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcclxuICpcclxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcclxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogRGl2aWRlcyB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjZWlsXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHopO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cblxuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cblxuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn1cbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdO1xuICB2YXIgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdO1xuICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGhlcm1pdGUgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBoZXJtaXRlKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxO1xuICB2YXIgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0O1xuICB2YXIgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSk7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBiZXppZXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBiZXppZXIob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBpbnZlcnNlRmFjdG9yID0gMSAtIHQ7XG4gIHZhciBpbnZlcnNlRmFjdG9yVGltZXNUd28gPSBpbnZlcnNlRmFjdG9yICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICB2YXIgZmFjdG9yMSA9IGludmVyc2VGYWN0b3JUaW1lc1R3byAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3IyID0gMyAqIHQgKiBpbnZlcnNlRmFjdG9yVGltZXNUd287XG4gIHZhciBmYWN0b3IzID0gMyAqIGZhY3RvclRpbWVzMiAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogdDtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgdmFyIHogPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAtIDEuMDtcbiAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAgLSB6ICogeikgKiBzY2FsZTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICBvdXRbMl0gPSB6ICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cclxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgdmFyIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV07XG4gIHcgPSB3IHx8IDEuMDtcbiAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3O1xuICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcclxuICogQ2FuIGFsc28gYmUgdXNlZCBmb3IgZHVhbCBxdWF0ZXJuaW9ucy4gKE11bHRpcGx5IGl0IHdpdGggdGhlIHJlYWwgcGFydClcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIC8vIGJlbmNobWFya3M6IGh0dHBzOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9ucy1maXhlZFxuICB2YXIgcXggPSBxWzBdLFxuICAgICAgcXkgPSBxWzFdLFxuICAgICAgcXogPSBxWzJdLFxuICAgICAgcXcgPSBxWzNdO1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdOyAvLyB2YXIgcXZlYyA9IFtxeCwgcXksIHF6XTtcbiAgLy8gdmFyIHV2ID0gdmVjMy5jcm9zcyhbXSwgcXZlYywgYSk7XG5cbiAgdmFyIHV2eCA9IHF5ICogeiAtIHF6ICogeSxcbiAgICAgIHV2eSA9IHF6ICogeCAtIHF4ICogeixcbiAgICAgIHV2eiA9IHF4ICogeSAtIHF5ICogeDsgLy8gdmFyIHV1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIHV2KTtcblxuICB2YXIgdXV2eCA9IHF5ICogdXZ6IC0gcXogKiB1dnksXG4gICAgICB1dXZ5ID0gcXogKiB1dnggLSBxeCAqIHV2eixcbiAgICAgIHV1dnogPSBxeCAqIHV2eSAtIHF5ICogdXZ4OyAvLyB2ZWMzLnNjYWxlKHV2LCB1diwgMiAqIHcpO1xuXG4gIHZhciB3MiA9IHF3ICogMjtcbiAgdXZ4ICo9IHcyO1xuICB1dnkgKj0gdzI7XG4gIHV2eiAqPSB3MjsgLy8gdmVjMy5zY2FsZSh1dXYsIHV1diwgMik7XG5cbiAgdXV2eCAqPSAyO1xuICB1dXZ5ICo9IDI7XG4gIHV1dnogKj0gMjsgLy8gcmV0dXJuIHZlYzMuYWRkKG91dCwgYSwgdmVjMy5hZGQob3V0LCB1diwgdXV2KSk7XG5cbiAgb3V0WzBdID0geCArIHV2eCArIHV1dng7XG4gIG91dFsxXSA9IHkgKyB1dnkgKyB1dXZ5O1xuICBvdXRbMl0gPSB6ICsgdXZ6ICsgdXV2ejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMF07XG4gIHJbMV0gPSBwWzFdICogTWF0aC5jb3MocmFkKSAtIHBbMl0gKiBNYXRoLnNpbihyYWQpO1xuICByWzJdID0gcFsxXSAqIE1hdGguc2luKHJhZCkgKyBwWzJdICogTWF0aC5jb3MocmFkKTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeS1heGlzXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzJdICogTWF0aC5zaW4ocmFkKSArIHBbMF0gKiBNYXRoLmNvcyhyYWQpO1xuICByWzFdID0gcFsxXTtcbiAgclsyXSA9IHBbMl0gKiBNYXRoLmNvcyhyYWQpIC0gcFswXSAqIE1hdGguc2luKHJhZCk7IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFswXSAqIE1hdGguY29zKHJhZCkgLSBwWzFdICogTWF0aC5zaW4ocmFkKTtcbiAgclsxXSA9IHBbMF0gKiBNYXRoLnNpbihyYWQpICsgcFsxXSAqIE1hdGguY29zKHJhZCk7XG4gIHJbMl0gPSBwWzJdOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDNEIHZlY3RvcnNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIGJ6ID0gYlsyXSxcbiAgICAgIG1hZzEgPSBNYXRoLnNxcnQoYXggKiBheCArIGF5ICogYXkgKyBheiAqIGF6KSxcbiAgICAgIG1hZzIgPSBNYXRoLnNxcnQoYnggKiBieCArIGJ5ICogYnkgKyBieiAqIGJ6KSxcbiAgICAgIG1hZyA9IG1hZzEgKiBtYWcyLFxuICAgICAgY29zaW5lID0gbWFnICYmIGRvdChhLCBiKSAvIG1hZztcbiAgcmV0dXJuIE1hdGguYWNvcyhNYXRoLm1pbihNYXRoLm1heChjb3NpbmUsIC0xKSwgMSkpO1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gemVyb1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzMoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIHN1YiA9IHN1YnRyYWN0O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnN1YiA9IHN1YjtcbnZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubXVsID0gbXVsO1xudmFyIGRpdiA9IGRpdmlkZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5kaXYgPSBkaXY7XG52YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkRGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5kaXN0ID0gZGlzdDtcbnZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zcXJEaXN0ID0gc3FyRGlzdDtcbnZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5sZW4gPSBsZW47XG52YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cclxuICogQHJldHVybnMge0FycmF5fSBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zcXJMZW4gPSBzcXJMZW47XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmVjID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGw7XG5cbiAgICBpZiAoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMztcbiAgICB9XG5cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGwgPSBNYXRoLm1pbihjb3VudCAqIHN0cmlkZSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07XG4gICAgICB2ZWNbMV0gPSBhW2kgKyAxXTtcbiAgICAgIHZlY1syXSA9IGFbaSArIDJdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdO1xuICAgICAgYVtpICsgMV0gPSB2ZWNbMV07XG4gICAgICBhW2kgKyAyXSA9IHZlY1syXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5mb3JFYWNoID0gZm9yRWFjaDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLmRpdmlkZSA9IGRpdmlkZTtcbmV4cG9ydHMuY2VpbCA9IGNlaWw7XG5leHBvcnRzLmZsb29yID0gZmxvb3I7XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubWF4ID0gbWF4O1xuZXhwb3J0cy5yb3VuZCA9IHJvdW5kO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5zY2FsZUFuZEFkZCA9IHNjYWxlQW5kQWRkO1xuZXhwb3J0cy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuZXhwb3J0cy5zcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbmV4cG9ydHMuc3F1YXJlZExlbmd0aCA9IHNxdWFyZWRMZW5ndGg7XG5leHBvcnRzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbmV4cG9ydHMuaW52ZXJzZSA9IGludmVyc2U7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMuZG90ID0gZG90O1xuZXhwb3J0cy5jcm9zcyA9IGNyb3NzO1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMucmFuZG9tID0gcmFuZG9tO1xuZXhwb3J0cy50cmFuc2Zvcm1NYXQ0ID0gdHJhbnNmb3JtTWF0NDtcbmV4cG9ydHMudHJhbnNmb3JtUXVhdCA9IHRyYW5zZm9ybVF1YXQ7XG5leHBvcnRzLnplcm8gPSB6ZXJvO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLmV4YWN0RXF1YWxzID0gZXhhY3RFcXVhbHM7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcbmV4cG9ydHMuZm9yRWFjaCA9IGV4cG9ydHMuc3FyTGVuID0gZXhwb3J0cy5sZW4gPSBleHBvcnRzLnNxckRpc3QgPSBleHBvcnRzLmRpc3QgPSBleHBvcnRzLmRpdiA9IGV4cG9ydHMubXVsID0gZXhwb3J0cy5zdWIgPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKlxyXG4gKiA0IERpbWVuc2lvbmFsIFZlY3RvclxyXG4gKiBAbW9kdWxlIHZlYzRcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWM0XHJcbiAqXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcclxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeiwgdykge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeiwgdykge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIG91dFszXSA9IGFbM10gKiBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIERpdmlkZXMgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIG91dFszXSA9IGFbM10gLyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNlaWxcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmNlaWwoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGZsb29yXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIG91dFszXSA9IE1hdGguZmxvb3IoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIHJvdW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIG91dFszXSA9IE1hdGgucm91bmQoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIGEgdmVjNCBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWM0J3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cblxuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICB2YXIgdyA9IGJbM10gLSBhWzNdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6LCB3KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHZhciB3ID0gYlszXSAtIGFbM107XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciB3ID0gYVszXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeiwgdyk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG59XG4vKipcclxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gLWFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGludmVydFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIG91dFszXSA9IDEuMCAvIGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgdyA9IGFbM107XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcblxuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgfVxuXG4gIG91dFswXSA9IHggKiBsZW47XG4gIG91dFsxXSA9IHkgKiBsZW47XG4gIG91dFsyXSA9IHogKiBsZW47XG4gIG91dFszXSA9IHcgKiBsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxyXG4gKi9cblxuXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgY3Jvc3MtcHJvZHVjdCBvZiB0aHJlZSB2ZWN0b3JzIGluIGEgNC1kaW1lbnNpb25hbCBzcGFjZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gcmVzdWx0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBVIHRoZSBmaXJzdCB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IFYgdGhlIHNlY29uZCB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IFcgdGhlIHRoaXJkIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gcmVzdWx0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyb3NzKG91dCwgdSwgdiwgdykge1xuICB2YXIgQSA9IHZbMF0gKiB3WzFdIC0gdlsxXSAqIHdbMF0sXG4gICAgICBCID0gdlswXSAqIHdbMl0gLSB2WzJdICogd1swXSxcbiAgICAgIEMgPSB2WzBdICogd1szXSAtIHZbM10gKiB3WzBdLFxuICAgICAgRCA9IHZbMV0gKiB3WzJdIC0gdlsyXSAqIHdbMV0sXG4gICAgICBFID0gdlsxXSAqIHdbM10gLSB2WzNdICogd1sxXSxcbiAgICAgIEYgPSB2WzJdICogd1szXSAtIHZbM10gKiB3WzJdO1xuICB2YXIgRyA9IHVbMF07XG4gIHZhciBIID0gdVsxXTtcbiAgdmFyIEkgPSB1WzJdO1xuICB2YXIgSiA9IHVbM107XG4gIG91dFswXSA9IEggKiBGIC0gSSAqIEUgKyBKICogRDtcbiAgb3V0WzFdID0gLShHICogRikgKyBJICogQyAtIEogKiBCO1xuICBvdXRbMl0gPSBHICogRSAtIEggKiBDICsgSiAqIEE7XG4gIG91dFszXSA9IC0oRyAqIEQpICsgSCAqIEIgLSBJICogQTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF07XG4gIHZhciBheSA9IGFbMV07XG4gIHZhciBheiA9IGFbMl07XG4gIHZhciBhdyA9IGFbM107XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gIG91dFszXSA9IGF3ICsgdCAqIChiWzNdIC0gYXcpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7IC8vIE1hcnNhZ2xpYSwgR2VvcmdlLiBDaG9vc2luZyBhIFBvaW50IGZyb20gdGhlIFN1cmZhY2Ugb2YgYVxuICAvLyBTcGhlcmUuIEFubi4gTWF0aC4gU3RhdGlzdC4gNDMgKDE5NzIpLCBuby4gMiwgNjQ1LS02NDYuXG4gIC8vIGh0dHA6Ly9wcm9qZWN0ZXVjbGlkLm9yZy9ldWNsaWQuYW9tcy8xMTc3NjkyNjQ0O1xuXG4gIHZhciB2MSwgdjIsIHYzLCB2NDtcbiAgdmFyIHMxLCBzMjtcblxuICBkbyB7XG4gICAgdjEgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIgLSAxO1xuICAgIHYyID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICBzMSA9IHYxICogdjEgKyB2MiAqIHYyO1xuICB9IHdoaWxlIChzMSA+PSAxKTtcblxuICBkbyB7XG4gICAgdjMgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIgLSAxO1xuICAgIHY0ID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICBzMiA9IHYzICogdjMgKyB2NCAqIHY0O1xuICB9IHdoaWxlIChzMiA+PSAxKTtcblxuICB2YXIgZCA9IE1hdGguc3FydCgoMSAtIHMxKSAvIHMyKTtcbiAgb3V0WzBdID0gc2NhbGUgKiB2MTtcbiAgb3V0WzFdID0gc2NhbGUgKiB2MjtcbiAgb3V0WzJdID0gc2NhbGUgKiB2MyAqIGQ7XG4gIG91dFszXSA9IHNjYWxlICogdjQgKiBkO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl0sXG4gICAgICB3ID0gYVszXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSAqIHc7XG4gIG91dFsyXSA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSAqIHc7XG4gIG91dFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXTsgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcblxuICB2YXIgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG4gIHZhciBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcbiAgdmFyIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICB2YXIgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6OyAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG5cbiAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHplcm9cclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICBvdXRbM10gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzQoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbnZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zdWIgPSBzdWI7XG52YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpdmlkZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLm11bCA9IG11bDtcbnZhciBkaXYgPSBkaXZpZGU7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuZGl2ID0gZGl2O1xudmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZERpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuZGlzdCA9IGRpc3Q7XG52YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3FyRGlzdCA9IHNxckRpc3Q7XG52YXIgbGVuID0gbGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkTGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubGVuID0gbGVuO1xudmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzQuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjNHMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3FyTGVuID0gc3FyTGVuO1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuXG4gICAgaWYgKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDQ7XG4gICAgfVxuXG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldO1xuICAgICAgdmVjWzFdID0gYVtpICsgMV07XG4gICAgICB2ZWNbMl0gPSBhW2kgKyAyXTtcbiAgICAgIHZlY1szXSA9IGFbaSArIDNdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdO1xuICAgICAgYVtpICsgMV0gPSB2ZWNbMV07XG4gICAgICBhW2kgKyAyXSA9IHZlY1syXTtcbiAgICAgIGFbaSArIDNdID0gdmVjWzNdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSgpO1xuXG5leHBvcnRzLmZvckVhY2ggPSBmb3JFYWNoOyIsIi8qISBIYW1tZXIuSlMgLSB2Mi4wLjQgLSAyMDE0LTA5LTI4XHJcbiAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb3JpayBUYW5nZWxkZXI7XHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xyXG4oZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCwgZXhwb3J0TmFtZSwgdW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFZFTkRPUl9QUkVGSVhFUyA9IFsnJywgJ3dlYmtpdCcsICdtb3onLCAnTVMnLCAnbXMnLCAnbyddO1xyXG52YXIgVEVTVF9FTEVNRU5UID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG52YXIgVFlQRV9GVU5DVElPTiA9ICdmdW5jdGlvbic7XHJcblxyXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xyXG52YXIgYWJzID0gTWF0aC5hYnM7XHJcbnZhciBub3cgPSBEYXRlLm5vdztcclxuXHJcbi8qKlxyXG4gKiBzZXQgYSB0aW1lb3V0IHdpdGggYSBnaXZlbiBzY29wZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxyXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0VGltZW91dENvbnRleHQoZm4sIHRpbWVvdXQsIGNvbnRleHQpIHtcclxuICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmRGbihmbiwgY29udGV4dCksIHRpbWVvdXQpO1xyXG59XHJcblxyXG4vKipcclxuICogaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCB3ZSB3YW50IHRvIGV4ZWN1dGUgdGhlIGZuIG9uIGVhY2ggZW50cnlcclxuICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXHJcbiAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxyXG4gKiBAcGFyYW0geyp8QXJyYXl9IGFyZ1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cclxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcclxuICAgICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxyXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgaTtcclxuXHJcbiAgICBpZiAoIW9iaikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob2JqLmZvckVhY2gpIHtcclxuICAgICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XHJcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgb2JqLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xyXG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoaSkgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogZXh0ZW5kIG9iamVjdC5cclxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcclxuICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2VdXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcclxuICovXHJcbmZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMsIG1lcmdlKSB7XHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFtZXJnZSB8fCAobWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVzdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIG1lcmdlIHRoZSB2YWx1ZXMgZnJvbSBzcmMgaW4gdGhlIGRlc3QuXHJcbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcclxuICogQHJldHVybnMge09iamVjdH0gZGVzdFxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjKSB7XHJcbiAgICByZXR1cm4gZXh0ZW5kKGRlc3QsIHNyYywgdHJ1ZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XHJcbiAgICB2YXIgYmFzZVAgPSBiYXNlLnByb3RvdHlwZSxcclxuICAgICAgICBjaGlsZFA7XHJcblxyXG4gICAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XHJcbiAgICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcclxuICAgIGNoaWxkUC5fc3VwZXIgPSBiYXNlUDtcclxuXHJcbiAgICBpZiAocHJvcGVydGllcykge1xyXG4gICAgICAgIGV4dGVuZChjaGlsZFAsIHByb3BlcnRpZXMpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKi9cclxuZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRGbigpIHtcclxuICAgICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxyXG4gKiB0aGlzIGZpcnN0IGl0ZW0gaW4gYXJncyB3aWxsIGJlIHVzZWQgYXMgdGhlIGNvbnRleHRcclxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcclxuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PSBUWVBFX0ZVTkNUSU9OKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbC5hcHBseShhcmdzID8gYXJnc1swXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIHVzZSB0aGUgdmFsMiB3aGVuIHZhbDEgaXMgdW5kZWZpbmVkXHJcbiAqIEBwYXJhbSB7Kn0gdmFsMVxyXG4gKiBAcGFyYW0geyp9IHZhbDJcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5mdW5jdGlvbiBpZlVuZGVmaW5lZCh2YWwxLCB2YWwyKSB7XHJcbiAgICByZXR1cm4gKHZhbDEgPT09IHVuZGVmaW5lZCkgPyB2YWwyIDogdmFsMTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxyXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcclxuICovXHJcbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcclxuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcclxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XHJcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxyXG4gKiBAbWV0aG9kIGhhc1BhcmVudFxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxyXG4gKi9cclxuZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xyXG4gICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcclxuICovXHJcbmZ1bmN0aW9uIGluU3RyKHN0ciwgZmluZCkge1xyXG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcclxuICovXHJcbmZ1bmN0aW9uIHNwbGl0U3RyKHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHNyY1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cclxuICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcclxuICovXHJcbmZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcclxuICAgIGlmIChzcmMuaW5kZXhPZiAmJiAhZmluZEJ5S2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICgoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQpIHx8ICghZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogY29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gcmVhbCBhcnJheXNcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xyXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB1bmlxdWUgYXJyYXkgd2l0aCBvYmplY3RzIGJhc2VkIG9uIGEga2V5IChsaWtlICdpZCcpIG9yIGp1c3QgYnkgdGhlIGFycmF5J3MgdmFsdWVcclxuICogQHBhcmFtIHtBcnJheX0gc3JjIFt7aWQ6MX0se2lkOjJ9LHtpZDoxfV1cclxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvcnQ9RmFsc2VdXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gW3tpZDoxfSx7aWQ6Mn1dXHJcbiAqL1xyXG5mdW5jdGlvbiB1bmlxdWVBcnJheShzcmMsIGtleSwgc29ydCkge1xyXG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgIHZhciBpID0gMDtcclxuXHJcbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcclxuICAgICAgICB2YXIgdmFsID0ga2V5ID8gc3JjW2ldW2tleV0gOiBzcmNbaV07XHJcbiAgICAgICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWVzW2ldID0gdmFsO1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc29ydCkge1xyXG4gICAgICAgIGlmICgha2V5KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KGZ1bmN0aW9uIHNvcnRVbmlxdWVBcnJheShhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBnZXQgdGhlIHByZWZpeGVkIHByb3BlcnR5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XHJcbiAqIEByZXR1cm5zIHtTdHJpbmd8VW5kZWZpbmVkfSBwcmVmaXhlZFxyXG4gKi9cclxuZnVuY3Rpb24gcHJlZml4ZWQob2JqLCBwcm9wZXJ0eSkge1xyXG4gICAgdmFyIHByZWZpeCwgcHJvcDtcclxuICAgIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XHJcblxyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XHJcbiAgICAgICAgcHJlZml4ID0gVkVORE9SX1BSRUZJWEVTW2ldO1xyXG4gICAgICAgIHByb3AgPSAocHJlZml4KSA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xyXG5cclxuICAgICAgICBpZiAocHJvcCBpbiBvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBnZXQgYSB1bmlxdWUgaWRcclxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlSWRcclxuICovXHJcbnZhciBfdW5pcXVlSWQgPSAxO1xyXG5mdW5jdGlvbiB1bmlxdWVJZCgpIHtcclxuICAgIHJldHVybiBfdW5pcXVlSWQrKztcclxufVxyXG5cclxuLyoqXHJcbiAqIGdldCB0aGUgd2luZG93IG9iamVjdCBvZiBhbiBlbGVtZW50XHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XHJcbiAgICByZXR1cm4gKGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93KTtcclxufVxyXG5cclxudmFyIE1PQklMRV9SRUdFWCA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWQvaTtcclxuXHJcbnZhciBTVVBQT1JUX1RPVUNIID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XHJcbnZhciBTVVBQT1JUX1BPSU5URVJfRVZFTlRTID0gcHJlZml4ZWQod2luZG93LCAnUG9pbnRlckV2ZW50JykgIT09IHVuZGVmaW5lZDtcclxudmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcblxyXG52YXIgSU5QVVRfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XHJcbnZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xyXG52YXIgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XHJcbnZhciBJTlBVVF9UWVBFX0tJTkVDVCA9ICdraW5lY3QnO1xyXG5cclxudmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcclxuXHJcbnZhciBJTlBVVF9TVEFSVCA9IDE7XHJcbnZhciBJTlBVVF9NT1ZFID0gMjtcclxudmFyIElOUFVUX0VORCA9IDQ7XHJcbnZhciBJTlBVVF9DQU5DRUwgPSA4O1xyXG5cclxudmFyIERJUkVDVElPTl9OT05FID0gMTtcclxudmFyIERJUkVDVElPTl9MRUZUID0gMjtcclxudmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XHJcbnZhciBESVJFQ1RJT05fVVAgPSA4O1xyXG52YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcclxuXHJcbnZhciBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9MRUZUIHwgRElSRUNUSU9OX1JJR0hUO1xyXG52YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XHJcbnZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XHJcblxyXG52YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xyXG52YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxyXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICogQHJldHVybnMge0lucHV0fVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgdGhpcy5lbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xyXG4gICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7XHJcblxyXG4gICAgLy8gc21hbGxlciB3cmFwcGVyIGFyb3VuZCB0aGUgaGFuZGxlciwgZm9yIHRoZSBzY29wZSBhbmQgdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIG1hbmFnZXIsXHJcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXHJcbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xyXG4gICAgICAgIGlmIChib29sT3JGbihtYW5hZ2VyLm9wdGlvbnMuZW5hYmxlLCBbbWFuYWdlcl0pKSB7XHJcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlcihldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmluaXQoKTtcclxuXHJcbn1cclxuXHJcbklucHV0LnByb3RvdHlwZSA9IHtcclxuICAgIC8qKlxyXG4gICAgICogc2hvdWxkIGhhbmRsZSB0aGUgaW5wdXRFdmVudCBkYXRhIGFuZCB0cmlnZ2VyIHRoZSBjYWxsYmFja1xyXG4gICAgICogQHZpcnR1YWxcclxuICAgICAqL1xyXG4gICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7IH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBiaW5kIHRoZSBldmVudHNcclxuICAgICAqL1xyXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuZXZUYXJnZXQgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5ldldpbiAmJiBhZGRFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdW5iaW5kIHRoZSBldmVudHNcclxuICAgICAqL1xyXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuZXZUYXJnZXQgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcclxuICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXHJcbiAqIEByZXR1cm5zIHtJbnB1dH1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xyXG4gICAgdmFyIFR5cGU7XHJcbiAgICB2YXIgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xyXG5cclxuICAgIGlmIChpbnB1dENsYXNzKSB7XHJcbiAgICAgICAgVHlwZSA9IGlucHV0Q2xhc3M7XHJcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcclxuICAgICAgICBUeXBlID0gUG9pbnRlckV2ZW50SW5wdXQ7XHJcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xyXG4gICAgICAgIFR5cGUgPSBUb3VjaElucHV0O1xyXG4gICAgfSBlbHNlIGlmICghU1VQUE9SVF9UT1VDSCkge1xyXG4gICAgICAgIFR5cGUgPSBNb3VzZUlucHV0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBUeXBlID0gVG91Y2hNb3VzZUlucHV0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyAoVHlwZSkobWFuYWdlciwgaW5wdXRIYW5kbGVyKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGhhbmRsZSBpbnB1dCBldmVudHNcclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XHJcbiAqL1xyXG5mdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xyXG4gICAgdmFyIHBvaW50ZXJzTGVuID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoO1xyXG4gICAgdmFyIGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XHJcbiAgICB2YXIgaXNGaXJzdCA9IChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcclxuICAgIHZhciBpc0ZpbmFsID0gKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIChwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMCkpO1xyXG5cclxuICAgIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XHJcbiAgICBpbnB1dC5pc0ZpbmFsID0gISFpc0ZpbmFsO1xyXG5cclxuICAgIGlmIChpc0ZpcnN0KSB7XHJcbiAgICAgICAgbWFuYWdlci5zZXNzaW9uID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc291cmNlIGV2ZW50IGlzIHRoZSBub3JtYWxpemVkIHZhbHVlIG9mIHRoZSBkb21FdmVudHNcclxuICAgIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xyXG4gICAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xyXG5cclxuICAgIC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xyXG4gICAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7XHJcblxyXG4gICAgLy8gZW1pdCBzZWNyZXQgZXZlbnRcclxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xyXG5cclxuICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcclxuICAgIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcclxufVxyXG5cclxuLyoqXHJcbiAqIGV4dGVuZCB0aGUgZGF0YSB3aXRoIHNvbWUgdXNhYmxlIHByb3BlcnRpZXMgbGlrZSBzY2FsZSwgcm90YXRlLCB2ZWxvY2l0eSBldGNcclxuICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KSB7XHJcbiAgICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcclxuICAgIHZhciBwb2ludGVycyA9IGlucHV0LnBvaW50ZXJzO1xyXG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xyXG5cclxuICAgIC8vIHN0b3JlIHRoZSBmaXJzdCBpbnB1dCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGFuZCBkaXJlY3Rpb25cclxuICAgIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XHJcbiAgICAgICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcclxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA+IDEgJiYgIXNlc3Npb24uZmlyc3RNdWx0aXBsZSkge1xyXG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcclxuICAgIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcclxuICAgICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZmlyc3RJbnB1dCA9IHNlc3Npb24uZmlyc3RJbnB1dDtcclxuICAgIHZhciBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xyXG4gICAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xyXG5cclxuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xyXG4gICAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XHJcbiAgICBpbnB1dC5kZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBmaXJzdElucHV0LnRpbWVTdGFtcDtcclxuXHJcbiAgICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcclxuICAgIGlucHV0LmRpc3RhbmNlID0gZ2V0RGlzdGFuY2Uob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xyXG5cclxuICAgIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcclxuICAgIGlucHV0Lm9mZnNldERpcmVjdGlvbiA9IGdldERpcmVjdGlvbihpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XHJcblxyXG4gICAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcclxuICAgIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XHJcblxyXG4gICAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTtcclxuXHJcbiAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxyXG4gICAgdmFyIHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcclxuICAgIGlmIChoYXNQYXJlbnQoaW5wdXQuc3JjRXZlbnQudGFyZ2V0LCB0YXJnZXQpKSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gaW5wdXQuc3JjRXZlbnQudGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgaW5wdXQudGFyZ2V0ID0gdGFyZ2V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xyXG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlcjtcclxuICAgIHZhciBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhIHx8IHt9O1xyXG4gICAgdmFyIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xyXG4gICAgdmFyIHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xyXG5cclxuICAgIGlmIChpbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX1NUQVJUIHx8IHByZXZJbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX0VORCkge1xyXG4gICAgICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xyXG4gICAgICAgICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXHJcbiAgICAgICAgICAgIHk6IHByZXZJbnB1dC5kZWx0YVkgfHwgMFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgPSB7XHJcbiAgICAgICAgICAgIHg6IGNlbnRlci54LFxyXG4gICAgICAgICAgICB5OiBjZW50ZXIueVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXQuZGVsdGFYID0gcHJldkRlbHRhLnggKyAoY2VudGVyLnggLSBvZmZzZXQueCk7XHJcbiAgICBpbnB1dC5kZWx0YVkgPSBwcmV2RGVsdGEueSArIChjZW50ZXIueSAtIG9mZnNldC55KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcclxuICovXHJcbmZ1bmN0aW9uIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCkge1xyXG4gICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dCxcclxuICAgICAgICBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcCxcclxuICAgICAgICB2ZWxvY2l0eSwgdmVsb2NpdHlYLCB2ZWxvY2l0eVksIGRpcmVjdGlvbjtcclxuXHJcbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgdmFyIGRlbHRhWCA9IGxhc3QuZGVsdGFYIC0gaW5wdXQuZGVsdGFYO1xyXG4gICAgICAgIHZhciBkZWx0YVkgPSBsYXN0LmRlbHRhWSAtIGlucHV0LmRlbHRhWTtcclxuXHJcbiAgICAgICAgdmFyIHYgPSBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcclxuICAgICAgICB2ZWxvY2l0eVggPSB2Lng7XHJcbiAgICAgICAgdmVsb2NpdHlZID0gdi55O1xyXG4gICAgICAgIHZlbG9jaXR5ID0gKGFicyh2LngpID4gYWJzKHYueSkpID8gdi54IDogdi55O1xyXG4gICAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XHJcblxyXG4gICAgICAgIHNlc3Npb24ubGFzdEludGVydmFsID0gaW5wdXQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcclxuICAgICAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XHJcbiAgICAgICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XHJcbiAgICAgICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XHJcbiAgICAgICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXQudmVsb2NpdHkgPSB2ZWxvY2l0eTtcclxuICAgIGlucHV0LnZlbG9jaXR5WCA9IHZlbG9jaXR5WDtcclxuICAgIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcclxuICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIGNyZWF0ZSBhIHNpbXBsZSBjbG9uZSBmcm9tIHRoZSBpbnB1dCB1c2VkIGZvciBzdG9yYWdlIG9mIGZpcnN0SW5wdXQgYW5kIGZpcnN0TXVsdGlwbGVcclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IGNsb25lZElucHV0RGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcclxuICAgIC8vIG1ha2UgYSBzaW1wbGUgY29weSBvZiB0aGUgcG9pbnRlcnMgYmVjYXVzZSB3ZSB3aWxsIGdldCBhIHJlZmVyZW5jZSBpZiB3ZSBkb24ndFxyXG4gICAgLy8gd2Ugb25seSBuZWVkIGNsaWVudFhZIGZvciB0aGUgY2FsY3VsYXRpb25zXHJcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgaW5wdXQucG9pbnRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgcG9pbnRlcnNbaV0gPSB7XHJcbiAgICAgICAgICAgIGNsaWVudFg6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFgpLFxyXG4gICAgICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdGltZVN0YW1wOiBub3coKSxcclxuICAgICAgICBwb2ludGVyczogcG9pbnRlcnMsXHJcbiAgICAgICAgY2VudGVyOiBnZXRDZW50ZXIocG9pbnRlcnMpLFxyXG4gICAgICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxyXG4gICAgICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSBwb2ludGVyc1xyXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xyXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcclxuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxyXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXHJcbiAgICAgICAgICAgIHk6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFkpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgeCA9IDAsIHkgPSAwLCBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcclxuICAgICAgICB4ICs9IHBvaW50ZXJzW2ldLmNsaWVudFg7XHJcbiAgICAgICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHJvdW5kKHggLyBwb2ludGVyc0xlbmd0aCksXHJcbiAgICAgICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxyXG4gKiBAcGFyYW0ge051bWJlcn0geFxyXG4gKiBAcGFyYW0ge051bWJlcn0geVxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIHgsIHkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxyXG4gICAgICAgIHk6IHkgLyBkZWx0YVRpbWUgfHwgMFxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xyXG4gKiBAcGFyYW0ge051bWJlcn0geFxyXG4gKiBAcGFyYW0ge051bWJlcn0geVxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpcmVjdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcclxuICAgIGlmICh4ID09PSB5KSB7XHJcbiAgICAgICAgcmV0dXJuIERJUkVDVElPTl9OT05FO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhYnMoeCkgPj0gYWJzKHkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHggPiAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geSA+IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcclxufVxyXG5cclxuLyoqXHJcbiAqIGNhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cclxuICogQHBhcmFtIHtPYmplY3R9IHAyIHt4LCB5fVxyXG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXHJcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcclxuICovXHJcbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMiwgcHJvcHMpIHtcclxuICAgIGlmICghcHJvcHMpIHtcclxuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xyXG4gICAgfVxyXG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXHJcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcclxuICogQHBhcmFtIHtPYmplY3R9IHAxXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMlxyXG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXHJcbiAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcclxuICovXHJcbmZ1bmN0aW9uIGdldEFuZ2xlKHAxLCBwMiwgcHJvcHMpIHtcclxuICAgIGlmICghcHJvcHMpIHtcclxuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xyXG4gICAgfVxyXG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXHJcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcclxuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xyXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xyXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcclxuICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xyXG4gICAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpIC0gZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xyXG59XHJcblxyXG4vKipcclxuICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcclxuICogbm8gc2NhbGUgaXMgMSwgYW5kIGdvZXMgZG93biB0byAwIHdoZW4gcGluY2hlZCB0b2dldGhlciwgYW5kIGJpZ2dlciB3aGVuIHBpbmNoZWQgb3V0XHJcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XHJcbiAgICByZXR1cm4gZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0sIFBST1BTX0NMSUVOVF9YWSkgLyBnZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0sIFBST1BTX0NMSUVOVF9YWSk7XHJcbn1cclxuXHJcbnZhciBNT1VTRV9JTlBVVF9NQVAgPSB7XHJcbiAgICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxyXG4gICAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxyXG4gICAgbW91c2V1cDogSU5QVVRfRU5EXHJcbn07XHJcblxyXG52YXIgTU9VU0VfRUxFTUVOVF9FVkVOVFMgPSAnbW91c2Vkb3duJztcclxudmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xyXG5cclxuLyoqXHJcbiAqIE1vdXNlIGV2ZW50cyBpbnB1dFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgSW5wdXRcclxuICovXHJcbmZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XHJcbiAgICB0aGlzLmV2RWwgPSBNT1VTRV9FTEVNRU5UX0VWRU5UUztcclxuICAgIHRoaXMuZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xyXG5cclxuICAgIHRoaXMuYWxsb3cgPSB0cnVlOyAvLyB1c2VkIGJ5IElucHV0LlRvdWNoTW91c2UgdG8gZGlzYWJsZSBtb3VzZSBldmVudHNcclxuICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcclxuXHJcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5pbmhlcml0KE1vdXNlSW5wdXQsIElucHV0LCB7XHJcbiAgICAvKipcclxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gICAgICovXHJcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNRWhhbmRsZXIoZXYpIHtcclxuICAgICAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdO1xyXG5cclxuICAgICAgICAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cclxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xyXG4gICAgICAgICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBtb3VzZSBtdXN0IGJlIGRvd24sIGFuZCBtb3VzZSBldmVudHMgYXJlIGFsbG93ZWQgKHNlZSB0aGUgVG91Y2hNb3VzZSBpbnB1dClcclxuICAgICAgICBpZiAoIXRoaXMucHJlc3NlZCB8fCAhdGhpcy5hbGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xyXG4gICAgICAgICAgICBwb2ludGVyczogW2V2XSxcclxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxyXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcclxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxudmFyIFBPSU5URVJfSU5QVVRfTUFQID0ge1xyXG4gICAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxyXG4gICAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXHJcbiAgICBwb2ludGVydXA6IElOUFVUX0VORCxcclxuICAgIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcclxuICAgIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxyXG59O1xyXG5cclxuLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cclxudmFyIElFMTBfUE9JTlRFUl9UWVBFX0VOVU0gPSB7XHJcbiAgICAyOiBJTlBVVF9UWVBFX1RPVUNILFxyXG4gICAgMzogSU5QVVRfVFlQRV9QRU4sXHJcbiAgICA0OiBJTlBVVF9UWVBFX01PVVNFLFxyXG4gICAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XHJcbn07XHJcblxyXG52YXIgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XHJcbnZhciBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAncG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnO1xyXG5cclxuLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXHJcbmlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcclxuICAgIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XHJcbiAgICBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAnTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xyXG59XHJcblxyXG4vKipcclxuICogUG9pbnRlciBldmVudHMgaW5wdXRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIElucHV0XHJcbiAqL1xyXG5mdW5jdGlvbiBQb2ludGVyRXZlbnRJbnB1dCgpIHtcclxuICAgIHRoaXMuZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XHJcbiAgICB0aGlzLmV2V2luID0gUE9JTlRFUl9XSU5ET1dfRVZFTlRTO1xyXG5cclxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5zdG9yZSA9ICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wb2ludGVyRXZlbnRzID0gW10pO1xyXG59XHJcblxyXG5pbmhlcml0KFBvaW50ZXJFdmVudElucHV0LCBJbnB1dCwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICAgICAqL1xyXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gUEVoYW5kbGVyKGV2KSB7XHJcbiAgICAgICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcclxuICAgICAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZhbHNlO1xyXG5cclxuICAgICAgICB2YXIgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcclxuICAgICAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XHJcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XHJcblxyXG4gICAgICAgIHZhciBpc1RvdWNoID0gKHBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpO1xyXG5cclxuICAgICAgICAvLyBnZXQgaW5kZXggb2YgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxyXG4gICAgICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7XHJcblxyXG4gICAgICAgIC8vIHN0YXJ0IGFuZCBtb3VzZSBtdXN0IGJlIGRvd25cclxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xyXG4gICAgICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHN0b3JlLnB1c2goZXYpO1xyXG4gICAgICAgICAgICAgICAgc3RvcmVJbmRleCA9IHN0b3JlLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXHJcbiAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXHJcbiAgICAgICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xyXG4gICAgICAgICAgICBwb2ludGVyczogc3RvcmUsXHJcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcclxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxyXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKHJlbW92ZVBvaW50ZXIpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlXHJcbiAgICAgICAgICAgIHN0b3JlLnNwbGljZShzdG9yZUluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxudmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XHJcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcclxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcclxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXHJcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXHJcbn07XHJcblxyXG52YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XHJcbnZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XHJcblxyXG4vKipcclxuICogVG91Y2ggZXZlbnRzIGlucHV0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBJbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gU2luZ2xlVG91Y2hJbnB1dCgpIHtcclxuICAgIHRoaXMuZXZUYXJnZXQgPSBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUztcclxuICAgIHRoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcclxuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xyXG5cclxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmluaGVyaXQoU2luZ2xlVG91Y2hJbnB1dCwgSW5wdXQsIHtcclxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRFaGFuZGxlcihldikge1xyXG4gICAgICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcclxuXHJcbiAgICAgICAgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xyXG4gICAgICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xyXG5cclxuICAgICAgICAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXHJcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiB0b3VjaGVzWzBdLmxlbmd0aCAtIHRvdWNoZXNbMV0ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcclxuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXHJcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcclxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXHJcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cclxuICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcclxuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMoZXYsIHR5cGUpIHtcclxuICAgIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xyXG4gICAgdmFyIGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcclxuXHJcbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XHJcbiAgICAgICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW2FsbCwgY2hhbmdlZF07XHJcbn1cclxuXHJcbnZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XHJcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcclxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcclxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXHJcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXHJcbn07XHJcblxyXG52YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XHJcblxyXG4vKipcclxuICogTXVsdGktdXNlciB0b3VjaCBldmVudHMgaW5wdXRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIElucHV0XHJcbiAqL1xyXG5mdW5jdGlvbiBUb3VjaElucHV0KCkge1xyXG4gICAgdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XHJcbiAgICB0aGlzLnRhcmdldElkcyA9IHt9O1xyXG5cclxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmluaGVyaXQoVG91Y2hJbnB1dCwgSW5wdXQsIHtcclxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1URWhhbmRsZXIoZXYpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IFRPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcclxuICAgICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XHJcbiAgICAgICAgaWYgKCF0b3VjaGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XHJcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxyXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXHJcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxyXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogQHRoaXMge1RvdWNoSW5wdXR9XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUb3VjaGVzKGV2LCB0eXBlKSB7XHJcbiAgICB2YXIgYWxsVG91Y2hlcyA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XHJcbiAgICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7XHJcblxyXG4gICAgLy8gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZSB0b3VjaCwgdGhlIHByb2Nlc3MgY2FuIGJlIHNpbXBsaWZpZWRcclxuICAgIGlmICh0eXBlICYgKElOUFVUX1NUQVJUIHwgSU5QVVRfTU9WRSkgJiYgYWxsVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFthbGxUb3VjaGVzLCBhbGxUb3VjaGVzXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaSxcclxuICAgICAgICB0YXJnZXRUb3VjaGVzLFxyXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyksXHJcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMgPSBbXSxcclxuICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldDtcclxuXHJcbiAgICAvLyBnZXQgdGFyZ2V0IHRvdWNoZXMgZnJvbSB0b3VjaGVzXHJcbiAgICB0YXJnZXRUb3VjaGVzID0gYWxsVG91Y2hlcy5maWx0ZXIoZnVuY3Rpb24odG91Y2gpIHtcclxuICAgICAgICByZXR1cm4gaGFzUGFyZW50KHRvdWNoLnRhcmdldCwgdGFyZ2V0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGNvbGxlY3QgdG91Y2hlc1xyXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xyXG4gICAgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcclxuICAgICAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjbGVhbnVwIHJlbW92ZWQgdG91Y2hlc1xyXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY2hhbmdlZFRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXHJcbiAgICAgICAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLFxyXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzXHJcbiAgICBdO1xyXG59XHJcblxyXG4vKipcclxuICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XHJcbiAqXHJcbiAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxyXG4gKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBJbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gVG91Y2hNb3VzZUlucHV0KCkge1xyXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICB2YXIgaGFuZGxlciA9IGJpbmRGbih0aGlzLmhhbmRsZXIsIHRoaXMpO1xyXG4gICAgdGhpcy50b3VjaCA9IG5ldyBUb3VjaElucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XHJcbiAgICB0aGlzLm1vdXNlID0gbmV3IE1vdXNlSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcclxufVxyXG5cclxuaW5oZXJpdChUb3VjaE1vdXNlSW5wdXQsIElucHV0LCB7XHJcbiAgICAvKipcclxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXHJcbiAgICAgKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0RXZlbnRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcclxuICAgICAqL1xyXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVE1FaGFuZGxlcihtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpIHtcclxuICAgICAgICB2YXIgaXNUb3VjaCA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCksXHJcbiAgICAgICAgICAgIGlzTW91c2UgPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfTU9VU0UpO1xyXG5cclxuICAgICAgICAvLyB3aGVuIHdlJ3JlIGluIGEgdG91Y2ggZXZlbnQsIHNvICBibG9jayBhbGwgdXBjb21pbmcgbW91c2UgZXZlbnRzXHJcbiAgICAgICAgLy8gbW9zdCBtb2JpbGUgYnJvd3NlciBhbHNvIGVtaXQgbW91c2VldmVudHMsIHJpZ2h0IGFmdGVyIHRvdWNoc3RhcnRcclxuICAgICAgICBpZiAoaXNUb3VjaCkge1xyXG4gICAgICAgICAgICB0aGlzLm1vdXNlLmFsbG93ID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdXNlICYmICF0aGlzLm1vdXNlLmFsbG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlc2V0IHRoZSBhbGxvd01vdXNlIHdoZW4gd2UncmUgZG9uZVxyXG4gICAgICAgIGlmIChpbnB1dEV2ZW50ICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZS5hbGxvdyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcclxuICAgICAqL1xyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLm1vdXNlLmRlc3Ryb3koKTtcclxuICAgIH1cclxufSk7XHJcblxyXG52YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcclxudmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcclxuXHJcbi8vIG1hZ2ljYWwgdG91Y2hBY3Rpb24gdmFsdWVcclxudmFyIFRPVUNIX0FDVElPTl9DT01QVVRFID0gJ2NvbXB1dGUnO1xyXG52YXIgVE9VQ0hfQUNUSU9OX0FVVE8gPSAnYXV0byc7XHJcbnZhciBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OID0gJ21hbmlwdWxhdGlvbic7IC8vIG5vdCBpbXBsZW1lbnRlZFxyXG52YXIgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XHJcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1ggPSAncGFuLXgnO1xyXG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcclxuXHJcbi8qKlxyXG4gKiBUb3VjaCBBY3Rpb25cclxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIFRvdWNoQWN0aW9uKG1hbmFnZXIsIHZhbHVlKSB7XHJcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgdGhpcy5zZXQodmFsdWUpO1xyXG59XHJcblxyXG5Ub3VjaEFjdGlvbi5wcm90b3R5cGUgPSB7XHJcbiAgICAvKipcclxuICAgICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAvLyBmaW5kIG91dCB0aGUgdG91Y2gtYWN0aW9uIGJ5IHRoZSBldmVudCBoYW5kbGVyc1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBUT1VDSF9BQ1RJT05fQ09NUFVURSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04pIHtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGVbUFJFRklYRURfVE9VQ0hfQUNUSU9OXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnNldCh0aGlzLm1hbmFnZXIub3B0aW9ucy50b3VjaEFjdGlvbik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBjb21wdXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIGVhY2godGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLCBmdW5jdGlvbihyZWNvZ25pemVyKSB7XHJcbiAgICAgICAgICAgIGlmIChib29sT3JGbihyZWNvZ25pemVyLm9wdGlvbnMuZW5hYmxlLCBbcmVjb2duaXplcl0pKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIG9uIGVhY2ggaW5wdXQgY3ljbGUgYW5kIHByb3ZpZGVzIHRoZSBwcmV2ZW50aW5nIG9mIHRoZSBicm93c2VyIGJlaGF2aW9yXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcclxuICAgICAqL1xyXG4gICAgcHJldmVudERlZmF1bHRzOiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIC8vIG5vdCBuZWVkZWQgd2l0aCBuYXRpdmUgc3VwcG9ydCBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5XHJcbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0Lm9mZnNldERpcmVjdGlvbjtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXHJcbiAgICAgICAgaWYgKHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCkge1xyXG4gICAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcclxuICAgICAgICB2YXIgaGFzTm9uZSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKTtcclxuICAgICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XHJcbiAgICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xyXG5cclxuICAgICAgICBpZiAoaGFzTm9uZSB8fFxyXG4gICAgICAgICAgICAoaGFzUGFuWSAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkgfHxcclxuICAgICAgICAgICAgKGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50U3JjKHNyY0V2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcclxuICAgICAqL1xyXG4gICAgcHJldmVudFNyYzogZnVuY3Rpb24oc3JjRXZlbnQpIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQgPSB0cnVlO1xyXG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25zXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuZnVuY3Rpb24gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucykge1xyXG4gICAgLy8gbm9uZVxyXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xyXG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCk7XHJcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XHJcblxyXG4gICAgLy8gcGFuLXggYW5kIHBhbi15IGNhbiBiZSBjb21iaW5lZFxyXG4gICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xyXG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fUEFOX1ggKyAnICcgKyBUT1VDSF9BQ1RJT05fUEFOX1k7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcGFuLXggT1IgcGFuLXlcclxuICAgIGlmIChoYXNQYW5YIHx8IGhhc1BhblkpIHtcclxuICAgICAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBtYW5pcHVsYXRpb25cclxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OKSkge1xyXG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlY29nbml6ZXIgZmxvdyBleHBsYWluZWQ7ICpcclxuICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxyXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcclxuICogRXhhbXBsZSBzZXNzaW9uIGZvciBtb3VzZS1pbnB1dDogbW91c2Vkb3duIC0+IG1vdXNlbW92ZSAtPiBtb3VzZXVwXHJcbiAqXHJcbiAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcclxuICogd2hpY2ggZGV0ZXJtaW5lcyB3aXRoIHN0YXRlIGl0IHNob3VsZCBiZS5cclxuICpcclxuICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xyXG4gKiBQT1NTSUJMRSB0byBnaXZlIGl0IGFub3RoZXIgY2hhbmdlIG9uIHRoZSBuZXh0IGN5Y2xlLlxyXG4gKlxyXG4gKiAgICAgICAgICAgICAgIFBvc3NpYmxlXHJcbiAqICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXHJcbiAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICArLS0tLS0rLS0tLS0rICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XHJcbiAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tKy0tLS0tLStcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmRlZC9SZWNvZ25pemVkXHJcbiAqL1xyXG52YXIgU1RBVEVfUE9TU0lCTEUgPSAxO1xyXG52YXIgU1RBVEVfQkVHQU4gPSAyO1xyXG52YXIgU1RBVEVfQ0hBTkdFRCA9IDQ7XHJcbnZhciBTVEFURV9FTkRFRCA9IDg7XHJcbnZhciBTVEFURV9SRUNPR05JWkVEID0gU1RBVEVfRU5ERUQ7XHJcbnZhciBTVEFURV9DQU5DRUxMRUQgPSAxNjtcclxudmFyIFNUQVRFX0ZBSUxFRCA9IDMyO1xyXG5cclxuLyoqXHJcbiAqIFJlY29nbml6ZXJcclxuICogRXZlcnkgcmVjb2duaXplciBuZWVkcyB0byBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICovXHJcbmZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xyXG4gICAgdGhpcy5pZCA9IHVuaXF1ZUlkKCk7XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcclxuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMgfHwge30sIHRoaXMuZGVmYXVsdHMpO1xyXG5cclxuICAgIC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcclxuICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSBpZlVuZGVmaW5lZCh0aGlzLm9wdGlvbnMuZW5hYmxlLCB0cnVlKTtcclxuXHJcbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XHJcblxyXG4gICAgdGhpcy5zaW11bHRhbmVvdXMgPSB7fTtcclxuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcclxufVxyXG5cclxuUmVjb2duaXplci5wcm90b3R5cGUgPSB7XHJcbiAgICAvKipcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0czoge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4ge1JlY29nbml6ZXJ9XHJcbiAgICAgKi9cclxuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIGV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxyXG4gICAgICAgIHRoaXMubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgcmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XHJcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcclxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XHJcbiAgICAgICAgaWYgKCFzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSkge1xyXG4gICAgICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcclxuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlY29nbml6ZVdpdGgodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGRyb3AgdGhlIHNpbXVsdGFuZW91cyBsaW5rLiBpdCBkb2VzbnQgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIGRyb3BSZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcclxuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZWNvZ25pemVyIGNhbiBvbmx5IHJ1biB3aGVuIGFuIG90aGVyIGlzIGZhaWxpbmdcclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xyXG4gICAgICovXHJcbiAgICByZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XHJcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVxdWlyZUZhaWwgPSB0aGlzLnJlcXVpcmVGYWlsO1xyXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcclxuICAgICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmVxdWlyZUZhaWwucHVzaChvdGhlclJlY29nbml6ZXIpO1xyXG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGRyb3AgdGhlIHJlcXVpcmVGYWlsdXJlIGxpbmsuIGl0IGRvZXMgbm90IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xyXG4gICAgICovXHJcbiAgICBkcm9wUmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xyXG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcclxuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBoYXMgcmVxdWlyZSBmYWlsdXJlcyBib29sZWFuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgaGFzUmVxdWlyZUZhaWx1cmVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGlmIHRoZSByZWNvZ25pemVyIGNhbiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplclxyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBjYW5SZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFlvdSBzaG91bGQgdXNlIGB0cnlFbWl0YCBpbnN0ZWFkIG9mIGBlbWl0YCBkaXJlY3RseSB0byBjaGVja1xyXG4gICAgICogdGhhdCBhbGwgdGhlIG5lZWRlZCByZWNvZ25pemVycyBoYXMgZmFpbGVkIGJlZm9yZSBlbWl0dGluZy5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gICAgICovXHJcbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBlbWl0KHdpdGhTdGF0ZSkge1xyXG4gICAgICAgICAgICBzZWxmLm1hbmFnZXIuZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyAod2l0aFN0YXRlID8gc3RhdGVTdHIoc3RhdGUpIDogJycpLCBpbnB1dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAncGFuc3RhcnQnIGFuZCAncGFubW92ZSdcclxuICAgICAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xyXG4gICAgICAgICAgICBlbWl0KHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZW1pdCgpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXHJcblxyXG4gICAgICAgIC8vIHBhbmVuZCBhbmQgcGFuY2FuY2VsXHJcbiAgICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XHJcbiAgICAgICAgICAgIGVtaXQodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcclxuICAgICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcclxuICAgICAqIG90aGVyd2lzZSwgc2V0dXAgdGhlIHN0YXRlIHRvIEZBSUxFRC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gICAgICovXHJcbiAgICB0cnlFbWl0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaXQncyBmYWlsaW5nIGFueXdheVxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogY2FuIHdlIGVtaXQ/XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgY2FuRW1pdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKCEodGhpcy5yZXF1aXJlRmFpbFtpXS5zdGF0ZSAmIChTVEFURV9GQUlMRUQgfCBTVEFURV9QT1NTSUJMRSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB1cGRhdGUgdGhlIHJlY29nbml6ZXJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcclxuICAgICAqL1xyXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbihpbnB1dERhdGEpIHtcclxuICAgICAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxyXG4gICAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXHJcbiAgICAgICAgdmFyIGlucHV0RGF0YUNsb25lID0gZXh0ZW5kKHt9LCBpbnB1dERhdGEpO1xyXG5cclxuICAgICAgICAvLyBpcyBpcyBlbmFibGVkIGFuZCBhbGxvdyByZWNvZ25pemluZz9cclxuICAgICAgICBpZiAoIWJvb2xPckZuKHRoaXMub3B0aW9ucy5lbmFibGUsIFt0aGlzLCBpbnB1dERhdGFDbG9uZV0pKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVzZXQgd2hlbiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmRcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9SRUNPR05JWkVEIHwgU1RBVEVfQ0FOQ0VMTEVEIHwgU1RBVEVfRkFJTEVEKSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTtcclxuXHJcbiAgICAgICAgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXHJcbiAgICAgICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEIHwgU1RBVEVfQ0FOQ0VMTEVEKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm4gdGhlIHN0YXRlIG9mIHRoZSByZWNvZ25pemVyXHJcbiAgICAgKiB0aGUgYWN0dWFsIHJlY29nbml6aW5nIGhhcHBlbnMgaW4gdGhpcyBtZXRob2RcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXHJcbiAgICAgKiBAcmV0dXJucyB7Q29uc3R9IFNUQVRFXHJcbiAgICAgKi9cclxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0RGF0YSkgeyB9LCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybiB0aGUgcHJlZmVycmVkIHRvdWNoLWFjdGlvblxyXG4gICAgICogQHZpcnR1YWxcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkgeyB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcclxuICAgICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKi9cclxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHsgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIGdldCBhIHVzYWJsZSBzdHJpbmcsIHVzZWQgYXMgZXZlbnQgcG9zdGZpeFxyXG4gKiBAcGFyYW0ge0NvbnN0fSBzdGF0ZVxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcclxuICAgIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xyXG4gICAgICAgIHJldHVybiAnY2FuY2VsJztcclxuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9FTkRFRCkge1xyXG4gICAgICAgIHJldHVybiAnZW5kJztcclxuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9DSEFOR0VEKSB7XHJcbiAgICAgICAgcmV0dXJuICdtb3ZlJztcclxuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xyXG4gICAgICAgIHJldHVybiAnc3RhcnQnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcnO1xyXG59XHJcblxyXG4vKipcclxuICogZGlyZWN0aW9uIGNvbnMgdG8gc3RyaW5nXHJcbiAqIEBwYXJhbSB7Q29uc3R9IGRpcmVjdGlvblxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gZGlyZWN0aW9uU3RyKGRpcmVjdGlvbikge1xyXG4gICAgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTikge1xyXG4gICAgICAgIHJldHVybiAnZG93bic7XHJcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fVVApIHtcclxuICAgICAgICByZXR1cm4gJ3VwJztcclxuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9MRUZUKSB7XHJcbiAgICAgICAgcmV0dXJuICdsZWZ0JztcclxuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9SSUdIVCkge1xyXG4gICAgICAgIHJldHVybiAncmlnaHQnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcnO1xyXG59XHJcblxyXG4vKipcclxuICogZ2V0IGEgcmVjb2duaXplciBieSBuYW1lIGlmIGl0IGlzIGJvdW5kIHRvIGEgbWFuYWdlclxyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSBvdGhlclJlY29nbml6ZXJcclxuICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXHJcbiAqIEByZXR1cm5zIHtSZWNvZ25pemVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcclxuICAgIHZhciBtYW5hZ2VyID0gcmVjb2duaXplci5tYW5hZ2VyO1xyXG4gICAgaWYgKG1hbmFnZXIpIHtcclxuICAgICAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdGhlclJlY29nbml6ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBBdHRyUmVjb2duaXplcigpIHtcclxuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuaW5oZXJpdChBdHRyUmVjb2duaXplciwgUmVjb2duaXplciwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICAgKi9cclxuICAgICAgICBwb2ludGVyczogMVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gY2hlY2sgaWYgaXQgdGhlIHJlY29nbml6ZXIgcmVjZWl2ZXMgdmFsaWQgaW5wdXQsIGxpa2UgaW5wdXQuZGlzdGFuY2UgPiAxMC5cclxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmVjb2duaXplZFxyXG4gICAgICovXHJcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB2YXIgb3B0aW9uUG9pbnRlcnMgPSB0aGlzLm9wdGlvbnMucG9pbnRlcnM7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvblBvaW50ZXJzID09PSAwIHx8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9uUG9pbnRlcnM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXHJcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gICAgICogQHJldHVybnMgeyp9IFN0YXRlXHJcbiAgICAgKi9cclxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICB2YXIgZXZlbnRUeXBlID0gaW5wdXQuZXZlbnRUeXBlO1xyXG5cclxuICAgICAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcclxuICAgICAgICB2YXIgaXNWYWxpZCA9IHRoaXMuYXR0clRlc3QoaW5wdXQpO1xyXG5cclxuICAgICAgICAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXHJcbiAgICAgICAgaWYgKGlzUmVjb2duaXplZCAmJiAoZXZlbnRUeXBlICYgSU5QVVRfQ0FOQ0VMIHx8ICFpc1ZhbGlkKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DQU5DRUxMRUQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9FTkRFRDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogUGFuXHJcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGFuZCBtb3ZlZCBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxyXG4gKi9cclxuZnVuY3Rpb24gUGFuUmVjb2duaXplcigpIHtcclxuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5wWCA9IG51bGw7XHJcbiAgICB0aGlzLnBZID0gbnVsbDtcclxufVxyXG5cclxuaW5oZXJpdChQYW5SZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAbWVtYmVyb2YgUGFuUmVjb2duaXplclxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGV2ZW50OiAncGFuJyxcclxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxyXG4gICAgICAgIHBvaW50ZXJzOiAxLFxyXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0FMTFxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XHJcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcclxuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcclxuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhY3Rpb25zO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXJlY3Rpb25UZXN0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gaW5wdXQuZGlzdGFuY2U7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcclxuICAgICAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcclxuICAgICAgICB2YXIgeSA9IGlucHV0LmRlbHRhWTtcclxuXHJcbiAgICAgICAgLy8gbG9jayB0byBheGlzP1xyXG4gICAgICAgIGlmICghKGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uKSkge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHggPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XHJcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHggIT0gdGhpcy5wWDtcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFYKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh5ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHkgPCAwKSA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xyXG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB5ICE9IHRoaXMucFk7XHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xyXG4gICAgICAgIHJldHVybiBoYXNNb3ZlZCAmJiBkaXN0YW5jZSA+IG9wdGlvbnMudGhyZXNob2xkICYmIGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uO1xyXG4gICAgfSxcclxuXHJcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXHJcbiAgICAgICAgICAgICh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgKCEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcclxuICAgICAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xyXG5cclxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFBpbmNoXHJcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIoKSB7XHJcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5pbmhlcml0KFBpbmNoUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGV2ZW50OiAncGluY2gnLFxyXG4gICAgICAgIHRocmVzaG9sZDogMCxcclxuICAgICAgICBwb2ludGVyczogMlxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XHJcbiAgICB9LFxyXG5cclxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxyXG4gICAgICAgICAgICAoTWF0aC5hYnMoaW5wdXQuc2NhbGUgLSAxKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcclxuICAgIH0sXHJcblxyXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xyXG4gICAgICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xyXG4gICAgICAgICAgICB2YXIgaW5PdXQgPSBpbnB1dC5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCc7XHJcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0LCBpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBQcmVzc1xyXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBmb3IgeCBtcyB3aXRob3V0IGFueSBtb3ZlbWVudC5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcclxuICovXHJcbmZ1bmN0aW9uIFByZXNzUmVjb2duaXplcigpIHtcclxuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICB0aGlzLl90aW1lciA9IG51bGw7XHJcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XHJcbn1cclxuXHJcbmluaGVyaXQoUHJlc3NSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAqIEBtZW1iZXJvZiBQcmVzc1JlY29nbml6ZXJcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBldmVudDogJ3ByZXNzJyxcclxuICAgICAgICBwb2ludGVyczogMSxcclxuICAgICAgICB0aW1lOiA1MDAsIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXHJcbiAgICAgICAgdGhyZXNob2xkOiA1IC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9BVVRPXTtcclxuICAgIH0sXHJcblxyXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcclxuICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XHJcbiAgICAgICAgdmFyIHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcclxuXHJcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcclxuXHJcbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcclxuICAgICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXHJcbiAgICAgICAgaWYgKCF2YWxpZE1vdmVtZW50IHx8ICF2YWxpZFBvaW50ZXJzIHx8IChpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xyXG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWUsIHRoaXMpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcclxuICAgIH0sXHJcblxyXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaW5wdXQgJiYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkpIHtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgJ3VwJywgaW5wdXQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xyXG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFJvdGF0ZVxyXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcclxuICovXHJcbmZ1bmN0aW9uIFJvdGF0ZVJlY29nbml6ZXIoKSB7XHJcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5pbmhlcml0KFJvdGF0ZVJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAqIEBtZW1iZXJvZiBSb3RhdGVSZWNvZ25pemVyXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgZXZlbnQ6ICdyb3RhdGUnLFxyXG4gICAgICAgIHRocmVzaG9sZDogMCxcclxuICAgICAgICBwb2ludGVyczogMlxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XHJcbiAgICB9LFxyXG5cclxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxyXG4gICAgICAgICAgICAoTWF0aC5hYnMoaW5wdXQucm90YXRpb24pID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBTd2lwZVxyXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcclxuICovXHJcbmZ1bmN0aW9uIFN3aXBlUmVjb2duaXplcigpIHtcclxuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmluaGVyaXQoU3dpcGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAbWVtYmVyb2YgU3dpcGVSZWNvZ25pemVyXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgZXZlbnQ6ICdzd2lwZScsXHJcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcclxuICAgICAgICB2ZWxvY2l0eTogMC42NSxcclxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxyXG4gICAgICAgIHBvaW50ZXJzOiAxXHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gUGFuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0VG91Y2hBY3Rpb24uY2FsbCh0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XHJcbiAgICAgICAgdmFyIHZlbG9jaXR5O1xyXG5cclxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgKERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xyXG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0LnZlbG9jaXR5O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcclxuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC52ZWxvY2l0eVg7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcclxuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC52ZWxvY2l0eVk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcclxuICAgICAgICAgICAgZGlyZWN0aW9uICYgaW5wdXQuZGlyZWN0aW9uICYmXHJcbiAgICAgICAgICAgIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJlxyXG4gICAgICAgICAgICBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcclxuICAgIH0sXHJcblxyXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBBIHRhcCBpcyBlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXHJcbiAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xyXG4gKiBhIHNpbmdsZSB0YXAuXHJcbiAqXHJcbiAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxyXG4gKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBUYXBSZWNvZ25pemVyKCkge1xyXG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcclxuICAgIC8vIHVzZWQgZm9yIHRhcCBjb3VudGluZ1xyXG4gICAgdGhpcy5wVGltZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5wQ2VudGVyID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xyXG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xyXG4gICAgdGhpcy5jb3VudCA9IDA7XHJcbn1cclxuXHJcbmluaGVyaXQoVGFwUmVjb2duaXplciwgUmVjb2duaXplciwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgZXZlbnQ6ICd0YXAnLFxyXG4gICAgICAgIHBvaW50ZXJzOiAxLFxyXG4gICAgICAgIHRhcHM6IDEsXHJcbiAgICAgICAgaW50ZXJ2YWw6IDMwMCwgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcclxuICAgICAgICB0aW1lOiAyNTAsIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXHJcbiAgICAgICAgdGhyZXNob2xkOiAyLCAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xyXG4gICAgICAgIHBvc1RocmVzaG9sZDogMTAgLy8gYSBtdWx0aS10YXAgY2FuIGJlIGEgYml0IG9mZiB0aGUgaW5pdGlhbCBwb3NpdGlvblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OXTtcclxuICAgIH0sXHJcblxyXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XHJcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xyXG4gICAgICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG5cclxuICAgICAgICBpZiAoKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSAmJiAodGhpcy5jb3VudCA9PT0gMCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XHJcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxyXG4gICAgICAgIGlmICh2YWxpZE1vdmVtZW50ICYmIHZhbGlkVG91Y2hUaW1lICYmIHZhbGlkUG9pbnRlcnMpIHtcclxuICAgICAgICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9FTkQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IChpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCkgOiB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgdmFsaWRNdWx0aVRhcCA9ICF0aGlzLnBDZW50ZXIgfHwgZ2V0RGlzdGFuY2UodGhpcy5wQ2VudGVyLCBpbnB1dC5jZW50ZXIpIDwgb3B0aW9ucy5wb3NUaHJlc2hvbGQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xyXG4gICAgICAgICAgICB0aGlzLnBDZW50ZXIgPSBpbnB1dC5jZW50ZXI7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxyXG4gICAgICAgICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxyXG4gICAgICAgICAgICB2YXIgdGFwQ291bnQgPSB0aGlzLmNvdW50ICUgb3B0aW9ucy50YXBzO1xyXG4gICAgICAgICAgICBpZiAodGFwQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcclxuICAgICAgICAgICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmludGVydmFsLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcclxuICAgIH0sXHJcblxyXG4gICAgZmFpbFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XHJcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsLCB0aGlzKTtcclxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcclxuICAgIH0sXHJcblxyXG4gICAgZW1pdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT0gU1RBVEVfUkVDT0dOSVpFRCApIHtcclxuICAgICAgICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xyXG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFNpbXBsZSB3YXkgdG8gY3JlYXRlIGFuIG1hbmFnZXIgd2l0aCBhIGRlZmF1bHQgc2V0IG9mIHJlY29nbml6ZXJzLlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBvcHRpb25zLnJlY29nbml6ZXJzID0gaWZVbmRlZmluZWQob3B0aW9ucy5yZWNvZ25pemVycywgSGFtbWVyLmRlZmF1bHRzLnByZXNldCk7XHJcbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAY29uc3Qge3N0cmluZ31cclxuICovXHJcbkhhbW1lci5WRVJTSU9OID0gJzIuMC40JztcclxuXHJcbi8qKlxyXG4gKiBkZWZhdWx0IHNldHRpbmdzXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbkhhbW1lci5kZWZhdWx0cyA9IHtcclxuICAgIC8qKlxyXG4gICAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cclxuICAgICAqIEJ1dCB0aGlzIGlzIHNsb3dlciBhbmQgdW51c2VkIGJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbnMsIHNvIGRpc2FibGVkIGJ5IGRlZmF1bHQuXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIGRvbUV2ZW50czogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eS9mYWxsYmFjay5cclxuICAgICAqIFdoZW4gc2V0IHRvIGBjb21wdXRlYCBpdCB3aWxsIG1hZ2ljYWxseSBzZXQgdGhlIGNvcnJlY3QgdmFsdWUgYmFzZWQgb24gdGhlIGFkZGVkIHJlY29nbml6ZXJzLlxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0IGNvbXB1dGVcclxuICAgICAqL1xyXG4gICAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKi9cclxuICAgIGVuYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVYUEVSSU1FTlRBTCBGRUFUVVJFIC0tIGNhbiBiZSByZW1vdmVkL2NoYW5nZWRcclxuICAgICAqIENoYW5nZSB0aGUgcGFyZW50IGlucHV0IHRhcmdldCBlbGVtZW50LlxyXG4gICAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cclxuICAgICAqIEB0eXBlIHtOdWxsfEV2ZW50VGFyZ2V0fVxyXG4gICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICovXHJcbiAgICBpbnB1dFRhcmdldDogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXHJcbiAgICAgKiBAdHlwZSB7TnVsbHxGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqL1xyXG4gICAgaW5wdXRDbGFzczogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgcmVjb2duaXplciBzZXR1cCB3aGVuIGNhbGxpbmcgYEhhbW1lcigpYFxyXG4gICAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgcHJlc2V0OiBbXHJcbiAgICAgICAgLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXHJcbiAgICAgICAgW1JvdGF0ZVJlY29nbml6ZXIsIHsgZW5hYmxlOiBmYWxzZSB9XSxcclxuICAgICAgICBbUGluY2hSZWNvZ25pemVyLCB7IGVuYWJsZTogZmFsc2UgfSwgWydyb3RhdGUnXV0sXHJcbiAgICAgICAgW1N3aXBlUmVjb2duaXplcix7IGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfV0sXHJcbiAgICAgICAgW1BhblJlY29nbml6ZXIsIHsgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB9LCBbJ3N3aXBlJ11dLFxyXG4gICAgICAgIFtUYXBSZWNvZ25pemVyXSxcclxuICAgICAgICBbVGFwUmVjb2duaXplciwgeyBldmVudDogJ2RvdWJsZXRhcCcsIHRhcHM6IDIgfSwgWyd0YXAnXV0sXHJcbiAgICAgICAgW1ByZXNzUmVjb2duaXplcl1cclxuICAgIF0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxyXG4gICAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICovXHJcbiAgICBjc3NQcm9wczoge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cclxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcclxuICAgICAgICAgKi9cclxuICAgICAgICB0b3VjaFNlbGVjdDogJ25vbmUnLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgZGVmYXVsdCBjYWxsb3V0IHNob3duIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0LlxyXG4gICAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xyXG4gICAgICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcclxuICAgICAgICAgKi9cclxuICAgICAgICB0b3VjaENhbGxvdXQ6ICdub25lJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgem9vbWluZyBpcyBlbmFibGVkLiBVc2VkIGJ5IElFMTA+XHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcclxuICAgICAgICAgKi9cclxuICAgICAgICB1c2VyRHJhZzogJ25vbmUnLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxyXG4gICAgICAgICAqIGNsaWNrYWJsZSBlbGVtZW50IGluIGlPUy4gVGhpcyBwcm9wZXJ0eSBvYmV5cyB0aGUgYWxwaGEgdmFsdWUsIGlmIHNwZWNpZmllZC5cclxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBTVE9QID0gMTtcclxudmFyIEZPUkNFRF9TVE9QID0gMjtcclxuXHJcbi8qKlxyXG4gKiBNYW5hZ2VyXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2Uob3B0aW9ucywgSGFtbWVyLmRlZmF1bHRzKTtcclxuICAgIHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCA9IHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCB8fCBlbGVtZW50O1xyXG5cclxuICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcclxuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xyXG4gICAgdGhpcy5yZWNvZ25pemVycyA9IFtdO1xyXG5cclxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcclxuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcclxuXHJcbiAgICB0b2dnbGVDc3NQcm9wcyh0aGlzLCB0cnVlKTtcclxuXHJcbiAgICBlYWNoKG9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMuYWRkKG5ldyAoaXRlbVswXSkoaXRlbVsxXSkpO1xyXG4gICAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xyXG4gICAgICAgIGl0ZW1bM10gJiYgcmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShpdGVtWzNdKTtcclxuICAgIH0sIHRoaXMpO1xyXG59XHJcblxyXG5NYW5hZ2VyLnByb3RvdHlwZSA9IHtcclxuICAgIC8qKlxyXG4gICAgICogc2V0IG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cclxuICAgICAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIC8vIE9wdGlvbnMgdGhhdCBuZWVkIGEgbGl0dGxlIG1vcmUgc2V0dXBcclxuICAgICAgICBpZiAob3B0aW9ucy50b3VjaEFjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5pbnB1dFRhcmdldCkge1xyXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYW5kIHJlaW5pdGlhbGl6ZVxyXG4gICAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC50YXJnZXQgPSBvcHRpb25zLmlucHV0VGFyZ2V0O1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0LmluaXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxyXG4gICAgICogVGhpcyBzZXNzaW9uIHdpbGwgYmUgZGlzY2FyZGVkLCB3aGVuIGEgbmV3IFtpbnB1dF1zdGFydCBldmVudCBpcyBmaXJlZC5cclxuICAgICAqIFdoZW4gZm9yY2VkLCB0aGUgcmVjb2duaXplciBjeWNsZSBpcyBzdG9wcGVkIGltbWVkaWF0ZWx5LlxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXHJcbiAgICAgKi9cclxuICAgIHN0b3A6IGZ1bmN0aW9uKGZvcmNlKSB7XHJcbiAgICAgICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBydW4gdGhlIHJlY29nbml6ZXJzIVxyXG4gICAgICogY2FsbGVkIGJ5IHRoZSBpbnB1dEhhbmRsZXIgZnVuY3Rpb24gb24gZXZlcnkgbW92ZW1lbnQgb2YgdGhlIHBvaW50ZXJzICh0b3VjaGVzKVxyXG4gICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXHJcbiAgICAgKi9cclxuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XHJcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XHJcbiAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxyXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24ucHJldmVudERlZmF1bHRzKGlucHV0RGF0YSk7XHJcblxyXG4gICAgICAgIHZhciByZWNvZ25pemVyO1xyXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XHJcblxyXG4gICAgICAgIC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxyXG4gICAgICAgIC8vIHNvIHRoZSByZWNvZ25pemVyJ3Mgc3RhdGUgbmVlZHMgdG8gYmUgQkVHQU4sIENIQU5HRUQsIEVOREVEIG9yIFJFQ09HTklaRURcclxuICAgICAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXHJcbiAgICAgICAgdmFyIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXI7XHJcblxyXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gdGhlIGxhc3QgcmVjb2duaXplciBpcyByZWNvZ25pemVkXHJcbiAgICAgICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXHJcbiAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyIHx8IChjdXJSZWNvZ25pemVyICYmIGN1clJlY29nbml6ZXIuc3RhdGUgJiBTVEFURV9SRUNPR05JWkVEKSkge1xyXG4gICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07XHJcblxyXG4gICAgICAgICAgICAvLyBmaW5kIG91dCBpZiB3ZSBhcmUgYWxsb3dlZCB0cnkgdG8gcmVjb2duaXplIHRoZSBpbnB1dCBmb3IgdGhpcyBvbmUuXHJcbiAgICAgICAgICAgIC8vIDEuICAgYWxsb3cgaWYgdGhlIHNlc3Npb24gaXMgTk9UIGZvcmNlZCBzdG9wcGVkIChzZWUgdGhlIC5zdG9wKCkgbWV0aG9kKVxyXG4gICAgICAgICAgICAvLyAyLiAgIGFsbG93IGlmIHdlIHN0aWxsIGhhdmVuJ3QgcmVjb2duaXplZCBhIGdlc3R1cmUgaW4gdGhpcyBzZXNzaW9uLCBvciB0aGUgdGhpcyByZWNvZ25pemVyIGlzIHRoZSBvbmVcclxuICAgICAgICAgICAgLy8gICAgICB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXHJcbiAgICAgICAgICAgIC8vIDMuICAgYWxsb3cgaWYgdGhlIHJlY29nbml6ZXIgaXMgYWxsb3dlZCB0byBydW4gc2ltdWx0YW5lb3VzIHdpdGggdGhlIGN1cnJlbnQgcmVjb2duaXplZCByZWNvZ25pemVyLlxyXG4gICAgICAgICAgICAvLyAgICAgIHRoaXMgY2FuIGJlIHNldHVwIHdpdGggdGhlIGByZWNvZ25pemVXaXRoKClgIG1ldGhvZCBvbiB0aGUgcmVjb2duaXplci5cclxuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXHJcbiAgICAgICAgICAgICAgICAgICAgIWN1clJlY29nbml6ZXIgfHwgcmVjb2duaXplciA9PSBjdXJSZWNvZ25pemVyIHx8IC8vIDJcclxuICAgICAgICAgICAgICAgICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7IC8vIDNcclxuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSByZWNvZ25pemVyIGhhcyBiZWVuIHJlY29nbml6aW5nIHRoZSBpbnB1dCBhcyBhIHZhbGlkIGdlc3R1cmUsIHdlIHdhbnQgdG8gc3RvcmUgdGhpcyBvbmUgYXMgdGhlXHJcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxyXG4gICAgICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgJiYgcmVjb2duaXplci5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCkpIHtcclxuICAgICAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XHJcbiAgICAgKi9cclxuICAgIGdldDogZnVuY3Rpb24ocmVjb2duaXplcikge1xyXG4gICAgICAgIGlmIChyZWNvZ25pemVyIGluc3RhbmNlb2YgUmVjb2duaXplcikge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocmVjb2duaXplcnNbaV0ub3B0aW9ucy5ldmVudCA9PSByZWNvZ25pemVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogYWRkIGEgcmVjb2duaXplciB0byB0aGUgbWFuYWdlclxyXG4gICAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxNYW5hZ2VyfVxyXG4gICAgICovXHJcbiAgICBhZGQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcclxuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ2FkZCcsIHRoaXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXHJcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQocmVjb2duaXplci5vcHRpb25zLmV2ZW50KTtcclxuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZXhpc3RpbmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nbml6ZXIpO1xyXG4gICAgICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XHJcblxyXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XHJcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XHJcbiAgICAgICAgcmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpO1xyXG4gICAgICAgIHJlY29nbml6ZXJzLnNwbGljZShpbkFycmF5KHJlY29nbml6ZXJzLCByZWNvZ25pemVyKSwgMSk7XHJcblxyXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogYmluZCBldmVudFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxyXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xyXG4gICAgICovXHJcbiAgICBvbjogZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcclxuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJzW2V2ZW50XSB8fCBbXTtcclxuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXVxyXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xyXG4gICAgICovXHJcbiAgICBvZmY6IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XHJcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyc1tldmVudF0uc3BsaWNlKGluQXJyYXkoaGFuZGxlcnNbZXZlbnRdLCBoYW5kbGVyKSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuICAgICAqL1xyXG4gICAgZW1pdDogZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcclxuICAgICAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gdHJpZ2dlciBkb20gZXZlbnRzXHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcclxuICAgICAgICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxyXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuaGFuZGxlcnNbZXZlbnRdLnNsaWNlKCk7XHJcbiAgICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRhdGEudHlwZSA9IGV2ZW50O1xyXG4gICAgICAgIGRhdGEucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyc1tpXShkYXRhKTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcclxuICAgICAqIGl0IGRvZXNuJ3QgdW5iaW5kIGRvbSBldmVudHMsIHRoYXQgaXMgdGhlIHVzZXIgb3duIHJlc3BvbnNpYmlsaXR5XHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcclxuICAgICAgICB0aGlzLnNlc3Npb24gPSB7fTtcclxuICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXHJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFkZFxyXG4gKi9cclxuZnVuY3Rpb24gdG9nZ2xlQ3NzUHJvcHMobWFuYWdlciwgYWRkKSB7XHJcbiAgICB2YXIgZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcclxuICAgIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGVbcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSldID0gYWRkID8gdmFsdWUgOiAnJztcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogdHJpZ2dlciBkb20gZXZlbnRcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpIHtcclxuICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxuICAgIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xyXG4gICAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xyXG4gICAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xyXG59XHJcblxyXG5leHRlbmQoSGFtbWVyLCB7XHJcbiAgICBJTlBVVF9TVEFSVDogSU5QVVRfU1RBUlQsXHJcbiAgICBJTlBVVF9NT1ZFOiBJTlBVVF9NT1ZFLFxyXG4gICAgSU5QVVRfRU5EOiBJTlBVVF9FTkQsXHJcbiAgICBJTlBVVF9DQU5DRUw6IElOUFVUX0NBTkNFTCxcclxuXHJcbiAgICBTVEFURV9QT1NTSUJMRTogU1RBVEVfUE9TU0lCTEUsXHJcbiAgICBTVEFURV9CRUdBTjogU1RBVEVfQkVHQU4sXHJcbiAgICBTVEFURV9DSEFOR0VEOiBTVEFURV9DSEFOR0VELFxyXG4gICAgU1RBVEVfRU5ERUQ6IFNUQVRFX0VOREVELFxyXG4gICAgU1RBVEVfUkVDT0dOSVpFRDogU1RBVEVfUkVDT0dOSVpFRCxcclxuICAgIFNUQVRFX0NBTkNFTExFRDogU1RBVEVfQ0FOQ0VMTEVELFxyXG4gICAgU1RBVEVfRkFJTEVEOiBTVEFURV9GQUlMRUQsXHJcblxyXG4gICAgRElSRUNUSU9OX05PTkU6IERJUkVDVElPTl9OT05FLFxyXG4gICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxyXG4gICAgRElSRUNUSU9OX1JJR0hUOiBESVJFQ1RJT05fUklHSFQsXHJcbiAgICBESVJFQ1RJT05fVVA6IERJUkVDVElPTl9VUCxcclxuICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcclxuICAgIERJUkVDVElPTl9IT1JJWk9OVEFMOiBESVJFQ1RJT05fSE9SSVpPTlRBTCxcclxuICAgIERJUkVDVElPTl9WRVJUSUNBTDogRElSRUNUSU9OX1ZFUlRJQ0FMLFxyXG4gICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcclxuXHJcbiAgICBNYW5hZ2VyOiBNYW5hZ2VyLFxyXG4gICAgSW5wdXQ6IElucHV0LFxyXG4gICAgVG91Y2hBY3Rpb246IFRvdWNoQWN0aW9uLFxyXG5cclxuICAgIFRvdWNoSW5wdXQ6IFRvdWNoSW5wdXQsXHJcbiAgICBNb3VzZUlucHV0OiBNb3VzZUlucHV0LFxyXG4gICAgUG9pbnRlckV2ZW50SW5wdXQ6IFBvaW50ZXJFdmVudElucHV0LFxyXG4gICAgVG91Y2hNb3VzZUlucHV0OiBUb3VjaE1vdXNlSW5wdXQsXHJcbiAgICBTaW5nbGVUb3VjaElucHV0OiBTaW5nbGVUb3VjaElucHV0LFxyXG5cclxuICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXHJcbiAgICBBdHRyUmVjb2duaXplcjogQXR0clJlY29nbml6ZXIsXHJcbiAgICBUYXA6IFRhcFJlY29nbml6ZXIsXHJcbiAgICBQYW46IFBhblJlY29nbml6ZXIsXHJcbiAgICBTd2lwZTogU3dpcGVSZWNvZ25pemVyLFxyXG4gICAgUGluY2g6IFBpbmNoUmVjb2duaXplcixcclxuICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcclxuICAgIFByZXNzOiBQcmVzc1JlY29nbml6ZXIsXHJcblxyXG4gICAgb246IGFkZEV2ZW50TGlzdGVuZXJzLFxyXG4gICAgb2ZmOiByZW1vdmVFdmVudExpc3RlbmVycyxcclxuICAgIGVhY2g6IGVhY2gsXHJcbiAgICBtZXJnZTogbWVyZ2UsXHJcbiAgICBleHRlbmQ6IGV4dGVuZCxcclxuICAgIGluaGVyaXQ6IGluaGVyaXQsXHJcbiAgICBiaW5kRm46IGJpbmRGbixcclxuICAgIHByZWZpeGVkOiBwcmVmaXhlZFxyXG59KTtcclxuXHJcbmlmICh0eXBlb2YgZGVmaW5lID09IFRZUEVfRlVOQ1RJT04gJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBIYW1tZXI7XHJcbiAgICB9KTtcclxufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhhbW1lcjtcclxufSBlbHNlIHtcclxuICAgIHdpbmRvd1tleHBvcnROYW1lXSA9IEhhbW1lcjtcclxufVxyXG5cclxufSkod2luZG93LCBkb2N1bWVudCwgJ0hhbW1lcicpO1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIE1pbmltYWxpc3RpYyBldmVudCBlbWl0dGVyIG1peGluLlxuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7fVxuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudC4gSWYgdGhlIGxpc3RlbmVyIGhhc1xuICogYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgZm9yIHRoZSBldmVudCwgdGhpcyBpcyBhIG5vLW9wLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihuYW1lLCBmbikge1xuICB2YXIgZXZlbnRNYXAgPSB0aGlzLl9fZXZlbnRzID0gdGhpcy5fX2V2ZW50cyB8fCB7fTtcbiAgdmFyIGhhbmRsZXJMaXN0ID0gZXZlbnRNYXBbbmFtZV0gPSBldmVudE1hcFtuYW1lXSB8fCBbXTtcbiAgaWYgKGhhbmRsZXJMaXN0LmluZGV4T2YoZm4pIDwgMCkge1xuICAgIGhhbmRsZXJMaXN0LnB1c2goZm4pO1xuICB9XG59O1xuXG4vKipcbiAqIFVucmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlIHNwZWNpZmllZCBldmVudC4gSWYgdGhlIGxpc3RlbmVyXG4gKiBoYXNuJ3QgYmVlbiByZWdpc3RlcmVkIGZvciB0aGUgZXZlbnQsIHRoaXMgaXMgYSBuby1vcC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgdmFyIGV2ZW50TWFwID0gdGhpcy5fX2V2ZW50cyA9IHRoaXMuX19ldmVudHMgfHwge307XG4gIHZhciBoYW5kbGVyTGlzdCA9IGV2ZW50TWFwW25hbWVdO1xuICBpZiAoaGFuZGxlckxpc3QpIHtcbiAgICB2YXIgaW5kZXggPSBoYW5kbGVyTGlzdC5pbmRleE9mKGZuKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgaGFuZGxlckxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRW1pdHMgYW4gZXZlbnQsIGNhdXNpbmcgYWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGF0IGV2ZW50IHRvIGJlXG4gKiBjYWxsZWQgaW4gcmVnaXN0cmF0aW9uIG9yZGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBcmd1bWVudHMgdG8gY2FsbCBsaXN0ZW5lcnMgd2l0aC5cbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24obmFtZSwgdmFyX2FyZ3MpIHtcbiAgdmFyIGV2ZW50TWFwID0gdGhpcy5fX2V2ZW50cyA9IHRoaXMuX19ldmVudHMgfHwge307XG4gIHZhciBoYW5kbGVyTGlzdCA9IGV2ZW50TWFwW25hbWVdO1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIGlmIChoYW5kbGVyTGlzdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmbiA9IGhhbmRsZXJMaXN0W2ldO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1peGVzIGluIHtAbGluayBFdmVudEVtaXR0ZXJ9IGludG8gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZXZlbnRFbWl0dGVyKGN0b3IpIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBFdmVudEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgaWYgKEV2ZW50RW1pdHRlci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGN0b3IucHJvdG90eXBlW3Byb3BdID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZVtwcm9wXTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBldmVudEVtaXR0ZXI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBwb3NpdGlvbkFic29sdXRlbHkgPSByZXF1aXJlKCcuL3V0aWwvcG9zaXRpb25BYnNvbHV0ZWx5Jyk7XG52YXIgc2V0VHJhbnNmb3JtID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldFRyYW5zZm9ybTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogQGNsYXNzIEhvdHNwb3RcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIEhvdHNwb3QgYWxsb3dzIGEgRE9NIGVsZW1lbnQgdG8gYmUgcGxhY2VkIGF0IGEgZml4ZWQgcG9zaXRpb24gaW4gdGhlXG4gKiBpbWFnZS4gVGhlIHBvc2l0aW9uIGlzIHVwZGF0ZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSB7QGxpbmsgVmlldyB2aWV3fVxuICogY2hhbmdlcy5cbiAqXG4gKiBQb3NpdGlvbmluZyBpcyBwZXJmb3JtZWQgd2l0aCB0aGUgYHRyYW5zZm9ybWAgQ1NTIHByb3BlcnR5IHdoZW4gYXZhaWxhYmxlLFxuICogZmFsbGluZyBiYWNrIHRvIHRoZSBgcG9zaXRpb25gLCBgbGVmdGAgYW5kIGB0b3BgIHByb3BlcnRpZXMgd2hlbiBub3QuXG4gKiBJbiBib3RoIGNhc2VzLCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBlbGVtZW50IGlzIHBsYWNlZCBpbiB0aGUgcmVxdWVzdGVkXG4gKiBwb3NpdGlvbjsgY2xpZW50cyBhcmUgZXhwZWN0ZWQgdG8gdXNlIGFkZGl0aW9uYWwgY2hpbGRyZW4gZWxlbWVudHMgb3Igb3RoZXJcbiAqIENTUyBwcm9wZXJ0aWVzIHRvIGFjaGlldmUgbW9yZSBzb3BoaXN0aWNhdGVkIGxheW91dHMuXG4gKlxuICogVGhlcmUgYXJlIHR3byBraW5kcyBvZiBob3RzcG90czogcmVndWxhciBhbmQgZW1iZWRkZWQuIEEgcmVndWxhciBob3RzcG90XG4gKiBkb2VzIG5vdCBjaGFuZ2Ugc2l6ZSBkZXBlbmRpbmcgb24gdGhlIHpvb20gbGV2ZWwuIEFuIGVtYmVkZGVkIGhvdHNwb3QgaXNcbiAqIGRpc3BsYXllZCBhdCBhIGZpeGVkIHNpemUgcmVsYXRpdmUgdG8gdGhlIHBhbm9yYW1hLCBhbHdheXMgY292ZXJpbmcgdGhlXG4gKiBzYW1lIHBvcnRpb24gb2YgdGhlIGltYWdlLlxuICpcbiAqIENsaWVudHMgc2hvdWxkIGNhbGwge0BsaW5rIEhvdHNwb3RDb250YWluZXIjY3JlYXRlSG90c3BvdH0gaW5zdGVhZCBvZlxuICogaW52b2tpbmcgdGhlIGNvbnN0cnVjdG9yIGRpcmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tRWxlbWVudCBUaGUgRE9NIGVsZW1lbnQuXG4gKiBAcGFyYW0ge1ZpZXd9IHZpZXcgVGhlIHZpZXcuXG4gKiBAcGFyYW0ge09iamVjdH0gY29vcmRzIFRoZSBob3RzcG90IGNvb3JkaW5hdGVzLlxuICogICAgIFVzZSB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3Q29vcmRzfSBmb3IgYSB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3fSBvclxuICogICAgIHtAbGluayBGbGF0Vmlld0Nvb3Jkc30gZm9yIGEge0BsaW5rIEZsYXRWaWV3fS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnBlcnNwZWN0aXZlIFBlcnNwZWN0aXZlIG9wdGlvbnMgZm9yIGVtYmVkZGVkIGhvdHNwb3RzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnBlcnNwZWN0aXZlLnJhZGl1cz1udWxsXSBJZiBzZXQsIGVtYmVkIHRoZSBob3RzcG90XG4gKiAgICAgaW50byB0aGUgaW1hZ2UgYnkgdHJhbnNmb3JtaW5nIGl0IGludG8gdGhlIHN1cmZhY2Ugb2YgYSBzcGhlcmUgd2l0aCB0aGlzXG4gKiAgICAgcmFkaXVzLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnBlcnNwZWN0aXZlLmV4dHJhVHJhbnNmb3Jtcz1udWxsXSBJZiBzZXQsIGFwcGVuZCB0aGlzXG4gKiAgICAgdmFsdWUgdG8gdGhlIENTUyBgdHJhbnNmb3JtYCBwcm9wZXJ0eSB1c2VkIHRvIHBvc2l0aW9uIHRoZSBob3RzcG90LiBUaGlzXG4gKiAgICAgbWF5IGJlIHVzZWQgdG8gcm90YXRlIGFuIGVtYmVkZGVkIGhvdHNwb3QuXG4gKi9cbmZ1bmN0aW9uIEhvdHNwb3QoZG9tRWxlbWVudCwgcGFyZW50RG9tRWxlbWVudCwgdmlldywgY29vcmRzLCBvcHRzKSB7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMucGVyc3BlY3RpdmUgPSBvcHRzLnBlcnNwZWN0aXZlIHx8IHt9O1xuICBvcHRzLnBlcnNwZWN0aXZlLmV4dHJhVHJhbnNmb3JtcyA9XG4gICAgICBvcHRzLnBlcnNwZWN0aXZlLmV4dHJhVHJhbnNmb3JtcyAhPSBudWxsID8gb3B0cy5wZXJzcGVjdGl2ZS5leHRyYVRyYW5zZm9ybXMgOiBcIlwiO1xuXG4gIHRoaXMuX2RvbUVsZW1lbnQgPSBkb21FbGVtZW50O1xuICB0aGlzLl9wYXJlbnREb21FbGVtZW50ID0gcGFyZW50RG9tRWxlbWVudDtcbiAgdGhpcy5fdmlldyA9IHZpZXc7XG4gIHRoaXMuX2Nvb3JkcyA9IHt9O1xuICB0aGlzLl9wZXJzcGVjdGl2ZSA9IHt9O1xuXG4gIHRoaXMuc2V0UG9zaXRpb24oY29vcmRzKTtcblxuICAvLyBBZGQgaG90c3BvdCBpbnRvIHRoZSBET00uXG4gIHRoaXMuX3BhcmVudERvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fZG9tRWxlbWVudCk7XG5cbiAgdGhpcy5zZXRQZXJzcGVjdGl2ZShvcHRzLnBlcnNwZWN0aXZlKTtcblxuICAvLyBXaGV0aGVyIHRoZSBob3RzcG90IGlzIHZpc2libGUuXG4gIC8vIFRoZSBob3RzcG90IG1heSBzdGlsbCBiZSBoaWRkZW4gaWYgaXQncyBpbnNpZGUgYSBoaWRkZW4gSG90c3BvdENvbnRhaW5lci5cbiAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG5cbiAgLy8gVGhlIGN1cnJlbnQgY2FsY3VsYXRlZCBzY3JlZW4gcG9zaXRpb24uXG4gIHRoaXMuX3Bvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG59XG5cbmV2ZW50RW1pdHRlcihIb3RzcG90KTtcblxuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKiBDbGllbnRzIHNob3VsZCBjYWxsIHtAbGluayBIb3RzcG90Q29udGFpbmVyI2Rlc3Ryb3lIb3RzcG90fSBpbnN0ZWFkLlxuICovXG5Ib3RzcG90LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3BhcmVudERvbUVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5fZG9tRWxlbWVudCk7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5Ib3RzcG90LnByb3RvdHlwZS5kb21FbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9kb21FbGVtZW50O1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuSG90c3BvdC5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Nvb3Jkcztcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gY29vcmRzXG4gKi9cbkhvdHNwb3QucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24oY29vcmRzKSB7XG4gIGZvciAodmFyIGtleSBpbiBjb29yZHMpIHtcbiAgICB0aGlzLl9jb29yZHNba2V5XSA9IGNvb3Jkc1trZXldO1xuICB9XG4gIHRoaXMuX3VwZGF0ZSgpO1xuICAvLyBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgZW1pdCBhIGhvdHNwb3RzQ2hhbmdlIGV2ZW50IG9uIHRoZSBwYXJlbnRcbiAgLy8gSG90c3BvdENvbnRhaW5lci4gV2hhdCdzIHRoZSBiZXN0IHdheSB0byBkbyBzbz9cbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkhvdHNwb3QucHJvdG90eXBlLnBlcnNwZWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9wZXJzcGVjdGl2ZTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqL1xuSG90c3BvdC5wcm90b3R5cGUuc2V0UGVyc3BlY3RpdmUgPSBmdW5jdGlvbihwZXJzcGVjdGl2ZSkge1xuICBmb3IgKHZhciBrZXkgaW4gcGVyc3BlY3RpdmUpIHtcbiAgICB0aGlzLl9wZXJzcGVjdGl2ZVtrZXldID0gcGVyc3BlY3RpdmVba2V5XTtcbiAgfVxuICB0aGlzLl91cGRhdGUoKTtcbn07XG5cblxuLyoqXG4gKiBTaG93IHRoZSBob3RzcG90XG4gKi9cbkhvdHNwb3QucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl92aXNpYmxlKSB7XG4gICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBIaWRlIHRoZSBob3RzcG90XG4gKi9cbkhvdHNwb3QucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3Zpc2libGUpIHtcbiAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbn07XG5cblxuSG90c3BvdC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZWxlbWVudCA9IHRoaXMuX2RvbUVsZW1lbnQ7XG5cbiAgdmFyIHBhcmFtcyA9IHRoaXMuX2Nvb3JkcztcbiAgdmFyIHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb247XG4gIHZhciB4LCB5O1xuXG4gIHZhciBpc1Zpc2libGUgPSBmYWxzZTtcblxuICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgIHZhciB2aWV3ID0gdGhpcy5fdmlldztcblxuICAgIGlmICh0aGlzLl9wZXJzcGVjdGl2ZS5yYWRpdXMpIHtcbiAgICAgIC8vIEhvdHNwb3RzIHRoYXQgYXJlIGVtYmVkZGVkIGluIHRoZSBwYW5vcmFtYSBtYXkgYmUgdmlzaWJsZSBldmVuIHdoZW5cbiAgICAgIC8vIHBvc2l0aW9uZWQgYmVoaW5kIHRoZSBjYW1lcmEuXG4gICAgICBpc1Zpc2libGUgPSB0cnVlO1xuICAgICAgdGhpcy5fc2V0RW1iZWRkZWRQb3NpdGlvbih2aWV3LCBwYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWd1bGFyIGhvdHNwb3RzIGFyZSBvbmx5IHZpc2libGUgd2hlbiBwb3NpdGlvbmVkIGluIGZyb250IG9mIHRoZVxuICAgICAgLy8gY2FtZXJhLiBOb3RlIHRoYXQgdGhleSBtYXkgYmUgcGFydGlhbGx5IHZpc2libGUgd2hlbiBwb3NpdGlvbmVkIG91dHNpZGVcbiAgICAgIC8vIHRoZSB2aWV3cG9ydC5cbiAgICAgIHZpZXcuY29vcmRpbmF0ZXNUb1NjcmVlbihwYXJhbXMsIHBvc2l0aW9uKTtcbiAgICAgIHggPSBwb3NpdGlvbi54O1xuICAgICAgeSA9IHBvc2l0aW9uLnk7XG5cbiAgICAgIGlmICh4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgIGlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNob3cgaWYgdmlzaWJsZSwgaGlkZSBpZiBub3QuXG4gIGlmIChpc1Zpc2libGUpIHtcbiAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICB9XG4gIGVsc2Uge1xuICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gIH1cblxufTtcblxuXG5Ib3RzcG90LnByb3RvdHlwZS5fc2V0RW1iZWRkZWRQb3NpdGlvbiA9IGZ1bmN0aW9uKHZpZXcsIHBhcmFtcykge1xuICB2YXIgdHJhbnNmb3JtID0gdmlldy5jb29yZGluYXRlc1RvUGVyc3BlY3RpdmVUcmFuc2Zvcm0oXG4gICAgICBwYXJhbXMsIHRoaXMuX3BlcnNwZWN0aXZlLnJhZGl1cywgdGhpcy5fcGVyc3BlY3RpdmUuZXh0cmFUcmFuc2Zvcm1zKTtcbiAgc2V0VHJhbnNmb3JtKHRoaXMuX2RvbUVsZW1lbnQsIHRyYW5zZm9ybSk7XG59O1xuXG5cbkhvdHNwb3QucHJvdG90eXBlLl9zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcG9zaXRpb25BYnNvbHV0ZWx5KHRoaXMuX2RvbUVsZW1lbnQsIHgsIHksIHRoaXMuX3BlcnNwZWN0aXZlLmV4dHJhVHJhbnNmb3Jtcyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSG90c3BvdDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIEhvdHNwb3QgPSByZXF1aXJlKCcuL0hvdHNwb3QnKTtcbnZhciBjYWxjUmVjdCA9IHJlcXVpcmUoJy4vdXRpbC9jYWxjUmVjdCcpO1xudmFyIHBvc2l0aW9uQWJzb2x1dGVseSA9IHJlcXVpcmUoJy4vdXRpbC9wb3NpdGlvbkFic29sdXRlbHknKTtcbnZhciBzZXRBYnNvbHV0ZSA9IHJlcXVpcmUoJy4vdXRpbC9kb20nKS5zZXRBYnNvbHV0ZTtcbnZhciBzZXRPdmVyZmxvd0hpZGRlbiA9IHJlcXVpcmUoJy4vdXRpbC9kb20nKS5zZXRPdmVyZmxvd0hpZGRlbjtcbnZhciBzZXRPdmVyZmxvd1Zpc2libGUgPSByZXF1aXJlKCcuL3V0aWwvZG9tJykuc2V0T3ZlcmZsb3dWaXNpYmxlO1xudmFyIHNldE51bGxTaXplID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldE51bGxTaXplO1xudmFyIHNldFBpeGVsU2l6ZSA9IHJlcXVpcmUoJy4vdXRpbC9kb20nKS5zZXRQaXhlbFNpemU7XG52YXIgc2V0UG9pbnRlckV2ZW50cyA9IHJlcXVpcmUoJy4vdXRpbC9kb20nKS5zZXRXaXRoVmVuZG9yUHJlZml4KCdwb2ludGVyLWV2ZW50cycpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgYSBob3RzcG90IGhhcyBiZWVuIGNyZWF0ZWQgb3IgZGVzdHJveWVkIG9uIHRoZSBjb250YWluZXIuXG4gKiBAZXZlbnQgSG90c3BvdENvbnRhaW5lciNob3RzcG90c0NoYW5nZVxuICovXG5cbi8qKlxuICogQGNsYXNzIEhvdHNwb3RDb250YWluZXJcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBDcmVhdGVzIGEgRE9NIGVsZW1lbnQgdG8gaG9sZCB7QGxpbmsgSG90c3BvdCBob3RzcG90c30gYW5kIHVwZGF0ZXMgdGhlaXJcbiAqIHBvc2l0aW9uIHdoZW4gbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50RG9tRWxlbWVudCBUaGUgRE9NIGVsZW1lbnQgaW5zaWRlIHdoaWNoIHRoZSBjb250YWluZXJcbiAqICAgICBzaG91bGQgYmUgY3JlYXRlZC5cbiAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlIFRoZSB1bmRlcmx5aW5nIHN0YWdlLlxuICogQHBhcmFtIHtWaWV3fSB2aWV3IFRoZSB2aWV3IGFjY29yZGluZyB0byB3aGljaCB0aGUgaG90c3BvdHMgYXJlIHBvc2l0aW9uZWQuXG4gKiBAcGFyYW0ge1JlbmRlckxvb3B9IHJlbmRlckxvb3AgVGhlIHJlbmRlciBsb29wIGluZGljYXRpbmcgd2hlbiB0aGUgaG90c3BvdHNcbiAqICAgICBtdXN0IGJlIHJlbmRlcmVkLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7UmVjdFNwZWN9IG9wdHMucmVjdCBSZWN0YW5ndWxhciByZWdpb24gY292ZXJlZCBieSB0aGUgY29udGFpbmVyLiBTZWVcbiAqICAgIHtAbGluayBFZmZlY3RzI3JlY3R9LlxuICovXG5mdW5jdGlvbiBIb3RzcG90Q29udGFpbmVyKHBhcmVudERvbUVsZW1lbnQsIHN0YWdlLCB2aWV3LCByZW5kZXJMb29wLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHRoaXMuX3BhcmVudERvbUVsZW1lbnQgPSBwYXJlbnREb21FbGVtZW50O1xuICB0aGlzLl9zdGFnZSA9IHN0YWdlO1xuICB0aGlzLl92aWV3ID0gdmlldztcbiAgdGhpcy5fcmVuZGVyTG9vcCA9IHJlbmRlckxvb3A7XG5cbiAgLy8gSG90c3BvdCBsaXN0LlxuICB0aGlzLl9ob3RzcG90cyA9IFtdO1xuXG4gIC8vIFdoZXRoZXIgdGhlIGhvdHNwb3QgY29udGFpbmVyIHNob3VsZCBiZSB2aXNpYmxlLlxuICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcblxuICAvLyBUaGUgY3VycmVudCByZWN0LlxuICB0aGlzLl9yZWN0ID0gb3B0cy5yZWN0O1xuXG4gIC8vIFdoZXRoZXIgdGhlIHZpc2liaWxpdHkgb3IgdGhlIHJlY3QgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IERPTSB1cGRhdGUuXG4gIHRoaXMuX3Zpc2liaWxpdHlPclJlY3RDaGFuZ2VkID0gdHJ1ZTtcblxuICAvLyBUaGUgbGFzdCBzZWVuIHN0YWdlIGRpbWVuc2lvbnMuXG4gIHRoaXMuX3N0YWdlV2lkdGggPSBudWxsO1xuICB0aGlzLl9zdGFnZUhlaWdodCA9IG51bGw7XG5cbiAgLy8gVGVtcG9yYXJ5IHZhcmlhYmxlIHRvIGhvbGQgdGhlIGNhbGN1bGF0ZWQgcG9zaXRpb24gYW5kIHNpemUuXG4gIHRoaXMuX3RtcFJlY3QgPSB7fTtcblxuICAvLyBXcmFwcGVyIGVsZW1lbnQuIFdoZW4gdGhlIHJlY3QgZWZmZWN0IGlzIHNldCwgdGhlIHdyYXBwZXIgd2lsbCBoYXZlIG5vbnplcm9cbiAgLy8gZGltZW5zaW9ucyBhbmQgYHBvaW50ZXItZXZlbnRzOiBub25lYCBzbyB0aGF0IGhvdHNwb3RzIG91dHNpZGUgdGhlIHJlY3QgYXJlXG4gIC8vIGhpZGRlbiwgYnV0IG5vIG1vdXNlIGV2ZW50cyBhcmUgaGlqYWNrZWQuXG4gIHRoaXMuX2hvdHNwb3RDb250YWluZXJXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHNldEFic29sdXRlKHRoaXMuX2hvdHNwb3RDb250YWluZXJXcmFwcGVyKTtcbiAgc2V0UG9pbnRlckV2ZW50cyh0aGlzLl9ob3RzcG90Q29udGFpbmVyV3JhcHBlciwgJ25vbmUnKTtcbiAgdGhpcy5fcGFyZW50RG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9ob3RzcG90Q29udGFpbmVyV3JhcHBlcik7XG5cbiAgLy8gSG90c3BvdCBjb250YWluZXIgZWxlbWVudC4gSXQgaGFzIHplcm8gZGltZW5zaW9ucyBhbmQgYHBvaW50ZXItZXZlbnRzOiBhbGxgXG4gIC8vIHRvIG92ZXJyaWRlIHRoZSBgcG9pbnRlci1ldmVudHM6IG5vbmVgIG9uIHRoZSB3cmFwcGVyIGFuZCBhbGxvdyBob3RzcG90cyB0b1xuICAvLyBiZSBpbnRlcmFjdGVkIHdpdGguXG4gIHRoaXMuX2hvdHNwb3RDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgc2V0QWJzb2x1dGUodGhpcy5faG90c3BvdENvbnRhaW5lcik7XG4gIHNldFBvaW50ZXJFdmVudHModGhpcy5faG90c3BvdENvbnRhaW5lciwgJ2FsbCcpO1xuICB0aGlzLl9ob3RzcG90Q29udGFpbmVyV3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLl9ob3RzcG90Q29udGFpbmVyKTtcblxuICAvLyBVcGRhdGUgd2hlbiB0aGUgaG90c3BvdHMgY2hhbmdlIG9yIHNjZW5lIGlzIHJlLXJlbmRlcmVkLlxuICB0aGlzLl91cGRhdGVIYW5kbGVyID0gdGhpcy5fdXBkYXRlLmJpbmQodGhpcyk7XG4gIHRoaXMuX3JlbmRlckxvb3AuYWRkRXZlbnRMaXN0ZW5lcignYWZ0ZXJSZW5kZXInLCB0aGlzLl91cGRhdGVIYW5kbGVyKTtcbn1cblxuZXZlbnRFbWl0dGVyKEhvdHNwb3RDb250YWluZXIpO1xuXG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB3aGlsZSAodGhpcy5faG90c3BvdHMubGVuZ3RoKSB7XG4gICAgdGhpcy5kZXN0cm95SG90c3BvdCh0aGlzLl9ob3RzcG90c1swXSk7XG4gIH1cblxuICB0aGlzLl9wYXJlbnREb21FbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX2hvdHNwb3RDb250YWluZXJXcmFwcGVyKTtcblxuICB0aGlzLl9yZW5kZXJMb29wLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FmdGVyUmVuZGVyJywgdGhpcy5fdXBkYXRlSGFuZGxlcik7XG5cbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbkhvdHNwb3RDb250YWluZXIucHJvdG90eXBlLmRvbUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2hvdHNwb3RDb250YWluZXI7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtSZWN0fSByZWN0XG4gKi9cbkhvdHNwb3RDb250YWluZXIucHJvdG90eXBlLnNldFJlY3QgPSBmdW5jdGlvbihyZWN0KSB7XG4gIHRoaXMuX3JlY3QgPSByZWN0O1xuICB0aGlzLl92aXNpYmlsaXR5T3JSZWN0Q2hhbmdlZCA9IHRydWU7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7UmVjdH1cbiAqL1xuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUucmVjdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcmVjdDtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGhvdHNwb3QgaW4gdGhpcyBjb250YWluZXIuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBkb21FbGVtZW50IERPTSBlbGVtZW50IHRvIHVzZSBmb3IgdGhlIGhvdHNwb3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb29yZHMgVGhlIGhvdHNwb3QgY29vcmRpbmF0ZXMuXG4gKiAgICAgVXNlIHtAbGluayBSZWN0aWxpbmVhclZpZXdDb29yZHN9YCBmb3IgYSB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3fSBvclxuICogICAgIHtAbGluayBGbGF0Vmlld0Nvb3Jkc30gZm9yIGEge0BsaW5rIEZsYXRWaWV3fS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbnMgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSBgb3B0c2AgYXJndW1lbnQgdG9cbiAqICAgICB0aGUge0BsaW5rIEhvdHNwb3R9IGNvbnN0cnVjdG9yLlxuICogQHJldHVybiB7SG90c3BvdH1cbiAqL1xuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUuY3JlYXRlSG90c3BvdCA9IGZ1bmN0aW9uKGRvbUVsZW1lbnQsIGNvb3Jkcywgb3B0cykge1xuICBjb29yZHMgPSBjb29yZHMgfHwge307XG5cbiAgdmFyIGhvdHNwb3QgPSBuZXcgSG90c3BvdChcbiAgICAgIGRvbUVsZW1lbnQsIHRoaXMuX2hvdHNwb3RDb250YWluZXIsIHRoaXMuX3ZpZXcsIGNvb3Jkcywgb3B0cyk7XG4gIHRoaXMuX2hvdHNwb3RzLnB1c2goaG90c3BvdCk7XG4gIGhvdHNwb3QuX3VwZGF0ZSgpO1xuXG4gIHRoaXMuZW1pdCgnaG90c3BvdHNDaGFuZ2UnKTtcblxuICByZXR1cm4gaG90c3BvdDtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge0hvdHNwb3R9IGhvdHNwb3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkhvdHNwb3RDb250YWluZXIucHJvdG90eXBlLmhhc0hvdHNwb3QgPSBmdW5jdGlvbihob3RzcG90KSB7XG4gIHJldHVybiB0aGlzLl9ob3RzcG90cy5pbmRleE9mKGhvdHNwb3QpID49IDA7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7SG90c3BvdFtdfVxuICovXG5Ib3RzcG90Q29udGFpbmVyLnByb3RvdHlwZS5saXN0SG90c3BvdHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdCh0aGlzLl9ob3RzcG90cyk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBhIGhvdHNwb3QgZnJvbSB0aGUgY29udGFpbmVyLlxuICpcbiAqIEBwYXJhbSB7SG90c3BvdH0gaG90c3BvdFxuICovXG5Ib3RzcG90Q29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95SG90c3BvdCA9IGZ1bmN0aW9uKGhvdHNwb3QpIHtcbiAgdmFyIGkgPSB0aGlzLl9ob3RzcG90cy5pbmRleE9mKGhvdHNwb3QpO1xuICBpZiAoaSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1Y2ggaG90c3BvdCcpO1xuICB9XG4gIHRoaXMuX2hvdHNwb3RzLnNwbGljZShpLCAxKTtcblxuICBob3RzcG90LmRlc3Ryb3koKTtcbiAgdGhpcy5lbWl0KCdob3RzcG90c0NoYW5nZScpO1xufTtcblxuXG4vKipcbiAqIEhpZGUgdGhlIGNvbnRhaW5lcidzIERPTSBlbGVtZW50LCBjYXVzaW5nIGV2ZXJ5IGNvbnRhaW5lZCB7QGxpbmsgSG90c3BvdH0gdG9cbiAqIGJlIGhpZGRlbi5cbiAqL1xuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLl92aXNpYmlsaXR5T3JSZWN0Q2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTaG93IHRoZSBjb250YWluZXIncyBET00gZWxlbWVudCwgY2F1c2luZyBldmVyeSBjb250YWluZWQge0BsaW5rIEhvdHNwb3R9IHRvXG4gKiBiZSBzaG93bi5cbiAqL1xuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3Zpc2libGUpIHtcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl92aXNpYmlsaXR5T3JSZWN0Q2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbn07XG5cblxuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd3JhcHBlciA9IHRoaXMuX2hvdHNwb3RDb250YWluZXJXcmFwcGVyO1xuICB2YXIgd2lkdGggPSB0aGlzLl9zdGFnZS53aWR0aCgpO1xuICB2YXIgaGVpZ2h0ID0gdGhpcy5fc3RhZ2UuaGVpZ2h0KCk7XG4gIHZhciB0bXBSZWN0ID0gdGhpcy5fdG1wUmVjdDtcblxuICAvLyBBdm9pZCB1cGRhdGluZyB0aGUgd3JhcHBlciBET00gdW5sZXNzIG5lY2Vzc2FyeS5cbiAgaWYgKHRoaXMuX3Zpc2liaWxpdHlPclJlY3RDaGFuZ2VkIHx8XG4gICAgICAodGhpcy5fcmVjdCAmJiAod2lkdGggIT09IHRoaXMuX3N0YWdlV2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLl9zdGFnZUhlaWdodCkpKSB7XG4gICAgdmFyIHZpc2libGUgPSB0aGlzLl92aXNpYmxlO1xuICAgIHdyYXBwZXIuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPyAnYmxvY2snIDogJ25vbmUnO1xuXG4gICAgaWYgKHZpc2libGUpIHtcbiAgICAgIGlmICh0aGlzLl9yZWN0KSB7XG4gICAgICAgIGNhbGNSZWN0KHdpZHRoLCBoZWlnaHQsIHRoaXMuX3JlY3QsIHRtcFJlY3QpO1xuICAgICAgICBwb3NpdGlvbkFic29sdXRlbHkod3JhcHBlciwgd2lkdGggKiB0bXBSZWN0LngsIGhlaWdodCAqIHRtcFJlY3QueSk7XG4gICAgICAgIHNldFBpeGVsU2l6ZSh3cmFwcGVyLCB3aWR0aCAqIHRtcFJlY3Qud2lkdGgsIGhlaWdodCAqIHRtcFJlY3QuaGVpZ2h0KTtcbiAgICAgICAgc2V0T3ZlcmZsb3dIaWRkZW4od3JhcHBlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3NpdGlvbkFic29sdXRlbHkod3JhcHBlciwgMCwgMCk7XG4gICAgICAgIHNldE51bGxTaXplKHdyYXBwZXIpO1xuICAgICAgICBzZXRPdmVyZmxvd1Zpc2libGUod3JhcHBlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhZ2VXaWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX3N0YWdlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX3Zpc2liaWxpdHlPclJlY3RDaGFuZ2VkID0gZmFsc2U7XG4gIH1cblxuICAvLyBVcGRhdGUgaG90c3BvdHMgdW5jb25kaXRpb25hbGx5LCBhcyB0aGUgdmlldyBwYXJhbWV0ZXJzIG1heSBoYXZlIGNoYW5nZWQuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG90c3BvdHMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9ob3RzcG90c1tpXS5fdXBkYXRlKCk7XG4gIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBIb3RzcG90Q29udGFpbmVyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCcuL3V0aWwvZXh0ZW5kJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCB0aGUgbGF5ZXIgaGFzIGJlZW4gcmVuZGVyZWQuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBzdGFibGUgV2hldGhlciBhbGwgdGlsZXMgd2VyZSBzdWNjZXNzZnVsbHkgcmVuZGVyZWQgd2l0aG91dFxuICogICAgIG1pc3NpbmcgdGV4dHVyZXMgb3IgcmVzb3J0aW5nIHRvIGZhbGxiYWNrcy5cbiAqIEBldmVudCBMYXllciNyZW5kZXJDb21wbGV0ZVxuICovXG5cbi8qKlxuICogQGNsYXNzIExheWVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSBMYXllciBpcyBhIGNvbWJpbmF0aW9uIG9mIHtAbGluayBTb3VyY2V9LCB7QGxpbmsgR2VvbWV0cnl9LCB7QGxpbmsgVmlld31cbiAqIGFuZCB7QGxpbmsgVGV4dHVyZVN0b3JlfSB0aGF0IG1heSBiZSBhZGRlZCBpbnRvIGEge0BsaW5rIFN0YWdlfSBhbmQgcmVuZGVyZWRcbiAqIHdpdGgge0BsaW5rIEVmZmVjdHN9LlxuICpcbiAqIEBwYXJhbSB7U291cmNlfSBzb3VyY2VcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5XG4gKiBAcGFyYW0ge1ZpZXd9IHZpZXdcbiAqIEBwYXJhbSB7VGV4dHVyZVN0b3JlfSB0ZXh0dXJlU3RvcmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge0VmZmVjdHN9IG9wdHMuZWZmZWN0c1xuKi9cbmZ1bmN0aW9uIExheWVyKHNvdXJjZSwgZ2VvbWV0cnksIHZpZXcsIHRleHR1cmVTdG9yZSwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICB0aGlzLl9nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICB0aGlzLl92aWV3ID0gdmlldztcbiAgdGhpcy5fdGV4dHVyZVN0b3JlID0gdGV4dHVyZVN0b3JlO1xuXG4gIHRoaXMuX2VmZmVjdHMgPSBvcHRzLmVmZmVjdHMgfHwge307XG5cbiAgdGhpcy5fZml4ZWRMZXZlbEluZGV4ID0gbnVsbDtcblxuICB0aGlzLl92aWV3Q2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgndmlld0NoYW5nZScsIHNlbGYudmlldygpKTtcbiAgfTtcblxuICB0aGlzLl92aWV3LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX3ZpZXdDaGFuZ2VIYW5kbGVyKTtcblxuICB0aGlzLl90ZXh0dXJlU3RvcmVDaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCd0ZXh0dXJlU3RvcmVDaGFuZ2UnLCBzZWxmLnRleHR1cmVTdG9yZSgpKTtcbiAgfTtcblxuICB0aGlzLl90ZXh0dXJlU3RvcmUuYWRkRXZlbnRMaXN0ZW5lcigndGV4dHVyZUxvYWQnLFxuICAgIHRoaXMuX3RleHR1cmVTdG9yZUNoYW5nZUhhbmRsZXIpO1xuICB0aGlzLl90ZXh0dXJlU3RvcmUuYWRkRXZlbnRMaXN0ZW5lcigndGV4dHVyZUVycm9yJyxcbiAgICB0aGlzLl90ZXh0dXJlU3RvcmVDaGFuZ2VIYW5kbGVyKTtcbiAgdGhpcy5fdGV4dHVyZVN0b3JlLmFkZEV2ZW50TGlzdGVuZXIoJ3RleHR1cmVJbnZhbGlkJyxcbiAgICB0aGlzLl90ZXh0dXJlU3RvcmVDaGFuZ2VIYW5kbGVyKTtcbn1cblxuZXZlbnRFbWl0dGVyKExheWVyKTtcblxuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cbkxheWVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3ZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fdmlld0NoYW5nZUhhbmRsZXIpO1xuICB0aGlzLl90ZXh0dXJlU3RvcmUucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGV4dHVyZUxvYWQnLFxuICAgIHRoaXMuX3RleHR1cmVTdG9yZUNoYW5nZUhhbmRsZXIpO1xuICB0aGlzLl90ZXh0dXJlU3RvcmUucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGV4dHVyZUVycm9yJyxcbiAgICB0aGlzLl90ZXh0dXJlU3RvcmVDaGFuZ2VIYW5kbGVyKTtcbiAgdGhpcy5fdGV4dHVyZVN0b3JlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RleHR1cmVJbnZhbGlkJyxcbiAgICB0aGlzLl90ZXh0dXJlU3RvcmVDaGFuZ2VIYW5kbGVyKTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcge0BsaW5rIFNvdXJjZSBzb3VyY2V9LlxuICogQHJldHVybiB7U291cmNlfVxuICovXG5MYXllci5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zb3VyY2U7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgR2VvbWV0cnkgZ2VvbWV0cnl9LlxuICogQHJldHVybiB7R2VvbWV0cnl9XG4gKi9cbkxheWVyLnByb3RvdHlwZS5nZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZ2VvbWV0cnk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgVmlldyB2aWV3fS5cbiAqIEByZXR1cm4ge1ZpZXd9XG4gKi9cbkxheWVyLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl92aWV3O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcge0BsaW5rIFRleHR1cmVTdG9yZSB0ZXh0dXJlIHN0b3JlfS5cbiAqIEByZXR1cm4ge1RleHR1cmVTdG9yZX1cbiAqL1xuTGF5ZXIucHJvdG90eXBlLnRleHR1cmVTdG9yZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdGV4dHVyZVN0b3JlO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBzZXQge0BsaW5rIEVmZmVjdHMgZWZmZWN0c30uXG4gKiBAcmV0dXJuIHtFZmZlY3RzfVxuICovXG5MYXllci5wcm90b3R5cGUuZWZmZWN0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZWZmZWN0cztcbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSB7QGxpbmsgRWZmZWN0cyBlZmZlY3RzfS5cbiAqIEBwYXJhbSB7RWZmZWN0c30gZWZmZWN0c1xuICovXG5MYXllci5wcm90b3R5cGUuc2V0RWZmZWN0cyA9IGZ1bmN0aW9uKGVmZmVjdHMpIHtcbiAgdGhpcy5fZWZmZWN0cyA9IGVmZmVjdHM7XG4gIHRoaXMuZW1pdCgnZWZmZWN0c0NoYW5nZScsIHRoaXMuX2VmZmVjdHMpO1xufTtcblxuXG4vKipcbiAqIE1lcmdlcyBlZmZlY3RzIGludG8gdGhlIGN1cnJlbnRseSBzZXQgb25lcy4gVGhlIG1lcmdlIGlzIG5vbi1yZWN1cnNpdmU7IGZvclxuICogaW5zdGFuY2UsIGlmIGN1cnJlbnQgZWZmZWN0cyBhcmUgYHsgcmVjdDogeyByZWxhdGl2ZVdpZHRoOiAwLjUgfSB9YCxcbiAqIGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBgeyByZWN0OiB7IHJlbGF0aXZlWDogMC41IH19YCB3aWxsIHJlc2V0XG4gKiBgcmVjdC5yZWxhdGl2ZVdpZHRoYC5cbiAqXG4gKiBAcGFyYW0ge0VmZmVjdHN9IGVmZmVjdHNcbiAqL1xuTGF5ZXIucHJvdG90eXBlLm1lcmdlRWZmZWN0cyA9IGZ1bmN0aW9uKGVmZmVjdHMpIHtcbiAgZXh0ZW5kKHRoaXMuX2VmZmVjdHMsIGVmZmVjdHMpO1xuICB0aGlzLmVtaXQoJ2VmZmVjdHNDaGFuZ2UnLCB0aGlzLl9lZmZlY3RzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXhlZCBsZXZlbCBpbmRleC5cbiAqIEByZXR1cm4geyhudW1iZXJ8bnVsbCl9XG4gKi9cbkxheWVyLnByb3RvdHlwZS5maXhlZExldmVsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9maXhlZExldmVsSW5kZXg7XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgZml4ZWQgbGV2ZWwgaW5kZXguIFdoZW4gc2V0LCB0aGUgY29ycmVzcG9uZGluZyBsZXZlbCB3aWxsIGJlXG4gKiB1c2VkIHJlZ2FyZGxlc3Mgb2YgdGhlIHZpZXcgcGFyYW1ldGVycy4gVW5zZXQgd2l0aCBhIG51bGwgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHsobnVtYmVyfG51bGwpfSBsZXZlbEluZGV4XG4gKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBsZXZlbCBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gKi9cbkxheWVyLnByb3RvdHlwZS5zZXRGaXhlZExldmVsID0gZnVuY3Rpb24obGV2ZWxJbmRleCkge1xuICBpZiAobGV2ZWxJbmRleCAhPT0gdGhpcy5fZml4ZWRMZXZlbEluZGV4KSB7XG4gICAgaWYgKGxldmVsSW5kZXggIT0gbnVsbCAmJiAobGV2ZWxJbmRleCA+PSB0aGlzLl9nZW9tZXRyeS5sZXZlbExpc3QubGVuZ3RoIHx8XG4gICAgICAgIGxldmVsSW5kZXggPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGV2ZWwgaW5kZXggb3V0IG9mIHJhbmdlOiBcIiArIGxldmVsSW5kZXgpO1xuICAgIH1cbiAgICB0aGlzLl9maXhlZExldmVsSW5kZXggPSBsZXZlbEluZGV4O1xuICAgIHRoaXMuZW1pdCgnZml4ZWRMZXZlbENoYW5nZScsIHRoaXMuX2ZpeGVkTGV2ZWxJbmRleCk7XG4gIH1cbn07XG5cblxuTGF5ZXIucHJvdG90eXBlLl9zZWxlY3RMZXZlbCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGV2ZWw7XG4gIGlmICh0aGlzLl9maXhlZExldmVsSW5kZXggIT0gbnVsbCkge1xuICAgIGxldmVsID0gdGhpcy5fZ2VvbWV0cnkubGV2ZWxMaXN0W3RoaXMuX2ZpeGVkTGV2ZWxJbmRleF07XG4gIH0gZWxzZSB7XG4gICAgbGV2ZWwgPSB0aGlzLl92aWV3LnNlbGVjdExldmVsKHRoaXMuX2dlb21ldHJ5LnNlbGVjdGFibGVMZXZlbExpc3QpO1xuICB9XG4gIHJldHVybiBsZXZlbDtcbn07XG5cblxuTGF5ZXIucHJvdG90eXBlLnZpc2libGVUaWxlcyA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICB2YXIgbGV2ZWwgPSB0aGlzLl9zZWxlY3RMZXZlbCgpO1xuICByZXR1cm4gdGhpcy5fZ2VvbWV0cnkudmlzaWJsZVRpbGVzKHRoaXMuX3ZpZXcsIGxldmVsLCByZXN1bHQpO1xufTtcblxuXG4vKipcbiAqIFBpbiBhIHdob2xlIGxldmVsIGludG8gdGhlIHRleHR1cmUgc3RvcmUuXG4gKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxJbmRleFxuICovXG5MYXllci5wcm90b3R5cGUucGluTGV2ZWwgPSBmdW5jdGlvbihsZXZlbEluZGV4KSB7XG4gIHZhciBsZXZlbCA9IHRoaXMuX2dlb21ldHJ5LmxldmVsTGlzdFtsZXZlbEluZGV4XTtcbiAgdmFyIHRpbGVzID0gdGhpcy5fZ2VvbWV0cnkubGV2ZWxUaWxlcyhsZXZlbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl90ZXh0dXJlU3RvcmUucGluKHRpbGVzW2ldKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFVucGluIGEgd2hvbGUgbGV2ZWwgZnJvbSB0aGUgdGV4dHVyZSBzdG9yZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbEluZGV4XG4gKi9cbkxheWVyLnByb3RvdHlwZS51bnBpbkxldmVsID0gZnVuY3Rpb24obGV2ZWxJbmRleCkge1xuICB2YXIgbGV2ZWwgPSB0aGlzLl9nZW9tZXRyeS5sZXZlbExpc3RbbGV2ZWxJbmRleF07XG4gIHZhciB0aWxlcyA9IHRoaXMuX2dlb21ldHJ5LmxldmVsVGlsZXMobGV2ZWwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fdGV4dHVyZVN0b3JlLnVucGluKHRpbGVzW2ldKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFBpbiB0aGUgZmlyc3QgbGV2ZWwuIEVxdWl2YWxlbnQgdG8gYHBpbkxldmVsKDApYC5cbiAqL1xuTGF5ZXIucHJvdG90eXBlLnBpbkZpcnN0TGV2ZWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucGluTGV2ZWwoMCk7XG59O1xuXG5cbi8qKlxuICogVW5waW4gdGhlIGZpcnN0IGxldmVsLiBFcXVpdmFsZW50IHRvIGB1bnBpbkxldmVsKDApYC5cbiAqL1xuTGF5ZXIucHJvdG90eXBlLnVucGluRmlyc3RMZXZlbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy51bnBpbkxldmVsKDApO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IExheWVyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuL3V0aWwvaW5oZXJpdHMnKTtcblxuLyoqXG4gKiBAY2xhc3MgTmV0d29ya0Vycm9yXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogU2lnbmFscyBhbiBlcnJvciB0aGF0IG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIGEgVVJMLiBUaGlzIGlzIHVzZWQgYnlcbiAqIHtAbGluayBMb2FkZXIgbG9hZGVyc30gdG8gZGlzdGluZ3Vpc2ggbmV0d29yayBmYWlsdXJlcyBmcm9tIG90aGVyIGVycm9ycy5cbiAqL1xuZnVuY3Rpb24gTmV0d29ya0Vycm9yKG1lc3NhZ2UpIHtcbiAgLy8gU2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzgyMTA3L3doYXRzLWEtZ29vZC13YXktdG8tZXh0ZW5kLWVycm9yLWluLWphdmFzY3JpcHRcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuaW5oZXJpdHMoTmV0d29ya0Vycm9yLCBFcnJvcik7XG5cbm1vZHVsZS5leHBvcnRzID0gTmV0d29ya0Vycm9yO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCB7QGxpbmsgU3RhZ2UjcmVuZGVyfSBpcyBhYm91dCB0byBiZSBjYWxsZWQuXG4gKiBAZXZlbnQgUmVuZGVyTG9vcCNiZWZvcmVSZW5kZXJcbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCB7QGxpbmsgU3RhZ2UjcmVuZGVyfSBoYXMganVzdCBiZWVuIGNhbGxlZC5cbiAqIEBldmVudCBSZW5kZXJMb29wI2FmdGVyUmVuZGVyXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgUmVuZGVyTG9vcFxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgUmVuZGVyTG9vcCB3cmFwcyBhIHtAbGluayBTdGFnZX0gYW5kIGNhbGxzIHtAbGluayBTdGFnZSNyZW5kZXJ9IG9uIHRoZSBuZXh0XG4gKiBmcmFtZSB3aGVuZXZlciBpdCBmaXJlcyB7QGxpbmsgU3RhZ2UjcmVuZGVySW52YWxpZH0uIEl0IG1heSBiZSBzdGFydGVkIGFuZFxuICogc3RvcHBlZCwgYW5kIGlzIGluaXRpYWxseSBpbiB0aGUgc3RvcHBlZCBzdGF0ZSwgaW4gd2hpY2ggbm8gY2FsbCB0b1xuICoge0BsaW5rIFN0YWdlI3JlbmRlcn0gb2NjdXJzLlxuICpcbiAqIEBsaXN0ZW5zIFN0YWdlI3JlbmRlckludmFsaWRcbiAqXG4gKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuICovXG5mdW5jdGlvbiBSZW5kZXJMb29wKHN0YWdlKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIFRoZSBzdGFnZSB3cmFwcGVkIGJ5IHRoZSBsb29wLlxuICB0aGlzLl9zdGFnZSA9IHN0YWdlO1xuXG4gIC8vIFdoZXRoZXIgdGhlIGxvb3AgaXMgcnVubmluZy5cbiAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuXG4gIC8vIFdoZXRoZXIgdGhlIGxvb3AgaXMgY3VycmVudGx5IHJlbmRlcmluZy5cbiAgdGhpcy5fcmVuZGVyaW5nID0gZmFsc2U7XG5cbiAgLy8gVGhlIGN1cnJlbnQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGhhbmRsZS5cbiAgdGhpcy5fcmVxdWVzdEhhbmRsZSA9IG51bGw7XG5cbiAgLy8gVGhlIGNhbGxiYWNrIHBhc3NlZCBpbnRvIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cbiAgdGhpcy5fYm91bmRMb29wID0gdGhpcy5fbG9vcC5iaW5kKHRoaXMpO1xuXG4gIC8vIEhhbmRsZXIgZm9yIHJlbmRlckludmFsaWQgZXZlbnRzIGVtaXR0ZWQgYnkgdGhlIHN0YWdlLlxuICB0aGlzLl9yZW5kZXJJbnZhbGlkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IHJlbmRlcmluZywgdGhlcmUncyBubyBuZWVkIHRvIHNjaGVkdWxlIGEgbmV3IHJlbmRlclxuICAgIC8vIG9uIHRoZSBuZXh0IGZyYW1lLlxuICAgIGlmICghc2VsZi5fcmVuZGVyaW5nKSB7XG4gICAgICBzZWxmLnJlbmRlck9uTmV4dEZyYW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEhhbmRsZSByZW5kZXJJbnZhbGlkIGV2ZW50cyBlbWl0dGVkIGJ5IHRoZSBzdGFnZS5cbiAgdGhpcy5fc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcigncmVuZGVySW52YWxpZCcsIHRoaXMuX3JlbmRlckludmFsaWRIYW5kbGVyKTtcblxufVxuXG5ldmVudEVtaXR0ZXIoUmVuZGVyTG9vcCk7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5SZW5kZXJMb29wLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc3RvcCgpO1xuICB0aGlzLl9zdGFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW5kZXJJbnZhbGlkJywgdGhpcy5fcmVuZGVySW52YWxpZEhhbmRsZXIpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBzdGFnZS5cbiAqIEByZXR1cm4ge1N0YWdlfVxuICovXG5SZW5kZXJMb29wLnByb3RvdHlwZS5zdGFnZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc3RhZ2U7XG59O1xuXG5cbi8qKlxuICogU3RhcnRzIHRoZSByZW5kZXIgbG9vcC5cbiAqL1xuUmVuZGVyTG9vcC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gIHRoaXMucmVuZGVyT25OZXh0RnJhbWUoKTtcbn07XG5cblxuLyoqXG4gKiBTdG9wcyB0aGUgcmVuZGVyIGxvb3AuXG4gKi9cblJlbmRlckxvb3AucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3JlcXVlc3RIYW5kbGUpIHtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVxdWVzdEhhbmRsZSk7XG4gICAgdGhpcy5fcmVxdWVzdEhhbmRsZSA9IG51bGw7XG4gIH1cbiAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xufTtcblxuXG4vKipcbiAqIEZvcmNlcyB0aGUgc3RhZ2UgdG8gcmVuZGVyIG9uIHRoZSBuZXh0IGZyYW1lLCBldmVuIGlmIGl0cyBjb250ZW50cyByZW1haW5cbiAqIHZhbGlkLiBEb2VzIG5vdGhpbmcgaWYgdGhlIGxvb3AgaXMgc3RvcHBlZC5cbiAqL1xuUmVuZGVyTG9vcC5wcm90b3R5cGUucmVuZGVyT25OZXh0RnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3J1bm5pbmcgJiYgIXRoaXMuX3JlcXVlc3RIYW5kbGUpIHtcbiAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9ib3VuZExvb3ApO1xuICB9XG59O1xuXG5cblJlbmRlckxvb3AucHJvdG90eXBlLl9sb29wID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fcnVubmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyIGxvb3AgcnVubmluZyB3aGlsZSBpbiBzdG9wcGVkIHN0YXRlJyk7XG4gIH1cbiAgdGhpcy5fcmVxdWVzdEhhbmRsZSA9IG51bGw7XG4gIHRoaXMuX3JlbmRlcmluZyA9IHRydWU7XG4gIHRoaXMuZW1pdCgnYmVmb3JlUmVuZGVyJyk7XG4gIHRoaXMuX3JlbmRlcmluZyA9IGZhbHNlO1xuICB0aGlzLl9zdGFnZS5yZW5kZXIoKTtcbiAgdGhpcy5lbWl0KCdhZnRlclJlbmRlcicpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlckxvb3A7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMYXllciA9IHJlcXVpcmUoJy4vTGF5ZXInKTtcbnZhciBUZXh0dXJlU3RvcmUgPSByZXF1aXJlKCcuL1RleHR1cmVTdG9yZScpO1xudmFyIEhvdHNwb3RDb250YWluZXIgPSByZXF1aXJlKCcuL0hvdHNwb3RDb250YWluZXInKTtcbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBub3cgPSByZXF1aXJlKCcuL3V0aWwvbm93Jyk7XG52YXIgbm9vcCA9IHJlcXVpcmUoJy4vdXRpbC9ub29wJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4vdXRpbC90eXBlJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL3V0aWwvZGVmYXVsdHMnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogU2lnbmFscyB0aGF0IHRoZSBzY2VuZSdzIHZpZXcgaGFzIGNoYW5nZWQuIFNlZSB7QGxpbmsgVmlldyNldmVudDpjaGFuZ2V9LlxuICogQGV2ZW50IFNjZW5lI3ZpZXdDaGFuZ2VcbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCB0aGUgc2NlbmUncyBsYXllcnMgaGF2ZSBjaGFuZ2VkLlxuICogQGV2ZW50IFNjZW5lI2xheWVyQ2hhbmdlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgU2NlbmVcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIFNjZW5lIGlzIGEgc3RhY2sgb2Yge0BsaW5rIExheWVyIGxheWVyc30gc2hhcmluZyB0aGUgc2FtZSB7QGxpbmsgVmlldyB2aWV3fVxuICogYW5kIHtAbGluayBIb3RzcG90Q29udGFpbmVyIGhvdHNwb3QgY29udGFpbmVyfS4gSXQgYmVsb25ncyB0byB0aGVcbiAqIHtAbGluayBWaWV3ZXIgdmlld2VyfSBpbnNpZGUgd2hpY2ggaXQgaXMgZGlzcGxheWVkLlxuICpcbiAqIENsaWVudHMgc2hvdWxkIGNhbGwge0BsaW5rIFZpZXdlciNjcmVhdGVTY2VuZX0gaW5zdGVhZCBvZiBpbnZva2luZyB0aGVcbiAqIGNvbnN0cnVjdG9yIGRpcmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7Vmlld2VyfSB2aWV3ZXIgVGhlIHZpZXdlciB0aGlzIHNjZW5lIGJlbG9uZ3MgdG8uXG4gKiBAcGFyYW0ge1ZpZXd9IHZpZXcgVGhlIHNjZW5lJ3MgdW5kZXJseWluZyB2aWV3LlxuICovXG5mdW5jdGlvbiBTY2VuZSh2aWV3ZXIsIHZpZXcpIHtcbiAgdGhpcy5fdmlld2VyID0gdmlld2VyO1xuICB0aGlzLl92aWV3ID0gdmlldztcbiAgdGhpcy5fbGF5ZXJzID0gW107XG5cbiAgLy8gSG90c3BvdCBjb250YWluZXIuIEFzc3VtZSBpdCBvY2N1cGllcyBhIGZ1bGwgcmVjdC5cbiAgdGhpcy5faG90c3BvdENvbnRhaW5lciA9IG5ldyBIb3RzcG90Q29udGFpbmVyKFxuICAgIHZpZXdlci5fY29udHJvbENvbnRhaW5lcixcbiAgICB2aWV3ZXIuc3RhZ2UoKSxcbiAgICB0aGlzLl92aWV3LFxuICAgIHZpZXdlci5yZW5kZXJMb29wKCkpO1xuXG4gIC8vIFRoZSBjdXJyZW50IG1vdmVtZW50LlxuICB0aGlzLl9tb3ZlbWVudCA9IG51bGw7XG4gIHRoaXMuX21vdmVtZW50U3RhcnRUaW1lID0gbnVsbDtcbiAgdGhpcy5fbW92ZW1lbnRTdGVwID0gbnVsbDtcbiAgdGhpcy5fbW92ZW1lbnRQYXJhbXMgPSBudWxsO1xuICB0aGlzLl9tb3ZlbWVudENhbGxiYWNrID0gbnVsbDtcblxuICAvLyBFdmVudCBsaXN0ZW5lciBmb3IgdXBkYXRpbmcgdGhlIHZpZXcgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IG1vdmVtZW50LlxuICAvLyBUaGUgbGlzdGVuZXIgaXMgc2V0L3Vuc2V0IG9uIHRoZSByZW5kZXIgbG9vcCB3aGVuIGEgbW92ZW1lbnQgc3RhcnRzL3N0b3BzLlxuICB0aGlzLl91cGRhdGVNb3ZlbWVudEhhbmRsZXIgPSB0aGlzLl91cGRhdGVNb3ZlbWVudC5iaW5kKHRoaXMpO1xuXG4gIC8vIFNob3cgb3IgaGlkZSBob3RzcG90cyB3aGVuIHNjZW5lIGNoYW5nZXMuXG4gIHRoaXMuX3VwZGF0ZUhvdHNwb3RDb250YWluZXJIYW5kbGVyID0gdGhpcy5fdXBkYXRlSG90c3BvdENvbnRhaW5lci5iaW5kKHRoaXMpO1xuICB0aGlzLl92aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcignc2NlbmVDaGFuZ2UnLCB0aGlzLl91cGRhdGVIb3RzcG90Q29udGFpbmVySGFuZGxlcik7XG5cbiAgLy8gRW1pdCBldmVudCB3aGVuIHZpZXcgY2hhbmdlcy5cbiAgdGhpcy5fdmlld0NoYW5nZUhhbmRsZXIgPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAndmlld0NoYW5nZScpO1xuICB0aGlzLl92aWV3LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX3ZpZXdDaGFuZ2VIYW5kbGVyKTtcblxuICAvLyBVcGRhdGUgdGhlIGhvdHNwb3QgY29udGFpbmVyLlxuICB0aGlzLl91cGRhdGVIb3RzcG90Q29udGFpbmVyKCk7XG59XG5cbmV2ZW50RW1pdHRlcihTY2VuZSk7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLiBDbGllbnRzIHNob3VsZCBjYWxsIHtAbGluayBWaWV3ZXIjZGVzdHJveVNjZW5lfSBpbnN0ZWFkLlxuICovXG5TY2VuZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl92aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX3ZpZXdDaGFuZ2VIYW5kbGVyKTtcbiAgdGhpcy5fdmlld2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NjZW5lQ2hhbmdlJywgdGhpcy5fdXBkYXRlSG90c3BvdENvbnRhaW5lckhhbmRsZXIpO1xuXG4gIGlmICh0aGlzLl9tb3ZlbWVudCkge1xuICAgIHRoaXMuc3RvcE1vdmVtZW50KCk7XG4gIH1cblxuICB0aGlzLl9ob3RzcG90Q29udGFpbmVyLmRlc3Ryb3koKTtcblxuICB0aGlzLmRlc3Ryb3lBbGxMYXllcnMoKTtcblxuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB7QGxpbmsgSG90c3BvdENvbnRhaW5lciBob3RzcG90IGNvbnRhaW5lcn0gZm9yIHRoZSBzY2VuZS5cbiAqIEByZXR1cm4ge0xheWVyfVxuICovXG5TY2VuZS5wcm90b3R5cGUuaG90c3BvdENvbnRhaW5lciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faG90c3BvdENvbnRhaW5lcjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3Qgb2YgdGhlIHtAbGluayBMYXllciBsYXllcnN9IGJlbG9uZ2luZyB0byB0aGUgc2NlbmUsIG9yXG4gKiBudWxsIGlmIHRoZSBzY2VuZSBoYXMgbm8gbGF5ZXJzLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYFNjZW5lI2xpc3RMYXllcnNbMF1gLiBJdCBtYXkgYmUgcmVtb3ZlZCBpbiB0aGVcbiAqIGZ1dHVyZS5cbiAqXG4gKiBAcmV0dXJuIHtMYXllcn1cbiAqL1xuU2NlbmUucHJvdG90eXBlLmxheWVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9sYXllcnNbMF07XG59O1xuXG4vKipcbiogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHtAbGluayBMYXllciBsYXllcnN9IGJlbG9uZ2luZyB0byB0aGUgc2NlbmUuIFRoZVxuKiByZXR1cm5lZCBsaXN0IGlzIGluIGRpc3BsYXkgb3JkZXIsIGJhY2tncm91bmQgdG8gZm9yZWdyb3VuZC5cbiogQHJldHVybiB7TGF5ZXJbXX1cbiAqL1xuU2NlbmUucHJvdG90eXBlLmxpc3RMYXllcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdCh0aGlzLl9sYXllcnMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjZW5lJ3MgdW5kZXJseWluZyB7QGxpbmsgVmlldyB2aWV3fS5cbiAqIEByZXR1cm4ge1ZpZXd9XG4gKi9cblNjZW5lLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl92aWV3O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHtAbGluayBWaWV3ZXIgdmlld2VyfSB0aGUgc2NlbmUgYmVsb25ncyB0by5cbiAqIEByZXR1cm4ge1ZpZXdlcn1cbiAqL1xuU2NlbmUucHJvdG90eXBlLnZpZXdlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdmlld2VyO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgc2NlbmUgaXMgY3VycmVudGx5IHZpc2libGUuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5TY2VuZS5wcm90b3R5cGUudmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdmlld2VyLnNjZW5lKCkgPT09IHRoaXM7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgTGF5ZXIgbGF5ZXJ9IGFuZCBhZGRzIGl0IGludG8gdGhlIHNjZW5lIGluIHRoZVxuICogZm9yZWdyb3VuZCBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBMYXllciBjcmVhdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtTb3VyY2V9IG9wdHMuc291cmNlIFRoZSBsYXllcidzIHVuZGVybHlpbmcge0BsaW5rIFNvdXJjZX0uXG4gKiBAcGFyYW0ge1NvdXJjZX0gb3B0cy5nZW9tZXRyeSBUaGUgbGF5ZXIncyB1bmRlcmx5aW5nIHtAbGluayBHZW9tZXRyeX0uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnBpbkZpcnN0TGV2ZWw9ZmFsc2VdIFdoZXRoZXIgdG8gcGluIHRoZSBmaXJzdCBsZXZlbCB0b1xuICogICAgIHByb3ZpZGUgYSBmYWxsYmFjayBvZiBsYXN0IHJlc29ydCwgYXQgdGhlIGNvc3Qgb2YgbWVtb3J5IGNvbnN1bXB0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnRleHR1cmVTdG9yZU9wdHM9e31dIE9wdGlvbnMgdG8gcGFzcyB0byB0aGVcbiAqICAgICB7QGxpbmsgVGV4dHVyZVN0b3JlfSBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5sYXllck9wdHM9e31dIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUge0BsaW5rIExheWVyfVxuICogICAgIGNvbnN0cnVjdG9yLlxuICogQHJldHVybiB7TGF5ZXJ9XG4gKi9cblNjZW5lLnByb3RvdHlwZS5jcmVhdGVMYXllciA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHRleHR1cmVTdG9yZU9wdHMgPSBvcHRzLnRleHR1cmVTdG9yZU9wdHMgfHwge307XG4gIHZhciBsYXllck9wdHMgPSBvcHRzLmxheWVyT3B0cyB8fCB7fTtcblxuICB2YXIgc291cmNlID0gb3B0cy5zb3VyY2U7XG4gIHZhciBnZW9tZXRyeSA9IG9wdHMuZ2VvbWV0cnk7XG4gIHZhciB2aWV3ID0gdGhpcy5fdmlldztcbiAgdmFyIHN0YWdlID0gdGhpcy5fdmlld2VyLnN0YWdlKCk7XG4gIHZhciB0ZXh0dXJlU3RvcmUgPSBuZXcgVGV4dHVyZVN0b3JlKHNvdXJjZSwgc3RhZ2UsIHRleHR1cmVTdG9yZU9wdHMpO1xuICB2YXIgbGF5ZXIgPSBuZXcgTGF5ZXIoc291cmNlLCBnZW9tZXRyeSwgdmlldywgdGV4dHVyZVN0b3JlLCBsYXllck9wdHMpO1xuXG4gIHRoaXMuX2xheWVycy5wdXNoKGxheWVyKTtcblxuICBpZiAob3B0cy5waW5GaXJzdExldmVsKSB7XG4gICAgbGF5ZXIucGluRmlyc3RMZXZlbCgpO1xuICB9XG5cbiAgLy8gU2lnbmFsIHRoYXQgdGhlIGxheWVycyBoYXZlIGNoYW5nZWQuXG4gIHRoaXMuZW1pdCgnbGF5ZXJDaGFuZ2UnKTtcblxuICByZXR1cm4gbGF5ZXI7XG59O1xuXG5cbi8qKlxuICogRGVzdHJveXMgYSB7QGxpbmsgTGF5ZXIgbGF5ZXJ9IGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIHNjZW5lLlxuICogQHBhcmFtIHtMYXllcn0gbGF5ZXJcbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGxheWVyIGRvZXMgbm90IGJlbG9uZyB0byB0aGUgc2NlbmUuXG4gKi9cblNjZW5lLnByb3RvdHlwZS5kZXN0cm95TGF5ZXIgPSBmdW5jdGlvbihsYXllcikge1xuICB2YXIgaSA9IHRoaXMuX2xheWVycy5pbmRleE9mKGxheWVyKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWNoIGxheWVyIGluIHNjZW5lJyk7XG4gIH1cblxuICB0aGlzLl9sYXllcnMuc3BsaWNlKGksIDEpO1xuXG4gIC8vIFNpZ25hbCB0aGF0IHRoZSBsYXllcnMgaGF2ZSBjaGFuZ2VkLlxuICB0aGlzLmVtaXQoJ2xheWVyQ2hhbmdlJyk7XG5cbiAgbGF5ZXIudGV4dHVyZVN0b3JlKCkuZGVzdHJveSgpO1xuICBsYXllci5kZXN0cm95KCk7XG59O1xuXG5cbi8qKlxuICogRGVzdHJveXMgYWxsIHtAbGluayBMYXllciBsYXllcnN9IGFuZCByZW1vdmVzIHRoZW0gZnJvbSB0aGUgc2NlbmUuXG4gKi9cblNjZW5lLnByb3RvdHlwZS5kZXN0cm95QWxsTGF5ZXJzID0gZnVuY3Rpb24oKSB7XG4gIHdoaWxlICh0aGlzLl9sYXllcnMubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuZGVzdHJveUxheWVyKHRoaXMuX2xheWVyc1swXSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTd2l0Y2hlcyB0byB0aGUgc2NlbmUuXG4gKlxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcge0BsaW5rIFZpZXdlciNzd2l0Y2hTY2VuZX0gb24gdGhpcyBzY2VuZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25zIHRvIHBhc3MgaW50byB7QGxpbmsgVmlld2VyI3N3aXRjaFNjZW5lfS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRvbmUgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBzd2l0Y2ggaXMgY29tcGxldGUuXG4gKi9cblNjZW5lLnByb3RvdHlwZS5zd2l0Y2hUbyA9IGZ1bmN0aW9uKG9wdHMsIGRvbmUpIHtcbiAgcmV0dXJuIHRoaXMuX3ZpZXdlci5zd2l0Y2hTY2VuZSh0aGlzLCBvcHRzLCBkb25lKTtcbn07XG5cblxuLyoqXG4gKiBUd2VlbnMgdGhlIHNjZW5lJ3MgdW5kZXJseWluZyB7QGxpbmsgVmlldyB2aWV3fS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRhcmdldCB2aWV3IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUcmFuc2l0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0cy5lYXNlPWVhc2VJbk91dFF1YWRdIFR3ZWVuIGVhc2luZyBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmNvbnRyb2xzSW50ZXJydXB0PWZhbHNlXSBhbGxvdyBjb250cm9scyB0byBpbnRlcnJ1cHRcbiAqICAgICBhbiBvbmdvaW5nIHR3ZWVuLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRyYW5zaXRpb25EdXJhdGlvbj0xMDAwXSBUd2VlbiBkdXJhdGlvbiwgaW5cbiAqICAgICBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuY2xvc2VzdD10cnVlXSBXaGV0aGVyIHRvIHR3ZWVuIHRocm91Z2ggdGhlIHNob3J0ZXN0XG4gKiAgICBwYXRoIGJldHdlZW4gdGhlIGluaXRpYWwgYW5kIGZpbmFsIHZpZXcgcGFyYW1ldGVycy4gVGhpcyByZXF1aXJlc1xuICogICAge0BsaW5rIFZpZXcjbm9ybWFsaXplVG9DbG9zZXN0fSB0byBiZSBpbXBsZW1lbnRlZCwgYW5kIGRvZXMgbm90aGluZ1xuICogICAgb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZG9uZSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHR3ZWVuIGZpbmlzaGVzIG9yIGlzXG4gKiAgICBpbnRlcnJ1cHRlZC5cbiAqL1xuU2NlbmUucHJvdG90eXBlLmxvb2tUbyA9IGZ1bmN0aW9uKHBhcmFtcywgb3B0cywgZG9uZSkge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgZG9uZSA9IGRvbmUgfHwgbm9vcDtcblxuICBpZiAodHlwZShwYXJhbXMpICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRhcmdldCB2aWV3IHBhcmFtZXRlcnMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIH1cblxuICAvLyBRdWFkcmF0aWMgaW4vb3V0IGVhc2luZy5cbiAgdmFyIGVhc2VJbk91dFF1YWQgPSBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogaztcbiAgICB9XG4gICAgcmV0dXJuIC0wLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuICB9O1xuXG4gIHZhciBlYXNlID0gb3B0cy5lYXNlICE9IG51bGwgPyBvcHRzLmVhc2UgOiBlYXNlSW5PdXRRdWFkO1xuICB2YXIgY29udHJvbHNJbnRlcnJ1cHQgPSBvcHRzLmNvbnRyb2xzSW50ZXJydXB0ICE9IG51bGwgPyBvcHRzLmNvbnRyb2xzSW50ZXJydXB0IDogZmFsc2U7XG4gIHZhciBkdXJhdGlvbiA9IG9wdHMudHJhbnNpdGlvbkR1cmF0aW9uICE9IG51bGwgPyBvcHRzLnRyYW5zaXRpb25EdXJhdGlvbiA6IDEwMDA7XG4gIHZhciBzaG9ydGVzdCA9IG9wdHMuc2hvcnRlc3QgIT0gbnVsbCA/IG9wdHMuc2hvcnRlc3QgOiB0cnVlO1xuXG4gIHZhciB2aWV3ID0gdGhpcy5fdmlldztcblxuICB2YXIgaW5pdGlhbFBhcmFtcyA9IHZpZXcucGFyYW1ldGVycygpO1xuXG4gIHZhciBmaW5hbFBhcmFtcyA9IHt9O1xuICBkZWZhdWx0cyhmaW5hbFBhcmFtcywgcGFyYW1zKTtcbiAgZGVmYXVsdHMoZmluYWxQYXJhbXMsIGluaXRpYWxQYXJhbXMpO1xuXG4gIC8vIFR3ZWVuIHRocm91Z2ggdGhlIHNob3J0ZXN0IHBhdGggaWYgcmVxdWVzdGVkLlxuICAvLyBUaGUgdmlldyBtdXN0IGltcGxlbWVudCB0aGUgbm9ybWFsaXplVG9DbG9zZXN0KCkgbWV0aG9kLlxuICBpZiAoc2hvcnRlc3QgJiYgdmlldy5ub3JtYWxpemVUb0Nsb3Nlc3QpIHtcbiAgICB2aWV3Lm5vcm1hbGl6ZVRvQ2xvc2VzdChmaW5hbFBhcmFtcywgZmluYWxQYXJhbXMpO1xuICB9XG5cbiAgdmFyIG1vdmVtZW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZmluYWxVcGRhdGUgPSBmYWxzZTtcblxuICAgIHJldHVybiBmdW5jdGlvbihwYXJhbXMsIGVsYXBzZWQpIHtcblxuICAgICAgaWYgKGVsYXBzZWQgPj0gZHVyYXRpb24gJiYgZmluYWxVcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWx0YSA9IE1hdGgubWluKGVsYXBzZWQgLyBkdXJhdGlvbiwgMSk7XG5cbiAgICAgIGZvciAodmFyIHBhcmFtIGluIHBhcmFtcykge1xuICAgICAgICB2YXIgc3RhcnQgPSBpbml0aWFsUGFyYW1zW3BhcmFtXTtcbiAgICAgICAgdmFyIGVuZCA9IGZpbmFsUGFyYW1zW3BhcmFtXTtcbiAgICAgICAgcGFyYW1zW3BhcmFtXSA9IHN0YXJ0ICsgZWFzZShkZWx0YSkgKiAoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBmaW5hbFVwZGF0ZSA9IGVsYXBzZWQgPj0gZHVyYXRpb247XG5cbiAgICAgIHJldHVybiBwYXJhbXM7XG5cbiAgICB9O1xuICB9O1xuXG4gIHZhciByZWVuYWJsZUNvbnRyb2xzID0gdGhpcy5fdmlld2VyLmNvbnRyb2xzKCkuZW5hYmxlZCgpO1xuXG4gIGlmICghY29udHJvbHNJbnRlcnJ1cHQpIHtcbiAgICB0aGlzLl92aWV3ZXIuY29udHJvbHMoKS5kaXNhYmxlKCk7XG4gIH1cblxuICB0aGlzLnN0YXJ0TW92ZW1lbnQobW92ZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgIGlmIChyZWVuYWJsZUNvbnRyb2xzKSB7XG4gICAgICB0aGlzLl92aWV3ZXIuY29udHJvbHMoKS5lbmFibGUoKTtcbiAgICB9XG4gICAgZG9uZSgpO1xuICB9KTtcblxufTtcblxuXG4vKipcbiAqIFN0YXJ0cyBhIG1vdmVtZW50LCBwb3NzaWJseSByZXBsYWNpbmcgdGhlIGN1cnJlbnQgbW92ZW1lbnQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIG1vdmVtZW50IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZG9uZSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgbW92ZW1lbnQgZmluaXNoZXMgb3IgaXNcbiAqICAgICBpbnRlcnJ1cHRlZC5cbiAqL1xuU2NlbmUucHJvdG90eXBlLnN0YXJ0TW92ZW1lbnQgPSBmdW5jdGlvbihmbiwgZG9uZSkge1xuXG4gIHZhciByZW5kZXJMb29wID0gdGhpcy5fdmlld2VyLnJlbmRlckxvb3AoKTtcblxuICBpZiAodGhpcy5fbW92ZW1lbnQpIHtcbiAgICB0aGlzLnN0b3BNb3ZlbWVudCgpO1xuICB9XG5cbiAgdmFyIHN0ZXAgPSBmbigpO1xuICBpZiAodHlwZW9mIHN0ZXAgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBtb3ZlbWVudCcpO1xuICB9XG5cbiAgdGhpcy5fbW92ZW1lbnQgPSBmbjtcbiAgdGhpcy5fbW92ZW1lbnRTdGVwID0gc3RlcDtcbiAgdGhpcy5fbW92ZW1lbnRTdGFydFRpbWUgPSBub3coKTtcbiAgdGhpcy5fbW92ZW1lbnRQYXJhbXMgPSB7fTtcbiAgdGhpcy5fbW92ZW1lbnRDYWxsYmFjayA9IGRvbmU7XG5cbiAgcmVuZGVyTG9vcC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmVSZW5kZXInLCB0aGlzLl91cGRhdGVNb3ZlbWVudEhhbmRsZXIpO1xuICByZW5kZXJMb29wLnJlbmRlck9uTmV4dEZyYW1lKCk7XG59O1xuXG5cbi8qKlxuICogU3RvcHMgdGhlIGN1cnJlbnQgbW92ZW1lbnQuXG4gKi9cblNjZW5lLnByb3RvdHlwZS5zdG9wTW92ZW1lbnQgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgcmVuZGVyTG9vcCA9IHRoaXMuX3ZpZXdlci5yZW5kZXJMb29wKCk7XG5cbiAgaWYgKCF0aGlzLl9tb3ZlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLl9tb3ZlbWVudENhbGxiYWNrKSB7XG4gICAgdGhpcy5fbW92ZW1lbnRDYWxsYmFjaygpO1xuICB9XG5cbiAgcmVuZGVyTG9vcC5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmVSZW5kZXInLCB0aGlzLl91cGRhdGVNb3ZlbWVudEhhbmRsZXIpO1xuXG4gIHRoaXMuX21vdmVtZW50ID0gbnVsbDtcbiAgdGhpcy5fbW92ZW1lbnRTdGVwID0gbnVsbDtcbiAgdGhpcy5fbW92ZW1lbnRTdGFydFRpbWUgPSBudWxsO1xuICB0aGlzLl9tb3ZlbWVudFBhcmFtcyA9IG51bGw7XG4gIHRoaXMuX21vdmVtZW50Q2FsbGJhY2sgPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbW92ZW1lbnQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuU2NlbmUucHJvdG90eXBlLm1vdmVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9tb3ZlbWVudDtcbn07XG5cblxuU2NlbmUucHJvdG90eXBlLl91cGRhdGVNb3ZlbWVudCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICghdGhpcy5fbW92ZW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgY2FsbCB1cGRhdGUnKTtcbiAgfVxuXG4gIHZhciByZW5kZXJMb29wID0gdGhpcy5fdmlld2VyLnJlbmRlckxvb3AoKTtcbiAgdmFyIHZpZXcgPSB0aGlzLl92aWV3O1xuXG4gIHZhciBlbGFwc2VkID0gbm93KCkgLSB0aGlzLl9tb3ZlbWVudFN0YXJ0VGltZTtcbiAgdmFyIHN0ZXAgPSB0aGlzLl9tb3ZlbWVudFN0ZXA7XG4gIHZhciBwYXJhbXMgPSB0aGlzLl9tb3ZlbWVudFBhcmFtcztcblxuICBwYXJhbXMgPSB2aWV3LnBhcmFtZXRlcnMocGFyYW1zKTtcbiAgcGFyYW1zID0gc3RlcChwYXJhbXMsIGVsYXBzZWQpO1xuICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICB0aGlzLnN0b3BNb3ZlbWVudCgpO1xuICB9IGVsc2Uge1xuICAgIHZpZXcuc2V0UGFyYW1ldGVycyhwYXJhbXMpO1xuICAgIHJlbmRlckxvb3AucmVuZGVyT25OZXh0RnJhbWUoKTtcbiAgfVxuXG59O1xuXG5cblNjZW5lLnByb3RvdHlwZS5fdXBkYXRlSG90c3BvdENvbnRhaW5lciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy52aXNpYmxlKCkpIHtcbiAgICB0aGlzLl9ob3RzcG90Q29udGFpbmVyLnNob3coKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ob3RzcG90Q29udGFpbmVyLmhpZGUoKTtcbiAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjZW5lO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTWFwID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9ucy9NYXAnKTtcbnZhciBTZXQgPSByZXF1aXJlKCcuL2NvbGxlY3Rpb25zL1NldCcpO1xudmFyIExydVNldCA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbnMvTHJ1U2V0Jyk7XG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL3V0aWwvZGVmYXVsdHMnKTtcbnZhciByZXRyeSA9IHJlcXVpcmUoJy4vdXRpbC9yZXRyeScpO1xudmFyIGNoYWluID0gcmVxdWlyZSgnLi91dGlsL2NoYWluJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuL3V0aWwvaW5oZXJpdHMnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBkZWJ1ZyA9IHR5cGVvZiBNQVJaSVBBTk9ERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgTUFSWklQQU5PREVCVUcudGV4dHVyZVN0b3JlO1xuXG5cbi8vIEEgU3RhZ2UgaW5mb3JtcyB0aGUgVGV4dHVyZVN0b3JlIGFib3V0IHRoZSBzZXQgb2YgdmlzaWJsZSB0aWxlcyBkdXJpbmcgYVxuLy8gZnJhbWUgYnkgY2FsbGluZyBzdGFydEZyYW1lLCBtYXJrVGlsZSBhbmQgZW5kRnJhbWUuIEluIGEgcGFydGljdWxhciBmcmFtZSxcbi8vIFRleHR1cmVTdG9yZSBleHBlY3RzIG9uZSBvciBtb3JlIGNhbGxzIHRvIHN0YXJ0RnJhbWUsIGZvbGxvd2VkIGJ5IHplcm8gb3Jcbi8vIG1vcmUgY2FsbHMgdG8gbWFya1RpbGUsIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGNhbGxzIHRvIGVuZEZyYW1lLiBUaGVcbi8vIG51bWJlciBvZiBjYWxscyB0byBzdGFydEZyYW1lIGFuZCBlbmRGcmFtZSBtdXN0IG1hdGNoLiBDYWxscyB0byBvdGhlclxuLy8gVGV4dHVyZVN0b3JlIG1ldGhvZHMgbWF5IGJlIGZyZWVseSBpbnRlcmxlYXZlZCB3aXRoIHRoaXMgc2VxdWVuY2UuXG4vL1xuLy8gQXQgYW55IGdpdmVuIHRpbWUsIFRleHR1cmVTdG9yZSBpcyBpbiBvbmUgb2YgZm91ciBzdGF0ZXMuIFRoZSBTVEFSVCBzdGF0ZVxuLy8gY29ycmVzcG9uZHMgdG8gdGhlIGludGVydmFsIGJldHdlZW4gdGhlIGZpcnN0IHN0YXJ0RnJhbWUgYW5kIHRoZSBmaXJzdFxuLy8gbWFya1RpbGUgb2YgYSBmcmFtZS4gVGhlIE1BUksgc3RhdGUgY29ycmVzcG9uZHMgdG8gdGhlIGludGVydmFsIGJldHdlZW4gdGhlXG4vLyBmaXJzdCBtYXJrVGlsZSBhbmQgdGhlIGZpcnN0IGVuZEZyYW1lLiBUaGUgRU5EIHN0YXRlIGNvcnJlc3BvbmRzIHRvIHRoZVxuLy8gaW50ZXJ2YWwgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIHRoZSBsYXN0IGVuZEZyYW1lLiBBdCBhbnkgb3RoZXIgdGltZSwgdGhlXG4vLyBUZXh0dXJlU3RvcmUgaXMgaW4gdGhlIElETEUgc3RhdGUuXG52YXIgU3RhdGUgPSB7XG4gIElETEU6IDAsXG4gIFNUQVJUOiAxLFxuICBNQVJLOiAyLFxuICBFTkQ6IDNcbn07XG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAvLyBNYXhpbXVtIG51bWJlciBvZiBjYWNoZWQgdGV4dHVyZXMgZm9yIHByZXZpb3VzbHkgdmlzaWJsZSB0aWxlcy5cbiAgcHJldmlvdXNseVZpc2libGVDYWNoZVNpemU6IDUxMlxufTtcblxuXG4vLyBBc3NpZ24gYW4gaWQgdG8gZWFjaCBvcGVyYXRpb24gc28gd2UgY2FuIHRyYWNrIGl0cyBzdGF0ZS5cbi8vIFdlIGFjdHVhbGx5IG9ubHkgbmVlZCB0aGlzIGluIGRlYnVnIG1vZGUsIGJ1dCB0aGUgY29kZSBpcyBsZXNzIGNvbnZvbHV0ZWRcbi8vIGlmIHdlIHRyYWNrIHVuY29uZGl0aW9uYWxseSwgYW5kIHRoZSBwZXJmb3JtYW5jZSBoaXQgaXMgbWluaW1hbCBhbnl3YXkuXG52YXIgbmV4dElkID0gMDtcblxuXG4vLyBEaXN0aW5ndWlzaGVzIGEgY2FuY2VsbGF0aW9uIGZyb20gb3RoZXIga2luZHMgb2YgZXJyb3JzLlxuZnVuY3Rpb24gQ2FuY2VsRXJyb3IoKSB7fVxuaW5oZXJpdHMoQ2FuY2VsRXJyb3IsIEVycm9yKTtcblxuXG4vKipcbiAqIEBjbGFzcyBUZXh0dXJlU3RvcmVJdGVtXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQW4gaXRlbSBzYXZlZCBpbiBhIHtAbGluayBUZXh0dXJlU3RvcmV9LlxuICpcbiAqIENsaWVudHMgZG8gbm90IG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy4gSXQgaXMgYXV0b21hdGljYWxseSBpbnN0YW50aWF0ZWQgYnlcbiAqIGEge0BsaW5rIFRleHR1cmVTdG9yZX0gdG8gbWFuYWdlIHRoZSBsaWZldGltZSBvZiBhIHN0b3JlZCBpdGVtOiBsb2FkaW5nLFxuICogcmVmcmVzaGluZywgdW5sb2FkaW5nIGFuZCBlbWl0dGluZyBhc3NvY2lhdGVkIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge1RleHR1cmVTdG9yZX0gc3RvcmUgVGhlIHVuZGVybHlpbmcge0BsaW5rIFRleHR1cmVTdG9yZX0uXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgVGhlIHVuZGVybHlpbmcgdGlsZS5cbiAqL1xuZnVuY3Rpb24gVGV4dHVyZVN0b3JlSXRlbShzdG9yZSwgdGlsZSkge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgaWQgPSBuZXh0SWQrKztcblxuICBzZWxmLl9pZCA9IGlkO1xuICBzZWxmLl9zdG9yZSA9IHN0b3JlO1xuICBzZWxmLl90aWxlID0gdGlsZTtcblxuICBzZWxmLl9hc3NldCA9IG51bGw7XG4gIHNlbGYuX3RleHR1cmUgPSBudWxsO1xuXG4gIHNlbGYuX2NoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICBzdG9yZS5lbWl0KCd0ZXh0dXJlSW52YWxpZCcsIHRpbGUpO1xuICB9O1xuXG4gIHZhciBzb3VyY2UgPSBzdG9yZS5zb3VyY2UoKTtcbiAgdmFyIHN0YWdlID0gc3RvcmUuc3RhZ2UoKTtcblxuICB2YXIgbG9hZEFzc2V0ID0gc291cmNlLmxvYWRBc3NldC5iaW5kKHNvdXJjZSk7XG4gIHZhciBjcmVhdGVUZXh0dXJlID0gc3RhZ2UuY3JlYXRlVGV4dHVyZS5iaW5kKHN0YWdlKTtcblxuICAvLyBSZXRyeSBsb2FkaW5nIHRoZSBhc3NldCB1bnRpbCBpdCBzdWNjZWVkcywgdGhlbiBjcmVhdGUgdGhlIHRleHR1cmUgZnJvbSBpdC5cbiAgLy8gVGhpcyBwcm9jZXNzIG1heSBiZSBjYW5jZWxlZCBhdCBhbnkgcG9pbnQgYnkgY2FsbGluZyB0aGUgZGVzdHJveSgpIG1ldGhvZC5cbiAgdmFyIGZuID0gY2hhaW4ocmV0cnkobG9hZEFzc2V0KSwgY3JlYXRlVGV4dHVyZSk7XG5cbiAgc3RvcmUuZW1pdCgndGV4dHVyZVN0YXJ0TG9hZCcsIHRpbGUpO1xuICBpZiAoZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZygnbG9hZGluZycsIGlkLCB0aWxlKTtcbiAgfVxuXG4gIHNlbGYuX2NhbmNlbCA9IGZuKHN0YWdlLCB0aWxlLCBmdW5jdGlvbihlcnIsIF90aWxlLCBhc3NldCwgdGV4dHVyZSkge1xuXG4gICAgLy8gTWFrZSBzdXJlIHdlIGRvIG5vdCBjYWxsIGNhbmNlbCBhZnRlciB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgIHNlbGYuX2NhbmNlbCA9IG51bGw7XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICAvLyBUaGUgbG9hZGluZyBwcm9jZXNzIHdhcyBpbnRlcnJ1cHRlZCBieSBhbiBlcnJvci5cbiAgICAgIC8vIFRoaXMgY291bGQgZWl0aGVyIGJlIGJlY2F1c2UgdGhlIHRleHR1cmUgY3JlYXRpb24gZmFpbGVkLCBvciBiZWNhdXNlXG4gICAgICAvLyB0aGUgb3BlcmF0aW9uIHdhcyBjYW5jZWxlZCBiZWZvcmUgdGhlIGxvYWRpbmcgd2FzIGNvbXBsZXRlLlxuXG4gICAgICAvLyBEZXN0cm95IHRoZSBhc3NldCBhbmQgdGV4dHVyZSwgaWYgdGhleSBleGlzdC5cbiAgICAgIGlmIChhc3NldCkge1xuICAgICAgICBhc3NldC5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBpZiAodGV4dHVyZSkge1xuICAgICAgICB0ZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgLy8gRW1pdCBldmVudHMuXG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ2FuY2VsRXJyb3IpIHtcbiAgICAgICAgc3RvcmUuZW1pdCgndGV4dHVyZUNhbmNlbCcsIHRpbGUpO1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnY2FuY2VsJywgaWQsIHRpbGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZS5lbWl0KCd0ZXh0dXJlRXJyb3InLCB0aWxlLCBlcnIpO1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnZXJyb3InLCBpZCwgdGlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNhdmUgYSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIHRleHR1cmUuXG4gICAgc2VsZi5fdGV4dHVyZSA9IHRleHR1cmU7XG5cbiAgICAvLyBJZiB0aGUgYXNzZXQgaXMgZHluYW1pYywgc2F2ZSBhIGxvY2FsIHJlZmVyZW5jZSB0byBpdCBhbmQgc2V0IHVwIGFcbiAgICAvLyBoYW5kbGVyIHRvIGJlIGNhbGxlZCB3aGVuZXZlciBpdCBjaGFuZ2VzLiBPdGhlcndpc2UsIGRlc3Ryb3kgdGhlIGFzc2V0XG4gICAgLy8gYXMgd2Ugd29uJ3QgYmUgbmVlZGluZyBpdCBhbnkgbG9uZ2VyLlxuICAgIGlmIChhc3NldC5pc0R5bmFtaWMoKSkge1xuICAgICAgc2VsZi5fYXNzZXQgPSBhc3NldDtcbiAgICAgIGFzc2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHNlbGYuX2NoYW5nZUhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NldC5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLy8gRW1pdCBldmVudC5cbiAgICBzdG9yZS5lbWl0KCd0ZXh0dXJlTG9hZCcsIHRpbGUpO1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coJ2xvYWQnLCBpZCwgdGlsZSk7XG4gICAgfVxuICB9KTtcblxufVxuXG5cblRleHR1cmVTdG9yZUl0ZW0ucHJvdG90eXBlLmFzc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9hc3NldDtcbn07XG5cblxuVGV4dHVyZVN0b3JlSXRlbS5wcm90b3R5cGUudGV4dHVyZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdGV4dHVyZTtcbn07XG5cblxuVGV4dHVyZVN0b3JlSXRlbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcbiAgdmFyIHN0b3JlID0gdGhpcy5fc3RvcmU7XG4gIHZhciB0aWxlID0gdGhpcy5fdGlsZTtcbiAgdmFyIGFzc2V0ID0gdGhpcy5fYXNzZXQ7XG4gIHZhciB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgdmFyIGNhbmNlbCA9IHRoaXMuX2NhbmNlbDtcblxuICBpZiAoY2FuY2VsKSB7XG4gICAgLy8gVGhlIHRleHR1cmUgaXMgc3RpbGwgbG9hZGluZywgc28gY2FuY2VsIGl0LlxuICAgIGNhbmNlbChuZXcgQ2FuY2VsRXJyb3IoJ1RleHR1cmUgbG9hZCBjYW5jZWxsZWQnKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVzdHJveSBhc3NldC5cbiAgaWYgKGFzc2V0KSB7XG4gICAgYXNzZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fY2hhbmdlSGFuZGxlcik7XG4gICAgYXNzZXQuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gRGVzdHJveSB0ZXh0dXJlLlxuICBpZiAodGV4dHVyZSkge1xuICAgIHRleHR1cmUuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gRW1pdCBldmVudC5cbiAgc3RvcmUuZW1pdCgndGV4dHVyZVVubG9hZCcsIHRpbGUpO1xuICBpZiAoZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZygndW5sb2FkJywgaWQsIHRpbGUpO1xuICB9XG5cbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuZXZlbnRFbWl0dGVyKFRleHR1cmVTdG9yZUl0ZW0pO1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHRleHR1cmUgaGFzIHN0YXJ0ZWQgdG8gbG9hZC5cbiAqXG4gKiBUaGlzIGV2ZW50IGlzIGZvbGxvd2VkIGJ5IGVpdGhlciB7QGxpbmsgVGV4dHVyZVN0b3JlI3RleHR1cmVMb2FkfSxcbiAqIHtAbGluayBUZXh0dXJlU3RvcmUjdGV4dHVyZUVycm9yfSBvciB7QGxpbmsgVGV4dHVyZVN0b3JlI3RleHR1cmVDYW5jZWx9LlxuICpcbiAqIEBldmVudCBUZXh0dXJlU3RvcmUjdGV4dHVyZVN0YXJ0TG9hZFxuICogQHBhcmFtIHtUaWxlfSB0aWxlIFRoZSB0aWxlIGZvciB3aGljaCB0aGUgdGV4dHVyZSBoYXMgc3RhcnRlZCB0byBsb2FkLlxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGEgdGV4dHVyZSBoYXMgYmVlbiBsb2FkZWQuXG4gKlxuICogQGV2ZW50IFRleHR1cmVTdG9yZSN0ZXh0dXJlTG9hZFxuICogQHBhcmFtIHtUaWxlfSB0aWxlIFRoZSB0aWxlIGZvciB3aGljaCB0aGUgdGV4dHVyZSB3YXMgbG9hZGVkLlxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGEgdGV4dHVyZSBoYXMgYmVlbiB1bmxvYWRlZC5cbiAqXG4gKiBAZXZlbnQgVGV4dHVyZVN0b3JlI3RleHR1cmVVbmxvYWRcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgdGlsZSBmb3Igd2hpY2ggdGhlIHRleHR1cmUgd2FzIHVubG9hZGVkLlxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGEgdGV4dHVyZSBoYXMgYmVlbiBpbnZhbGlkYXRlZC5cbiAqXG4gKiBUaGlzIGV2ZW50IG1heSBiZSByYWlzZWQgZm9yIGEgdGV4dHVyZSB3aXRoIGFuIHVuZGVybHlpbmcgZHluYW1pYyBhc3NldC4gSXRcbiAqIG1heSBvbmx5IG9jY3VyIHdoaWxlIHRoZSB0ZXh0dXJlIGlzIGxvYWRlZCwgaS5lLiwgaW4gYmV0d2VlblxuICoge0BsaW5rIFRleHR1cmVTdG9yZSN0ZXh0dXJlTG9hZH0gYW5kIHtAbGluayBUZXh0dXJlU3RvcmUjdGV4dHVyZVVubG9hZH0uXG4gKlxuICogQGV2ZW50IFRleHR1cmVTdG9yZSN0ZXh0dXJlSW52YWxpZFxuICogQHBhcmFtIHtUaWxlfSB0aWxlIFRoZSB0aWxlIGZvciB3aGljaCB0aGUgdGV4dHVyZSB3YXMgaW52YWxpZGF0ZWQuXG4gKi9cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgbG9hZGluZyBhIHRleHR1cmUgaGFzIGJlZW4gY2FuY2VsbGVkLlxuICpcbiAqIFRoaXMgZXZlbnQgbWF5IGZvbGxvdyB7QGxpbmsgVGV4dHVyZVN0b3JlI3RleHR1cmVTdGFydExvYWR9IGlmIHRoZSB0ZXh0dXJlXG4gKiBiZWNvbWVzIHVubmVjZXNzYXJ5IGJlZm9yZSBpdCBmaW5pc2hlcyBsb2FkaW5nLlxuICpcbiAqIEBldmVudCBUZXh0dXJlU3RvcmUjdGV4dHVyZUNhbmNlbFxuICogQHBhcmFtIHtUaWxlfSB0aWxlIFRoZSB0aWxlIGZvciB3aGljaCB0aGUgdGV4dHVyZSBsb2FkaW5nIHdhcyBjYW5jZWxsZWQuXG4gKi9cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgbG9hZGluZyBhIHRleHR1cmUgaGFzIGZhaWxlZC5cbiAqXG4gKiBUaGlzIGV2ZW50IG1heSBmb2xsb3cge0BsaW5rIFRleHR1cmVTdG9yZSN0ZXh0dXJlU3RhcnRMb2FkfSBpZiB0aGUgdGV4dHVyZVxuICogZmFpbHMgdG8gbG9hZC5cbiAqXG4gKiBAZXZlbnQgVGV4dHVyZVN0b3JlI3RleHR1cmVFcnJvclxuICogQHBhcmFtIHtUaWxlfSB0aWxlIFRoZSB0aWxlIGZvciB3aGljaCB0aGUgdGV4dHVyZSBsb2FkaW5nIGhhcyBmYWlsZWQuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgVGV4dHVyZVN0b3JlXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSBUZXh0dXJlU3RvcmUgbWFpbnRhaW5zIGEgY2FjaGUgb2YgdGV4dHVyZXMgdXNlZCB0byByZW5kZXIgYSB7QGxpbmsgTGF5ZXJ9LlxuICpcbiAqIEEge0BsaW5rIFN0YWdlfSBjb21tdW5pY2F0ZXMgd2l0aCB0aGUgVGV4dHVyZVN0b3JlIHRocm91Z2ggdGhlIHN0YXJ0RnJhbWUoKSxcbiAqIG1hcmtUaWxlKCkgYW5kIGVuZEZyYW1lKCkgbWV0aG9kcywgd2hpY2ggaW5kaWNhdGUgdGhlIHRpbGVzIHRoYXQgYXJlIHZpc2libGVcbiAqIGluIHRoZSBjdXJyZW50IGZyYW1lLiBUZXh0dXJlcyBmb3IgdmlzaWJsZSB0aWxlcyBhcmUgbG9hZGVkIGFuZCByZXRhaW5lZFxuICogYXMgbG9uZyBhcyB0aGUgdGlsZXMgcmVtYWluIHZpc2libGUuIEEgbGltaXRlZCBhbW91bnQgb2YgdGV4dHVyZXMgd2hvc2VcbiAqIHRpbGVzIHdlcmUgcHJldmlvdXNseSB2aXNpYmxlIGFyZSBjYWNoZWQgYWNjb3JkaW5nIHRvIGFuIExSVSBwb2xpY3kuIFRpbGVzXG4gKiBtYXkgYmUgcGlubmVkIHRvIGtlZXAgdGhlaXIgcmVzcGVjdGl2ZSB0ZXh0dXJlcyBjYWNoZWQgZXZlbiB3aGVuIHRoZXkgYXJlXG4gKiBpbnZpc2libGU7IHRoZXNlIHRleHR1cmVzIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBwcmV2aW91c2x5IHZpc2libGUgbGltaXQuXG4gKlxuICogTXVsdGlwbGUgbGF5ZXJzIGJlbG9uZ2luZyB0byB0aGUgc2FtZSB1bmRlcmx5aW5nIHtAbGluayBXZWJHbFN0YWdlfSBtYXlcbiAqIHNoYXJlIHRoZSBzYW1lIFRleHR1cmVTdG9yZS4gTGF5ZXJzIGJlbG9uZ2luZyB0byBkaXN0aW5jdCB7QGxpbmsgV2ViR2xTdGFnZX1cbiAqIGluc3RhbmNlcyBtYXkgbm90IGRvIHNvIGR1ZSB0byByZXN0cmljdGlvbnMgb24gdGhlIHVzZSBvZiB0ZXh0dXJlcyBhY3Jvc3NcbiAqIHN0YWdlcy5cbiAqXG4gKiBAcGFyYW0ge1NvdXJjZX0gc291cmNlIFRoZSB1bmRlcmx5aW5nIHNvdXJjZS5cbiAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlIFRoZSB1bmRlcmx5aW5nIHN0YWdlLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9ucy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy5wcmV2aW91c2x5VmlzaWJsZUNhY2hlU2l6ZT0zMl0gVGhlIG1heGltdW0gbnVtYmVyIG9mXG4gKiAgICAgcHJldmlvdXNseSB2aXNpYmxlIHRleHR1cmVzIHRvIGNhY2hlIGFjY29yZGluZyB0byBhbiBMUlUgcG9saWN5LlxuICovXG5mdW5jdGlvbiBUZXh0dXJlU3RvcmUoc291cmNlLCBzdGFnZSwgb3B0cykge1xuICBvcHRzID0gZGVmYXVsdHMob3B0cyB8fCB7fSwgZGVmYXVsdE9wdGlvbnMpO1xuXG4gIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy5fc3RhZ2UgPSBzdGFnZTtcblxuICAvLyBUaGUgY3VycmVudCBzdGF0ZS5cbiAgdGhpcy5fc3RhdGUgPSBTdGF0ZS5JRExFO1xuXG4gIC8vIFRoZSBudW1iZXIgb2Ygc3RhcnRGcmFtZSBjYWxscyB5ZXQgdG8gYmUgbWF0Y2hlZCBieSBlbmRGcmFtZSBjYWxscyBkdXJpbmdcbiAgLy8gdGhlIGN1cnJlbnQgZnJhbWUuXG4gIHRoaXMuX2RlbGltQ291bnQgPSAwO1xuXG4gIC8vIFRoZSBjYWNoZSBwcm9wZXI6IG1hcCBjYWNoZWQgdGlsZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSB0ZXh0dXJlcy9hc3NldHMuXG4gIHRoaXMuX2l0ZW1NYXAgPSBuZXcgTWFwKCk7XG5cbiAgLy8gVGhlIHN1YnNldCBvZiBjYWNoZWQgdGlsZXMgdGhhdCBhcmUgY3VycmVudGx5IHZpc2libGUuXG4gIHRoaXMuX3Zpc2libGUgPSBuZXcgU2V0KCk7XG5cbiAgLy8gVGhlIHN1YnNldCBvZiBjYWNoZWQgdGlsZXMgdGhhdCB3ZXJlIHZpc2libGUgcmVjZW50bHksIGJ1dCBhcmUgbm90XG4gIC8vIHZpc2libGUgcmlnaHQgbm93LiBOZXdseSBpbnNlcnRlZCB0aWxlcyByZXBsYWNlIG9sZGVyIG9uZXMuXG4gIHRoaXMuX3ByZXZpb3VzbHlWaXNpYmxlID0gbmV3IExydVNldChvcHRzLnByZXZpb3VzbHlWaXNpYmxlQ2FjaGVTaXplKTtcblxuICAvLyBUaGUgc3Vic2V0IG9mIGNhY2hlZCB0aWxlcyB0aGF0IHNob3VsZCBuZXZlciBiZSBldmljdGVkIGZyb20gdGhlIGNhY2hlLlxuICAvLyBBIHRpbGUgbWF5IGJlIHBpbm5lZCBtb3JlIHRoYW4gb25jZTsgbWFwIGVhY2ggdGlsZSBpbnRvIGEgcmVmZXJlbmNlIGNvdW50LlxuICB0aGlzLl9waW5NYXAgPSBuZXcgTWFwKCk7XG5cbiAgLy8gVGVtcG9yYXJ5IHZhcmlhYmxlcy5cbiAgdGhpcy5fbmV3VmlzaWJsZSA9IG5ldyBTZXQoKTtcbiAgdGhpcy5fbm9Mb25nZXJWaXNpYmxlID0gW107XG4gIHRoaXMuX3Zpc2libGVBZ2FpbiA9IFtdO1xuICB0aGlzLl9ldmljdGVkID0gW107XG59XG5cbmV2ZW50RW1pdHRlcihUZXh0dXJlU3RvcmUpO1xuXG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY2xlYXIoKTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUgdW5kZXJseWluZyB7QGxpbmsgU3RhZ2V9LlxuICogQHJldHVybiB7U3RhZ2V9XG4gKi9cblRleHR1cmVTdG9yZS5wcm90b3R5cGUuc3RhZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3N0YWdlO1xufTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUgdW5kZXJseWluZyB7QGxpbmsgU291cmNlfS5cbiAqIEByZXR1cm4ge1NvdXJjZX1cbiAqL1xuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3NvdXJjZTtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmUgYWxsIHRleHR1cmVzIGZyb20gdGhlIFRleHR1cmVTdG9yZSwgaW5jbHVkaW5nIHBpbm5lZCB0ZXh0dXJlcy5cbiAqL1xuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gQ29sbGVjdCBsaXN0IG9mIHRpbGVzIHRvIGJlIGV2aWN0ZWQuXG4gIHNlbGYuX2V2aWN0ZWQubGVuZ3RoID0gMDtcbiAgc2VsZi5faXRlbU1hcC5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUpIHtcbiAgICBzZWxmLl9ldmljdGVkLnB1c2godGlsZSk7XG4gIH0pO1xuXG4gIC8vIEV2aWN0IHRpbGVzLlxuICBzZWxmLl9ldmljdGVkLmZvckVhY2goZnVuY3Rpb24odGlsZSkge1xuICAgIHNlbGYuX3VubG9hZFRpbGUodGlsZSk7XG4gIH0pO1xuXG4gIC8vIENsZWFyIGFsbCBpbnRlcm5hbCBzdGF0ZS5cbiAgc2VsZi5faXRlbU1hcC5jbGVhcigpO1xuICBzZWxmLl92aXNpYmxlLmNsZWFyKCk7XG4gIHNlbGYuX3ByZXZpb3VzbHlWaXNpYmxlLmNsZWFyKCk7XG4gIHNlbGYuX3Bpbk1hcC5jbGVhcigpO1xuICBzZWxmLl9uZXdWaXNpYmxlLmNsZWFyKCk7XG4gIHNlbGYuX25vTG9uZ2VyVmlzaWJsZS5sZW5ndGggPSAwO1xuICBzZWxmLl92aXNpYmxlQWdhaW4ubGVuZ3RoID0gMDtcbiAgc2VsZi5fZXZpY3RlZC5sZW5ndGggPSAwO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZSBhbGwgdGV4dHVyZXMgaW4gdGhlIFRleHR1cmVTdG9yZSwgZXhjbHVkaW5nIHVucGlubmVkIHRleHR1cmVzLlxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLmNsZWFyTm90UGlubmVkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBDb2xsZWN0IGxpc3Qgb2YgdGlsZXMgdG8gYmUgZXZpY3RlZC5cbiAgc2VsZi5fZXZpY3RlZC5sZW5ndGggPSAwO1xuICBzZWxmLl9pdGVtTWFwLmZvckVhY2goZnVuY3Rpb24odGlsZSkge1xuICAgIGlmICghc2VsZi5fcGluTWFwLmhhcyh0aWxlKSkge1xuICAgICAgc2VsZi5fZXZpY3RlZC5wdXNoKHRpbGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRXZpY3QgdGlsZXMuXG4gIHNlbGYuX2V2aWN0ZWQuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgc2VsZi5fdW5sb2FkVGlsZSh0aWxlKTtcbiAgfSk7XG5cbiAgLy8gQ2xlYXIgYWxsIGNhY2hlcyBleGNlcHQgdGhlIHBpbm5lZCBzZXQuXG4gIHNlbGYuX3Zpc2libGUuY2xlYXIoKTtcbiAgc2VsZi5fcHJldmlvdXNseVZpc2libGUuY2xlYXIoKTtcblxuICAvLyBDbGVhciB0ZW1wb3JhcnkgdmFyaWFibGVzLlxuICBzZWxmLl9ldmljdGVkLmxlbmd0aCA9IDA7XG59O1xuXG5cbi8qKlxuICogU2lnbmFsIHRoZSBiZWdpbm5pbmcgb2YgYSBmcmFtZS4gQ2FsbGVkIGZyb20ge0BsaW5rIFN0YWdlfS5cbiAqL1xuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5zdGFydEZyYW1lID0gZnVuY3Rpb24oKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgYXJlIGluIGFuIGFwcHJvcHJpYXRlIHN0YXRlLlxuICBpZiAodGhpcy5fc3RhdGUgIT09IFN0YXRlLklETEUgJiYgdGhpcy5fc3RhdGUgIT09IFN0YXRlLlNUQVJUKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlU3RvcmU6IHN0YXJ0RnJhbWUgY2FsbGVkIG91dCBvZiBzZXF1ZW5jZScpO1xuICB9XG5cbiAgLy8gRW50ZXIgdGhlIFNUQVJUIHN0YXRlLCBpZiBub3QgYWxyZWFkeSB0aGVyZS5cbiAgdGhpcy5fc3RhdGUgPSBTdGF0ZS5TVEFSVDtcblxuICAvLyBFeHBlY3Qgb25lIG1vcmUgZW5kRnJhbWUgY2FsbC5cbiAgdGhpcy5fZGVsaW1Db3VudCsrO1xufTtcblxuXG4vKipcbiAqIE1hcmsgYSB0aWxlIGFzIHZpc2libGUgd2l0aGluIHRoZSBjdXJyZW50IGZyYW1lLiBDYWxsZWQgZnJvbSB7QGxpbmsgU3RhZ2V9LlxuICogQHBhcmFtIHtUaWxlfSB0aWxlIFRoZSB0aWxlIHRvIG1hcmsuXG4gKi9cblRleHR1cmVTdG9yZS5wcm90b3R5cGUubWFya1RpbGUgPSBmdW5jdGlvbih0aWxlKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgYXJlIGluIGFuIGFwcHJvcHJpYXRlIHN0YXRlLlxuICBpZiAodGhpcy5fc3RhdGUgIT09IFN0YXRlLlNUQVJUICYmIHRoaXMuX3N0YXRlICE9PSBTdGF0ZS5NQVJLKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlU3RvcmU6IG1hcmtUaWxlIGNhbGxlZCBvdXQgb2Ygc2VxdWVuY2UnKTtcbiAgfVxuXG4gIC8vIEVudGVyIHRoZSBNQVJLIHN0YXRlLCBpZiBub3QgYWxyZWFkeSB0aGVyZS5cbiAgdGhpcy5fc3RhdGUgPSBTdGF0ZS5NQVJLO1xuXG4gIC8vIFJlZnJlc2ggdGV4dHVyZSBmb3IgZHluYW1pYyBhc3NldHMuXG4gIHZhciBpdGVtID0gdGhpcy5faXRlbU1hcC5nZXQodGlsZSk7XG4gIHZhciB0ZXh0dXJlID0gaXRlbSAmJiBpdGVtLnRleHR1cmUoKTtcbiAgdmFyIGFzc2V0ID0gaXRlbSAmJiBpdGVtLmFzc2V0KCk7XG4gIGlmICh0ZXh0dXJlICYmIGFzc2V0KSB7XG4gICAgdGV4dHVyZS5yZWZyZXNoKHRpbGUsIGFzc2V0KTtcbiAgfVxuXG4gIC8vIEFkZCB0aWxlIHRvIHRoZSB2aXNpYmxlIHNldC5cbiAgdGhpcy5fbmV3VmlzaWJsZS5hZGQodGlsZSk7XG59O1xuXG5cbi8qKlxuICogU2lnbmFsIHRoZSBlbmQgb2YgYSBmcmFtZS4gQ2FsbGVkIGZyb20ge0BsaW5rIFN0YWdlfS5cbiAqL1xuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5lbmRGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBDaGVjayB0aGF0IHdlIGFyZSBpbiBhbiBhcHByb3ByaWF0ZSBzdGF0ZS5cbiAgaWYgKHRoaXMuX3N0YXRlICE9PSBTdGF0ZS5TVEFSVCAmJiB0aGlzLl9zdGF0ZSAhPT0gU3RhdGUuTUFSSyAmJiB0aGlzLl9zdGF0ZSAhPT0gU3RhdGUuRU5EKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlU3RvcmU6IGVuZEZyYW1lIGNhbGxlZCBvdXQgb2Ygc2VxdWVuY2UnKTtcbiAgfVxuXG4gIC8vIEVudGVyIHRoZSBFTkQgc3RhdGUsIGlmIG5vdCBhbHJlYWR5IHRoZXJlLlxuICB0aGlzLl9zdGF0ZSA9IFN0YXRlLkVORDtcblxuICAvLyBFeHBlY3Qgb25lIGxlc3MgY2FsbCB0byBlbmRGcmFtZS5cbiAgdGhpcy5fZGVsaW1Db3VudC0tO1xuXG4gIC8vIElmIG5vIGZ1cnRoZXIgY2FsbHMgYXJlIGV4cGVjdGVkLCBwcm9jZXNzIGZyYW1lIGFuZCBlbnRlciB0aGUgSURMRSBzdGF0ZS5cbiAgaWYgKCF0aGlzLl9kZWxpbUNvdW50KSB7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgdGhpcy5fc3RhdGUgPSBTdGF0ZS5JRExFO1xuICB9XG59O1xuXG5cblRleHR1cmVTdG9yZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBzZXQgb2YgdGlsZXMgdGhhdCB1c2VkIHRvIGJlIHZpc2libGUgYnV0IG5vIGxvbmdlciBhcmUuXG4gIHNlbGYuX25vTG9uZ2VyVmlzaWJsZS5sZW5ndGggPSAwO1xuICBzZWxmLl92aXNpYmxlLmZvckVhY2goZnVuY3Rpb24odGlsZSkge1xuICAgIGlmICghc2VsZi5fbmV3VmlzaWJsZS5oYXModGlsZSkpIHtcbiAgICAgIHNlbGYuX25vTG9uZ2VyVmlzaWJsZS5wdXNoKHRpbGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBzZXQgb2YgdGlsZXMgdGhhdCB3ZXJlIHZpc2libGUgcmVjZW50bHkgYW5kIGhhdmUgYmVjb21lXG4gIC8vIHZpc2libGUgYWdhaW4uXG4gIHNlbGYuX3Zpc2libGVBZ2Fpbi5sZW5ndGggPSAwO1xuICBzZWxmLl9uZXdWaXNpYmxlLmZvckVhY2goZnVuY3Rpb24odGlsZSkge1xuICAgIGlmIChzZWxmLl9wcmV2aW91c2x5VmlzaWJsZS5oYXModGlsZSkpIHtcbiAgICAgIHNlbGYuX3Zpc2libGVBZ2Fpbi5wdXNoKHRpbGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gUmVtb3ZlIHRpbGVzIHRoYXQgaGF2ZSBiZWNvbWUgdmlzaWJsZSBhZ2FpbiBmcm9tIHRoZSBsaXN0IG9mIHByZXZpb3VzbHlcbiAgLy8gdmlzaWJsZSB0aWxlcy5cbiAgc2VsZi5fdmlzaWJsZUFnYWluLmZvckVhY2goZnVuY3Rpb24odGlsZSkge1xuICAgIHNlbGYuX3ByZXZpb3VzbHlWaXNpYmxlLnJlbW92ZSh0aWxlKTtcbiAgfSk7XG5cbiAgLy8gQ2FuY2VsIGxvYWRpbmcgb2YgdGlsZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHZpc2libGUuXG4gIC8vIE1vdmUgbm8gbG9uZ2VyIHZpc2libGUgdGlsZXMgd2l0aCBhIGxvYWRlZCB0ZXh0dXJlIGludG8gdGhlIHByZXZpb3VzbHlcbiAgLy8gdmlzaWJsZSBzZXQsIGFuZCBjb2xsZWN0IHRoZSB0aWxlcyBldmljdGVkIGZyb20gdGhlIGxhdHRlci5cbiAgc2VsZi5fZXZpY3RlZC5sZW5ndGggPSAwO1xuICBzZWxmLl9ub0xvbmdlclZpc2libGUuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgdmFyIGl0ZW0gPSBzZWxmLl9pdGVtTWFwLmdldCh0aWxlKTtcbiAgICB2YXIgdGV4dHVyZSA9IGl0ZW0gJiYgaXRlbS50ZXh0dXJlKCk7XG4gICAgaWYgKHRleHR1cmUpIHtcbiAgICAgIHZhciBvdGhlclRpbGUgPSBzZWxmLl9wcmV2aW91c2x5VmlzaWJsZS5hZGQodGlsZSk7XG4gICAgICBpZiAob3RoZXJUaWxlICE9IG51bGwpIHtcbiAgICAgICAgc2VsZi5fZXZpY3RlZC5wdXNoKG90aGVyVGlsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpdGVtKSB7XG4gICAgICBzZWxmLl91bmxvYWRUaWxlKHRpbGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVW5sb2FkIGV2aWN0ZWQgdGlsZXMsIHVubGVzcyB0aGV5IGFyZSBwaW5uZWQuXG4gIHNlbGYuX2V2aWN0ZWQuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgaWYgKCFzZWxmLl9waW5NYXAuaGFzKHRpbGUpKSB7XG4gICAgICBzZWxmLl91bmxvYWRUaWxlKHRpbGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gTG9hZCB2aXNpYmxlIHRpbGVzIHRoYXQgYXJlIG5vdCBhbHJlYWR5IGluIHRoZSBzdG9yZS5cbiAgLy8gUmVmcmVzaCB0ZXh0dXJlIG9uIHZpc2libGUgdGlsZXMgZm9yIGR5bmFtaWMgYXNzZXRzLlxuICBzZWxmLl9uZXdWaXNpYmxlLmZvckVhY2goZnVuY3Rpb24odGlsZSkge1xuICAgIHZhciBpdGVtID0gc2VsZi5faXRlbU1hcC5nZXQodGlsZSk7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICBzZWxmLl9sb2FkVGlsZSh0aWxlKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFN3YXAgdGhlIG9sZCB2aXNpYmxlIHNldCB3aXRoIHRoZSBuZXcgb25lLlxuICB2YXIgdG1wID0gc2VsZi5fdmlzaWJsZTtcbiAgc2VsZi5fdmlzaWJsZSA9IHNlbGYuX25ld1Zpc2libGU7XG4gIHNlbGYuX25ld1Zpc2libGUgPSB0bXA7XG5cbiAgLy8gQ2xlYXIgdGhlIG5ldyB2aXNpYmxlIHNldC5cbiAgc2VsZi5fbmV3VmlzaWJsZS5jbGVhcigpO1xuXG4gIC8vIENsZWFyIHRlbXBvcmFyeSB2YXJpYWJsZXMuXG4gIHNlbGYuX25vTG9uZ2VyVmlzaWJsZS5sZW5ndGggPSAwO1xuICBzZWxmLl92aXNpYmxlQWdhaW4ubGVuZ3RoID0gMDtcbiAgc2VsZi5fZXZpY3RlZC5sZW5ndGggPSAwO1xufTtcblxuXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLl9sb2FkVGlsZSA9IGZ1bmN0aW9uKHRpbGUpIHtcbiAgaWYgKHRoaXMuX2l0ZW1NYXAuaGFzKHRpbGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlU3RvcmU6IGxvYWRpbmcgdGV4dHVyZSBhbHJlYWR5IGluIGNhY2hlJyk7XG4gIH1cbiAgdmFyIGl0ZW0gPSBuZXcgVGV4dHVyZVN0b3JlSXRlbSh0aGlzLCB0aWxlKTtcbiAgdGhpcy5faXRlbU1hcC5zZXQodGlsZSwgaXRlbSk7XG59O1xuXG5cblRleHR1cmVTdG9yZS5wcm90b3R5cGUuX3VubG9hZFRpbGUgPSBmdW5jdGlvbih0aWxlKSB7XG4gIHZhciBpdGVtID0gdGhpcy5faXRlbU1hcC5kZWwodGlsZSk7XG4gIGlmICghaXRlbSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZVN0b3JlOiB1bmxvYWRpbmcgdGV4dHVyZSBub3QgaW4gY2FjaGUnKTtcbiAgfVxuICBpdGVtLmRlc3Ryb3koKTtcbn07XG5cblxuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5hc3NldCA9IGZ1bmN0aW9uKHRpbGUpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9pdGVtTWFwLmdldCh0aWxlKTtcbiAgaWYgKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS5hc3NldCgpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLnRleHR1cmUgPSBmdW5jdGlvbih0aWxlKSB7XG4gIHZhciBpdGVtID0gdGhpcy5faXRlbU1hcC5nZXQodGlsZSk7XG4gIGlmIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0udGV4dHVyZSgpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuXG4vKipcbiAqIFBpbiBhIHRpbGUuIFRleHR1cmVzIGZvciBwaW5uZWQgdGlsZXMgYXJlIG5ldmVyIGV2aWN0ZWQgZnJvbSB0aGUgc3RvcmUuXG4gKiBVcG9uIHBpbm5pbmcsIHRoZSB0ZXh0dXJlIGlzIGNyZWF0ZWQgaWYgbm90IGFscmVhZHkgcHJlc2VudC4gUGlucyBhcmVcbiAqIHJlZmVyZW5jZS1jb3VudGVkOyBhIHRpbGUgbWF5IGJlIHBpbm5lZCBtdWx0aXBsZSB0aW1lcyBhbmQgbXVzdCBiZSB1bnBpbm5lZFxuICogdGhlIGNvcnJlc3BvbmRpbmcgbnVtYmVyIG9mIHRpbWVzLiBQaW5uaW5nIGlzIHVzZWZ1bCBlLmcuIHRvIGVuc3VyZSB0aGF0XG4gKiB0aGUgbG93ZXN0LXJlc29sdXRpb24gbGV2ZWwgb2YgYW4gaW1hZ2UgaXMgYWx3YXlzIGF2YWlsYWJsZSB0byBmYWxsIGJhY2tcbiAqIG9udG8uXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgdGhlIHRpbGUgdG8gcGluXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgcGluIHJlZmVyZW5jZSBjb3VudC5cbiAqL1xuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5waW4gPSBmdW5jdGlvbih0aWxlKSB7XG4gIC8vIEluY3JlbWVudCByZWZlcmVuY2UgY291bnQuXG4gIHZhciBjb3VudCA9ICh0aGlzLl9waW5NYXAuZ2V0KHRpbGUpIHx8IDApICsgMTtcbiAgdGhpcy5fcGluTWFwLnNldCh0aWxlLCBjb3VudCk7XG4gIC8vIElmIHRoZSB0ZXh0dXJlIGZvciB0aGUgdGlsZSBpcyBub3QgcHJlc2VudCwgbG9hZCBpdCBub3cuXG4gIGlmICghdGhpcy5faXRlbU1hcC5oYXModGlsZSkpIHtcbiAgICB0aGlzLl9sb2FkVGlsZSh0aWxlKTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG5cbi8qKlxuICogVW5waW4gYSB0aWxlLiBQaW5zIGFyZSByZWZlcmVuY2UtY291bnRlZDsgYSB0aWxlIG1heSBiZSBwaW5uZWQgbXVsdGlwbGVcbiAqIHRpbWVzIGFuZCBtdXN0IGJlIHVucGlubmVkIHRoZSBjb3JyZXNwb25kaW5nIG51bWJlciBvZiB0aW1lcy5cbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSB0aGUgdGlsZSB0byB1bnBpblxuICogQHJldHVybnMge251bWJlcn0gdGhlIHBpbiByZWZlcmVuY2UgY291bnQuXG4gKi9cblRleHR1cmVTdG9yZS5wcm90b3R5cGUudW5waW4gPSBmdW5jdGlvbih0aWxlKSB7XG4gIHZhciBjb3VudCA9IHRoaXMuX3Bpbk1hcC5nZXQodGlsZSk7XG4gIC8vIENvbnNpc3RlbmN5IGNoZWNrLlxuICBpZiAoIWNvdW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlU3RvcmU6IHVucGluIHdoZW4gbm90IHBpbm5lZCcpO1xuICB9IGVsc2Uge1xuICAgIC8vIERlY3JlbWVudCByZWZlcmVuY2UgY291bnQuXG4gICAgY291bnQtLTtcbiAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICB0aGlzLl9waW5NYXAuc2V0KHRpbGUsIGNvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGluTWFwLmRlbCh0aWxlKTtcbiAgICAgIC8vIElmIHRoZSB0aWxlIGRvZXMgbm90IGJlbG9uZyB0byBlaXRoZXIgdGhlIHZpc2libGUgb3IgcHJldmlvdXNseVxuICAgICAgLy8gdmlzaWJsZSBzZXRzLCBldmljdCBpdCBmcm9tIHRoZSBjYWNoZS5cbiAgICAgIGlmICghdGhpcy5fdmlzaWJsZS5oYXModGlsZSkgJiYgIXRoaXMuX3ByZXZpb3VzbHlWaXNpYmxlLmhhcyh0aWxlKSkge1xuICAgICAgICB0aGlzLl91bmxvYWRUaWxlKHRpbGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIHR5cGUgZm9yIHtAbGluayBUZXh0dXJlU3RvcmUjcXVlcnl9LlxuICogQHR5cGVkZWYge09iamVjdH0gVGlsZVN0YXRlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHZpc2libGUgV2hldGhlciB0aGUgdGlsZSBpcyBpbiB0aGUgdmlzaWJsZSBzZXQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHByZXZpb3VzbHlWaXNpYmxlIFdoZXRoZXIgdGhlIHRpbGUgaXMgaW4gdGhlIHByZXZpb3VzbHlcbiAqICAgICB2aXNpYmxlIHNldC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGFzQXNzZXQgV2hldGhlciB0aGUgYXNzZXQgZm9yIHRoZSB0aWxlIGlzIHByZXNlbnQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhhc1RleHR1cmUgV2hldGhlciB0aGUgdGV4dHVyZSBmb3IgdGhlIHRpbGUgaXMgcHJlc2VudC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGlubmVkIFdoZXRoZXIgdGhlIHRpbGUgaXMgaW4gdGhlIHBpbm5lZCBzZXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGluQ291bnQgVGhlIHBpbiByZWZlcmVuY2UgY291bnQgZm9yIHRoZSB0aWxlLlxuICovXG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHN0YXRlIG9mIGEgdGlsZS5cbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgdGlsZSB0byBxdWVyeS5cbiAqIEByZXR1cm4ge1RpbGVTdGF0ZX1cbiAqL1xuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHRpbGUpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9pdGVtTWFwLmdldCh0aWxlKTtcbiAgdmFyIHBpbkNvdW50ID0gdGhpcy5fcGluTWFwLmdldCh0aWxlKSB8fCAwO1xuICByZXR1cm4ge1xuICAgIHZpc2libGU6IHRoaXMuX3Zpc2libGUuaGFzKHRpbGUpLFxuICAgIHByZXZpb3VzbHlWaXNpYmxlOiB0aGlzLl9wcmV2aW91c2x5VmlzaWJsZS5oYXModGlsZSksXG4gICAgaGFzQXNzZXQ6IGl0ZW0gIT0gbnVsbCAmJiBpdGVtLmFzc2V0KCkgIT0gbnVsbCxcbiAgICBoYXNUZXh0dXJlOiBpdGVtICE9IG51bGwgJiYgaXRlbS50ZXh0dXJlKCkgIT0gbnVsbCxcbiAgICBwaW5uZWQ6IHBpbkNvdW50ICE9PSAwLFxuICAgIHBpbkNvdW50OiBwaW5Db3VudFxuICB9O1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmVTdG9yZTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFNldCA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbnMvU2V0Jyk7XG5cbi8qKlxuICogQGNsYXNzIFRpbGVTZWFyY2hlclxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgVGlsZVNlYXJjaGVyIHBlcmZvcm1zIHNlYXJjaGVzIGZvciB2aXNpYmxlIHRpbGVzLlxuICovXG5mdW5jdGlvbiBUaWxlU2VhcmNoZXIoKSB7XG4gIC8vIFN0YWNrIG9mIHRpbGVzIHRvIGJlIGV4cGxvcmVkLlxuICB0aGlzLl9zdGFjayA9IFtdO1xuXG4gIC8vIFNldCBvZiBhbHJlYWR5IGV4cGxvcmVkIHRpbGVzLlxuICB0aGlzLl92aXNpdGVkID0gbmV3IFNldCgpO1xuXG4gIC8vIFRpbGUgdmVydGljZXMuIEFsbG9jYXRlZCBieSBUaWxlI3ZlcnRpY2VzIG9uIGZpcnN0IHVzZS5cbiAgdGhpcy5fdmVydGljZXMgPSBudWxsO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgc2VhcmNoIGZvciB2aXNpYmxlIHRpbGVzIGJ5IHN0YXJ0aW5nIGF0IGEgZ2l2ZW4gdGlsZSBhbmRcbiAqIHJlY3Vyc2l2ZWx5IGV4cGxvcmluZyBuZWlnaGJvcnMgdW50aWwgbm8gbW9yZSB2aXNpYmxlIHRpbGVzIGFyZSBmb3VuZC5cbiAqXG4gKiBAcGFyYW0ge1ZpZXd9IHZpZXcgVGhlIHZpZXcgdXNlZCB0byBkZWVtIHdoZXRoZXIgYSB0aWxlIGlzIHZpc2libGUuXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgVGhlIHN0YXJ0aW5nIHRpbGUuXG4gKiBAcGFyYW0ge1RpbGVbXX0gcmVzdWx0IEFuIGFycmF5IHRvIGFwcGVuZCB0aGUgdmlzaWJsZSB0aWxlcyB0bywgaW5jbHVkaW5nIHRoZVxuICogICAgIHN0YXJ0aW5nIHRpbGUgd2hlbiB2aXNpYmxlLiBFeGlzdGluZyBhcnJheSBtZW1iZXJzIGFyZSBwcmVzZXJ2ZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgdmlzaWJsZSB0aWxlcyBmb3VuZC5cbiAqL1xuVGlsZVNlYXJjaGVyLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbih2aWV3LCBzdGFydGluZ1RpbGUsIHJlc3VsdCkge1xuICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFjaztcbiAgdmFyIHZpc2l0ZWQgPSB0aGlzLl92aXNpdGVkO1xuICB2YXIgdmVydGljZXMgPSB0aGlzLl92ZXJ0aWNlcztcblxuICB2YXIgY291bnQgPSAwO1xuXG4gIC8vIENsZWFyIGludGVybmFsIHN0YXRlLlxuICB0aGlzLl9jbGVhcigpO1xuXG4gIHN0YWNrLnB1c2goc3RhcnRpbmdUaWxlKTtcblxuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciB0aWxlID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAodmlzaXRlZC5oYXModGlsZSkpIHtcbiAgICAgIC8vIFNraXAgYWxyZWFkeSB2aXNpdGVkIHRpbGUuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoIXZpZXcuaW50ZXJzZWN0cyh0aWxlLnZlcnRpY2VzKHZlcnRpY2VzKSkpIHtcbiAgICAgIC8vIFNraXAgbm9uLXZpc2libGUgdGlsZS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIE1hcmsgdGlsZSBhcyB2aXNpdGVkLlxuICAgIHZpc2l0ZWQuYWRkKHRpbGUpO1xuXG4gICAgLy8gQWRkIG5laWdoYm9ycyB0byB0aGUgc3RhY2sgb2YgdGlsZXMgdG8gZXhwbG9yZS5cbiAgICB2YXIgbmVpZ2hib3JzID0gdGlsZS5uZWlnaGJvcnMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgc3RhY2sucHVzaChuZWlnaGJvcnNbaV0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB0byByZXN1bHQuXG4gICAgcmVzdWx0LnB1c2godGlsZSk7XG5cbiAgICBjb3VudCsrO1xuICB9XG5cbiAgLy8gUmV1c2UgdGhlIHZlcnRpY2VzIGFycmF5IGluIGZ1dHVyZSBzZWFyY2hlcy5cbiAgdGhpcy5fdmVydGljZXMgPSB2ZXJ0aWNlcztcblxuICAvLyBDbGVhciBpbnRlcm5hbCBzdGF0ZS5cbiAgdGhpcy5fY2xlYXIoKTtcblxuICByZXR1cm4gY291bnQ7XG59O1xuXG5UaWxlU2VhcmNoZXIucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zdGFjay5sZW5ndGggPSAwO1xuICB0aGlzLl92aXNpdGVkLmNsZWFyKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVTZWFyY2hlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi91dGlsL2RlZmF1bHRzJyk7XG52YXIgbm93ID0gcmVxdWlyZSgnLi91dGlsL25vdycpO1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGR1cmF0aW9uOiBJbmZpbml0eVxufTtcblxuXG4vKipcbiAqIFNpZ25hbHMgYSB0aW1lb3V0LlxuICogQGV2ZW50IFRpbWVyI3RpbWVvdXRcbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzIFRpbWVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSBUaW1lciBwcm92aWRlcyBhIG1lY2hhbmlzbSB0byByZWNlaXZlIGFuIGV2ZW50IGFmdGVyIGEgdGltZW91dC5cbiAqXG4gKiBBIHRpbWVyIGhhcyBhIHNldCBkdXJhdGlvbiwgYW5kIGlzIGVpdGhlciBzdGFydGVkIG9yIHN0b3BwZWQgYXQgYSBnaXZlbiB0aW1lLlxuICogVGhlIHRpbWVyIGlzIGluaXRpYWxseSBzdG9wcGVkLiBXaGVuIHRoZSB0aW1lciBpcyBzdGFydGVkLCBhIHRpbWVvdXQgZXZlbnQgaXNcbiAqIHNjaGVkdWxlZCB0byBmaXJlIG9uY2UgdGhlIHNldCBkdXJhdGlvbiBlbGFwc2VzLiBXaGVuIHRoZSB0aW1lciBpcyBzdG9wcGVkLFxuICogdGhlIHNjaGVkdWxlZCB0aW1lb3V0IGV2ZW50IGlzIGNhbmNlbGxlZC4gV2hlbiBhIHRpbWVvdXQgZXZlbnQgZmlyZXMsIHRoZVxuICogdGltZXIgcmV0dXJucyB0byB0aGUgc3RvcHBlZCBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZHVyYXRpb249SW5maW5pdHldIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5mdW5jdGlvbiBUaW1lcihvcHRzKSB7XG5cbiAgb3B0cyA9IGRlZmF1bHRzKG9wdHMgfHwge30sIGRlZmF1bHRPcHRpb25zKTtcblxuICB0aGlzLl9kdXJhdGlvbiA9IG9wdHMuZHVyYXRpb247XG5cbiAgdGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuICB0aGlzLl9oYW5kbGUgPSBudWxsO1xuXG4gIHRoaXMuX2NoZWNrID0gdGhpcy5fY2hlY2suYmluZCh0aGlzKTtcblxufVxuXG5ldmVudEVtaXR0ZXIoVGltZXIpO1xuXG5cbi8qKlxuICogU3RhcnRzIHRoZSB0aW1lci4gSWYgdGhlIHRpbWVyIGlzIGFscmVhZHkgc3RhcnRlZCwgdGhpcyBoYXMgdGhlIGVmZmVjdCBvZlxuICogc3RvcHBpbmcgYW5kIHN0YXJ0aW5nIGFnYWluIChpLmUuIHJlc2V0dGluZyB0aGUgdGltZXIpLlxuICovXG5UaW1lci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc3RhcnRUaW1lID0gbm93KCk7XG4gIGlmICh0aGlzLl9oYW5kbGUgPT0gbnVsbCAmJiB0aGlzLl9kdXJhdGlvbiA8IEluZmluaXR5KSB7XG4gICAgdGhpcy5fc2V0dXAodGhpcy5fZHVyYXRpb24pO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSB0aW1lciBpcyBpbiB0aGUgc3RhcnRlZCBzdGF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblRpbWVyLnByb3RvdHlwZS5zdGFydGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zdGFydFRpbWUgIT0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBTdG9wcyB0aGUgdGltZXIuXG4gKi9cblRpbWVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG4gIGlmICh0aGlzLl9oYW5kbGUgIT0gbnVsbCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9oYW5kbGUpO1xuICAgIHRoaXMuX2hhbmRsZSA9IG51bGw7XG4gIH1cbn07XG5cblxuVGltZXIucHJvdG90eXBlLl9zZXR1cCA9IGZ1bmN0aW9uKGludGVydmFsKSB7XG4gIHRoaXMuX2hhbmRsZSA9IHNldFRpbWVvdXQodGhpcy5fY2hlY2ssIGludGVydmFsKTtcbn07XG5cblxuVGltZXIucHJvdG90eXBlLl90ZWFyZG93biA9IGZ1bmN0aW9uKCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5faGFuZGxlKTtcbiAgdGhpcy5faGFuZGxlID0gbnVsbDtcbn07XG5cblxuVGltZXIucHJvdG90eXBlLl9jaGVjayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3VycmVudFRpbWUgPSBub3coKTtcbiAgdmFyIGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuX3N0YXJ0VGltZTtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMuX2R1cmF0aW9uIC0gZWxhcHNlZDtcblxuICB0aGlzLl90ZWFyZG93bigpO1xuXG4gIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgIHRoaXMuZW1pdCgndGltZW91dCcpO1xuICAgIHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG4gIH0gZWxzZSBpZiAocmVtYWluaW5nIDwgSW5maW5pdHkpIHtcbiAgICB0aGlzLl9zZXR1cChyZW1haW5pbmcpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5IHNldCBkdXJhdGlvbi5cbiAqL1xuVGltZXIucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSBkdXJhdGlvbi4gSWYgdGhlIHRpbWVyIGlzIGFscmVhZHkgc3RhcnRlZCwgdGhlIHRpbWVvdXQgZXZlbnQgaXNcbiAqIHJlc2NoZWR1bGVkIHRvIG9jY3VyIG9uY2UgdGhlIG5ldyBkdXJhdGlvbiBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBjYWxsXG4gKiB0byBzdGFydC4gSW4gcGFydGljdWxhciwgaWYgYW4gYW1vdW50IG9mIHRpbWUgbGFyZ2VyIHRoYW4gdGhlIG5ldyBkdXJhdGlvblxuICogaGFzIGFscmVhZHkgZWxhcHNlZCwgdGhlIHRpbWVvdXQgZXZlbnQgZmlyZXMgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqL1xuVGltZXIucHJvdG90eXBlLnNldER1cmF0aW9uID0gZnVuY3Rpb24oZHVyYXRpb24pIHtcbiAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgaWYgKHRoaXMuX3N0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgdGhpcy5fY2hlY2soKTtcbiAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJ2Jvd3NlcicpO1xudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xuXG52YXIgUmVuZGVyTG9vcCA9IHJlcXVpcmUoJy4vUmVuZGVyTG9vcCcpO1xudmFyIENvbnRyb2xzID0gcmVxdWlyZSgnLi9jb250cm9scy9Db250cm9scycpO1xudmFyIFNjZW5lID0gcmVxdWlyZSgnLi9TY2VuZScpO1xudmFyIFRpbWVyID0gcmVxdWlyZSgnLi9UaW1lcicpO1xuXG52YXIgV2ViR2xTdGFnZSA9IHJlcXVpcmUoJy4vc3RhZ2VzL1dlYkdsJyk7XG5cbnZhciBDb250cm9sQ3Vyc29yID0gcmVxdWlyZSgnLi9jb250cm9scy9Db250cm9sQ3Vyc29yJyk7XG52YXIgSGFtbWVyR2VzdHVyZXMgPSByZXF1aXJlKCcuL2NvbnRyb2xzL0hhbW1lckdlc3R1cmVzJyk7XG5cbnZhciByZWdpc3RlckRlZmF1bHRDb250cm9scyA9IHJlcXVpcmUoJy4vY29udHJvbHMvcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHMnKTtcbnZhciByZWdpc3RlckRlZmF1bHRSZW5kZXJlcnMgPSByZXF1aXJlKCcuL3JlbmRlcmVycy9yZWdpc3RlckRlZmF1bHRSZW5kZXJlcnMnKTtcblxudmFyIHNldE92ZXJmbG93SGlkZGVuID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldE92ZXJmbG93SGlkZGVuO1xudmFyIHNldEFic29sdXRlID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldEFic29sdXRlO1xudmFyIHNldEZ1bGxTaXplID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldEZ1bGxTaXplO1xudmFyIHNldEJsb2NraW5nID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldEJsb2NraW5nO1xuXG52YXIgdHdlZW4gPSByZXF1aXJlKCcuL3V0aWwvdHdlZW4nKTtcbnZhciBub29wID0gcmVxdWlyZSgnLi91dGlsL25vb3AnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogU2lnbmFscyB0aGF0IHRoZSBjdXJyZW50IHNjZW5lIGhhcyBjaGFuZ2VkLlxuICogQGV2ZW50IFZpZXdlciNzY2VuZUNoYW5nZVxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IHRoZSB2aWV3IG9mIHRoZSBjdXJyZW50IHNjZW5lIGhhcyBjaGFuZ2VkLiBTZWVcbiAqIHtAbGluayBWaWV3I2V2ZW50OmNoYW5nZX0uXG4gKiBAZXZlbnQgVmlld2VyI3ZpZXdDaGFuZ2VcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBWaWV3ZXJcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIFZpZXdlciBpcyBhIGNvbnRhaW5lciBmb3IgbXVsdGlwbGUge0BsaW5rIFNjZW5lIHNjZW5lc30gdG8gYmUgZGlzcGxheWVkXG4gKiBpbnNpZGUgYSB7QGxpbmsgU3RhZ2Ugc3RhZ2V9IGNvbnRhaW5lZCBpbiB0aGUgRE9NLlxuICpcbiAqIFNjZW5lcyBtYXkgYmUgY3JlYXRlZCBieSBjYWxsaW5nIHtAbGluayBWaWV3ZXIjY3JlYXRlU2NlbmV9LiBFeGNlcHQgZHVyaW5nIGFcbiAqIHNjZW5lIHN3aXRjaCwgYSBzaW5nbGUgb25lIG9mIHRoZW0sIGNhbGxlZCB0aGUgY3VycmVudCBzY2VuZSwgaXMgdmlzaWJsZS5cbiAqIENhbGxpbmcge0BsaW5rIFZpZXdlciNzd2l0Y2hTY2VuZX0gc2V0cyB0aGUgY3VycmVudCBzY2VuZSBhbmQgc3dpdGNoZXMgdG8gaXQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBkb21FbGVtZW50IFRoZSBET00gZWxlbWVudCB0byBjb250YWluIHRoZSBzdGFnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFZpZXdlciBjcmVhdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuY29udHJvbHMgT3B0aW9ucyB0byBiZSBwYXNzZWQgdG9cbiAqICAgICB7QGxpbmsgcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHN9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuc3RhZ2UgT3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIHtAbGluayBTdGFnZX1cbiAqICAgICBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmN1cnNvcnMgQ3Vyc29yIG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5jdXJzb3JzLmRyYWcgRHJhZyBjdXJzb3Igb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlXG4gKiAgICAge0BsaW5rIENvbnRyb2xDdXJzb3J9IGNvbnN0cnVjdG9yLlxuICovXG5mdW5jdGlvbiBWaWV3ZXIoZG9tRWxlbWVudCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB0aGlzLl9kb21FbGVtZW50ID0gZG9tRWxlbWVudDtcblxuICAvLyBBZGQgYG92ZXJmbG93OiBoaWRkZW5gIHRvIHRoZSBkb21FbGVtZW50LlxuICBzZXRPdmVyZmxvd0hpZGRlbihkb21FbGVtZW50KTtcblxuICAvLyBDcmVhdGUgc3RhZ2UuXG4gIHRoaXMuX3N0YWdlID0gbmV3IFdlYkdsU3RhZ2Uob3B0cy5zdGFnZSk7XG5cbiAgLy8gUmVnaXN0ZXIgdGhlIGRlZmF1bHQgcmVuZGVyZXJzIGZvciB0aGUgc2VsZWN0ZWQgc3RhZ2UuXG4gIHJlZ2lzdGVyRGVmYXVsdFJlbmRlcmVycyh0aGlzLl9zdGFnZSk7XG5cbiAgLy8gQWRkIHRoZSBzdGFnZSBlbGVtZW50IGludG8gdGhlIERPTS5cbiAgdGhpcy5fZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9zdGFnZS5kb21FbGVtZW50KCkpO1xuXG4gIC8vIENyZWF0ZSBjb250cm9sIGNvbnRhaW5lci5cbiAgLy8gQ29udHJvbHMgY2Fubm90IGJlIHBsYWNlZCBkaXJlY3RseSBvbiB0aGUgcm9vdCBET00gZWxlbWVudCBiZWNhdXNlXG4gIC8vIEhhbW1lci5qcyB3aWxsIHByZXZlbnQgY2xpY2sgZXZlbnRzIGZyb20gcmVhY2hpbmcgdGhlIGVsZW1lbnRzIGJlbmVhdGguXG5cbiAgLy8gVGhlIGhvdHNwb3QgY29udGFpbmVycyB3aWxsIGJlIGFkZGVkIGluc2lkZSB0aGUgY29udHJvbHMgY29udGFpbmVyLlxuICB0aGlzLl9jb250cm9sQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHNldEFic29sdXRlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xuICBzZXRGdWxsU2l6ZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcblxuICAvLyBQcmV2ZW50IGJvdW5jZSBzY3JvbGwgZWZmZWN0IG9uIGlPUy5cbiAgLy8gQXBwbGllZCBvbmx5IGZvciBpT1MsIGFzIEFuZHJvaWQncyBldmVudHMgbXVzdCBoYXZlIHRoZSBkZWZhdWx0IGFjdGlvbiB0byBhbGxvdyBpbnRlcmFjdGlvbiB3aXRoIGhvdHNwb3RzLlxuICBpZiAoYnJvd3Nlci5pb3MpIHtcbiAgICB0aGlzLl9jb250cm9sQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuICB9XG5cblxuICAvLyBPbGQgSUUgZG9lcyBub3QgZGV0ZWN0IG1vdXNlIGV2ZW50cyBvbiBlbGVtZW50cyB3aXRob3V0IGJhY2tncm91bmRcbiAgLy8gQWRkIGEgY2hpbGQgZWxlbWVudCB0byB0aGUgY29udHJvbHMgd2l0aCBmdWxsIHdpZHRoLCBhIGJhY2tncm91bmQgY29sb3JcbiAgLy8gYW5kIG9wYWNpdHkgMFxuICB2YXIgY29udHJvbENhcHR1cmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgc2V0QWJzb2x1dGUoY29udHJvbENhcHR1cmUpO1xuICBzZXRGdWxsU2l6ZShjb250cm9sQ2FwdHVyZSk7XG4gIHNldEJsb2NraW5nKGNvbnRyb2xDYXB0dXJlKTtcblxuICB0aGlzLl9jb250cm9sQ29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRyb2xDYXB0dXJlKTtcbiAgZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcblxuICAvLyBSZXNwb25kIHRvIHdpbmRvdyBzaXplIGNoYW5nZXMuXG4gIHRoaXMuX3NpemUgPSB7fTtcbiAgdGhpcy51cGRhdGVTaXplKCk7XG4gIHRoaXMuX3VwZGF0ZVNpemVMaXN0ZW5lciA9IHRoaXMudXBkYXRlU2l6ZS5iaW5kKHRoaXMpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fdXBkYXRlU2l6ZUxpc3RlbmVyKTtcblxuICAvLyBDcmVhdGUgcmVuZGVyIGxvb3AuXG4gIHRoaXMuX3JlbmRlckxvb3AgPSBuZXcgUmVuZGVyTG9vcCh0aGlzLl9zdGFnZSk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBjb250cm9scyBhbmQgcmVnaXN0ZXIgdGhlbSB3aXRoIHRoZSByZW5kZXIgbG9vcC5cbiAgdGhpcy5fY29udHJvbHMgPSBuZXcgQ29udHJvbHMoKTtcbiAgdGhpcy5fY29udHJvbE1ldGhvZHMgPSByZWdpc3RlckRlZmF1bHRDb250cm9scyh0aGlzLl9jb250cm9scywgdGhpcy5fY29udHJvbENvbnRhaW5lciwgb3B0cy5jb250cm9scyk7XG4gIHRoaXMuX2NvbnRyb2xzLmF0dGFjaCh0aGlzLl9yZW5kZXJMb29wKTtcblxuICAvLyBFeHBvc2UgSGFtbWVySlMuXG4gIHRoaXMuX2hhbW1lck1hbmFnZXJUb3VjaCA9IEhhbW1lckdlc3R1cmVzLmdldCh0aGlzLl9jb250cm9sQ29udGFpbmVyLCAndG91Y2gnKTtcbiAgdGhpcy5faGFtbWVyTWFuYWdlck1vdXNlID0gSGFtbWVyR2VzdHVyZXMuZ2V0KHRoaXMuX2NvbnRyb2xDb250YWluZXIsICdtb3VzZScpO1xuXG4gIC8vIEluaXRpYWxpemUgZHJhZyBjdXJzb3IuXG4gIHRoaXMuX2RyYWdDdXJzb3IgPSBuZXcgQ29udHJvbEN1cnNvcih0aGlzLl9jb250cm9scywgJ21vdXNlVmlld0RyYWcnLCBkb21FbGVtZW50LCBvcHRzLmN1cnNvcnMgJiYgb3B0cy5jdXJzb3JzLmRyYWcgfHwge30pO1xuXG4gIC8vIFN0YXJ0IHRoZSByZW5kZXIgbG9vcC5cbiAgdGhpcy5fcmVuZGVyTG9vcC5zdGFydCgpO1xuXG4gIC8vIFNjZW5lIGxpc3QuXG4gIHRoaXMuX3NjZW5lcyA9IFtdO1xuXG4gIC8vIFRoZSBjdXJyZW50bHkgdmlzaWJsZSBzY2VuZS5cbiAgLy8gRHVyaW5nIGEgc2NlbmUgdHJhbnNpdGlvbiwgdGhpcyBpcyB0aGUgc2NlbmUgYmVpbmcgc3dpdGNoZWQgdG8uXG4gIHRoaXMuX2N1cnJlbnRTY2VuZSA9IG51bGw7XG5cbiAgLy8gVGhlIHNjZW5lIGJlaW5nIHN3aXRjaGVkIGZyb20gZHVyaW5nIGEgc2NlbmUgdHJhbnNpdGlvbi5cbiAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gdXBkYXRlIHRoZSBsYXllcnMgY29ycmVjdGx5IHdoZW4gdGhleSBhcmUgYWRkZWQgb3JcbiAgLy8gcmVtb3ZlZCBkdXJpbmcgYSB0cmFuc2l0aW9uLlxuICB0aGlzLl9yZXBsYWNlZFNjZW5lID0gbnVsbDtcblxuICAvLyBUaGUgY3VycmVudCB0cmFuc2l0aW9uLlxuICB0aGlzLl9jYW5jZWxDdXJyZW50VHdlZW4gPSBudWxsO1xuXG4gIC8vIFRoZSBldmVudCBsaXN0ZW5lciBmaXJlZCB3aGVuIHRoZSBjdXJyZW50IHNjZW5lIGxheWVycyBjaGFuZ2UuXG4gIC8vIFRoaXMgaXMgYXR0YWNoZWQgdG8gdGhlIGNvcnJlY3Qgc2NlbmUgd2hlbmV2ZXIgdGhlIGN1cnJlbnQgc2NlbmUgY2hhbmdlcy5cbiAgdGhpcy5fbGF5ZXJDaGFuZ2VIYW5kbGVyID0gdGhpcy5fdXBkYXRlU2NlbmVMYXllcnMuYmluZCh0aGlzKTtcblxuICAvLyBUaGUgZXZlbnQgbGlzdGVuZXIgZmlyZWQgd2hlbiB0aGUgY3VycmVudCBzY2VuZSB2aWV3IGNoYW5nZXMuXG4gIC8vIFRoaXMgaXMgYXR0YWNoZWQgdG8gdGhlIGNvcnJlY3Qgc2NlbmUgd2hlbmV2ZXIgdGhlIGN1cnJlbnQgc2NlbmUgY2hhbmdlcy5cbiAgdGhpcy5fdmlld0NoYW5nZUhhbmRsZXIgPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAndmlld0NoYW5nZScpO1xuXG4gIC8vIFNldHVwIHRoZSBpZGxlIHRpbWVyLlxuICAvLyBCeSBkZWZhdWx0LCB0aGUgdGltZXIgaGFzIGFuIGluZmluaXRlIGR1cmF0aW9uIHNvIGl0IGRvZXMgbm90aGluZy5cbiAgdGhpcy5faWRsZVRpbWVyID0gbmV3IFRpbWVyKCk7XG4gIHRoaXMuX2lkbGVUaW1lci5zdGFydCgpO1xuXG4gIC8vIFJlc2V0IHRoZSB0aW1lciB3aGVuZXZlciB0aGUgdmlldyBjaGFuZ2VzLlxuICB0aGlzLl9yZXNldElkbGVUaW1lckhhbmRsZXIgPSB0aGlzLl9yZXNldElkbGVUaW1lci5iaW5kKHRoaXMpO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZpZXdDaGFuZ2UnLCB0aGlzLl9yZXNldElkbGVUaW1lckhhbmRsZXIpO1xuXG4gIC8vIFN0YXJ0IHRoZSBpZGxlIG1vdmVtZW50IHdoZW4gdGhlIGlkbGUgdGltZXIgZmlyZXMuXG4gIHRoaXMuX3RyaWdnZXJJZGxlVGltZXJIYW5kbGVyID0gdGhpcy5fdHJpZ2dlcklkbGVUaW1lci5iaW5kKHRoaXMpO1xuICB0aGlzLl9pZGxlVGltZXIuYWRkRXZlbnRMaXN0ZW5lcigndGltZW91dCcsIHRoaXMuX3RyaWdnZXJJZGxlVGltZXJIYW5kbGVyKTtcblxuICAvLyBTdG9wIGFuIG9uZ29pbmcgbW92ZW1lbnQgd2hlbiB0aGUgY29udHJvbHMgYXJlIGFjdGl2YXRlZCBvciB3aGVuIHRoZVxuICAvLyBzY2VuZSBjaGFuZ2VzLlxuICB0aGlzLl9zdG9wTW92ZW1lbnRIYW5kbGVyID0gdGhpcy5zdG9wTW92ZW1lbnQuYmluZCh0aGlzKTtcbiAgdGhpcy5fY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignYWN0aXZlJywgdGhpcy5fc3RvcE1vdmVtZW50SGFuZGxlcik7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignc2NlbmVDaGFuZ2UnLCB0aGlzLl9zdG9wTW92ZW1lbnRIYW5kbGVyKTtcblxuICAvLyBUaGUgY3VycmVudGx5IHByb2dyYW1tZWQgaWRsZSBtb3ZlbWVudC5cbiAgdGhpcy5faWRsZU1vdmVtZW50ID0gbnVsbDtcbn1cblxuZXZlbnRFbWl0dGVyKFZpZXdlcik7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5WaWV3ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblxuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fdXBkYXRlU2l6ZUxpc3RlbmVyKTtcblxuICBpZiAodGhpcy5fY3VycmVudFNjZW5lKSB7XG4gICAgdGhpcy5fcmVtb3ZlU2NlbmVFdmVudExpc3RlbmVycyh0aGlzLl9jdXJyZW50U2NlbmUpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3JlcGxhY2VkU2NlbmUpIHtcbiAgICB0aGlzLl9yZW1vdmVTY2VuZUV2ZW50TGlzdGVuZXJzKHRoaXMuX3JlcGxhY2VkU2NlbmUpO1xuICB9XG5cbiAgdGhpcy5fZHJhZ0N1cnNvci5kZXN0cm95KCk7XG5cbiAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiB0aGlzLl9jb250cm9sTWV0aG9kcykge1xuICAgIHRoaXMuX2NvbnRyb2xNZXRob2RzW21ldGhvZE5hbWVdLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHdoaWxlICh0aGlzLl9zY2VuZXMubGVuZ3RoKSB7XG4gICAgdGhpcy5kZXN0cm95U2NlbmUodGhpcy5fc2NlbmVzWzBdKTtcbiAgfVxuXG4gIHRoaXMuX2RvbUVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5fc3RhZ2UuZG9tRWxlbWVudCgpKTtcblxuICB0aGlzLl9zdGFnZS5kZXN0cm95KCk7XG4gIHRoaXMuX3JlbmRlckxvb3AuZGVzdHJveSgpO1xuICB0aGlzLl9jb250cm9scy5kZXN0cm95KCk7XG4gIHRoaXMuX2NvbnRyb2xzID0gbnVsbDtcblxuICBpZiAodGhpcy5fY2FuY2VsQ3VycmVudFR3ZWVuKSB7XG4gICAgdGhpcy5fY2FuY2VsQ3VycmVudFR3ZWVuKCk7XG4gIH1cblxuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgc3RhZ2Ugc2l6ZSB0byBmaWxsIHRoZSBjb250YWluaW5nIGVsZW1lbnQuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cgaXMgcmVzaXplZC5cbiAqIE1vc3QgY2xpZW50cyB3b24ndCBuZWVkIHRvIGV4cGxpY2l0bHkgY2FsbCBpdCB0byBrZWVwIHRoZSBzaXplIHVwIHRvIGRhdGUuXG4gKi9cblZpZXdlci5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gIHNpemUud2lkdGggPSB0aGlzLl9kb21FbGVtZW50LmNsaWVudFdpZHRoO1xuICBzaXplLmhlaWdodCA9IHRoaXMuX2RvbUVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICB0aGlzLl9zdGFnZS5zZXRTaXplKHNpemUpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcge0BsaW5rIFN0YWdlIHN0YWdlfS5cbiAqIEByZXR1cm4ge1N0YWdlfVxuICovXG5WaWV3ZXIucHJvdG90eXBlLnN0YWdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zdGFnZTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHtAbGluayBSZW5kZXJMb29wIHJlbmRlciBsb29wfS5cbiAqIEByZXR1cm4ge1JlbmRlckxvb3B9XG4gKi9cblZpZXdlci5wcm90b3R5cGUucmVuZGVyTG9vcCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcmVuZGVyTG9vcDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHtAbGluayBDb250cm9scyBjb250cm9sc30uXG4gKiBAcmV0dXJuIHtDb250cm9sc31cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5jb250cm9scyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY29udHJvbHM7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBET00gZWxlbWVudC5cbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cblZpZXdlci5wcm90b3R5cGUuZG9tRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZG9tRWxlbWVudDtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHtAbGluayBTY2VuZSBzY2VuZX0gd2l0aCBhIHNpbmdsZSBsYXllciBhbmQgYWRkcyBpdCB0byB0aGVcbiAqIHZpZXdlci5cbiAqXG4gKiBUaGUgY3VycmVudCBzY2VuZSBkb2VzIG5vdCBjaGFuZ2UuIFRvIHN3aXRjaCB0byB0aGUgc2NlbmUsIGNhbGxcbiAqIHtAbGluayBWaWV3ZXIjc3dpdGNoU2NlbmV9LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFNjZW5lIGNyZWF0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0ge1ZpZXd9IG9wdHMudmlldyBUaGUgc2NlbmUncyB1bmRlcmx5aW5nIHtAbGluayBWaWV3fS5cbiAqIEBwYXJhbSB7U291cmNlfSBvcHRzLnNvdXJjZSBUaGUgbGF5ZXIncyB1bmRlcmx5aW5nIHtAbGluayBTb3VyY2V9LlxuICogQHBhcmFtIHtHZW9tZXRyeX0gb3B0cy5nZW9tZXRyeSBUaGUgbGF5ZXIncyB1bmRlcmx5aW5nIHtAbGluayBHZW9tZXRyeX0uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnBpbkZpcnN0TGV2ZWw9ZmFsc2VdIFdoZXRoZXIgdG8gcGluIHRoZSBmaXJzdCBsZXZlbCB0b1xuICogICAgIHByb3ZpZGUgYSBmYWxsYmFjayBvZiBsYXN0IHJlc29ydCwgYXQgdGhlIGNvc3Qgb2YgbWVtb3J5IGNvbnN1bXB0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnRleHR1cmVTdG9yZU9wdHM9e31dIE9wdGlvbnMgdG8gcGFzcyB0byB0aGVcbiAqICAgICB7QGxpbmsgVGV4dHVyZVN0b3JlfSBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5sYXllck9wdHM9e31dIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUge0BsaW5rIExheWVyfVxuICogICAgIGNvbnN0cnVjdG9yLlxuICogQHJldHVybiB7U2NlbmV9XG4gKi9cblZpZXdlci5wcm90b3R5cGUuY3JlYXRlU2NlbmUgPSBmdW5jdGlvbihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBzY2VuZSA9IHRoaXMuY3JlYXRlRW1wdHlTY2VuZSh7IHZpZXc6IG9wdHMudmlldyB9KTtcblxuICBzY2VuZS5jcmVhdGVMYXllcih7XG4gICAgc291cmNlOiBvcHRzLnNvdXJjZSxcbiAgICBnZW9tZXRyeTogb3B0cy5nZW9tZXRyeSxcbiAgICBwaW5GaXJzdExldmVsOiBvcHRzLnBpbkZpcnN0TGV2ZWwsXG4gICAgdGV4dHVyZVN0b3JlT3B0czogb3B0cy50ZXh0dXJlU3RvcmVPcHRzLFxuICAgIGxheWVyT3B0czogb3B0cy5sYXllck9wdHNcbiAgfSk7XG5cbiAgcmV0dXJuIHNjZW5lO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFNjZW5lIHNjZW5lfSB3aXRoIG5vIGxheWVycyBhbmQgYWRkcyBpdCB0byB0aGUgdmlld2VyLlxuICpcbiAqIExheWVycyBtYXkgYmUgYWRkZWQgdG8gdGhlIHNjZW5lIGJ5IGNhbGxpbmcge0BsaW5rIFNjZW5lI2NyZWF0ZUxheWVyfS5cbiAqIEhvd2V2ZXIsIGlmIHRoZSBzY2VuZSBoYXMgYSBzaW5nbGUgbGF5ZXIsIGl0IGlzIHNpbXBsZXIgdG8gY2FsbFxuICoge0BsaW5rIFZpZXdlciNjcmVhdGVTY2VuZX0gaW5zdGVhZCBvZiB0aGlzIG1ldGhvZC5cbiAqXG4gKiBUaGUgY3VycmVudCBzY2VuZSBkb2VzIG5vdCBjaGFuZ2UuIFRvIHN3aXRjaCB0byB0aGUgc2NlbmUsIGNhbGxcbiAqIHtAbGluayBWaWV3ZXIjc3dpdGNoU2NlbmV9LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFNjZW5lIGNyZWF0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0ge1ZpZXd9IG9wdHMudmlldyBUaGUgc2NlbmUncyB1bmRlcmx5aW5nIHtAbGluayBWaWV3fS5cbiAqIEByZXR1cm4ge1NjZW5lfVxuICovXG5WaWV3ZXIucHJvdG90eXBlLmNyZWF0ZUVtcHR5U2NlbmUgPSBmdW5jdGlvbihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBzY2VuZSA9IG5ldyBTY2VuZSh0aGlzLCBvcHRzLnZpZXcpO1xuICB0aGlzLl9zY2VuZXMucHVzaChzY2VuZSk7XG5cbiAgcmV0dXJuIHNjZW5lO1xufTtcblxuXG5WaWV3ZXIucHJvdG90eXBlLl91cGRhdGVTY2VuZUxheWVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaTtcbiAgdmFyIGxheWVyO1xuXG4gIHZhciBzdGFnZSA9IHRoaXMuX3N0YWdlO1xuICB2YXIgY3VycmVudFNjZW5lID0gdGhpcy5fY3VycmVudFNjZW5lO1xuICB2YXIgcmVwbGFjZWRTY2VuZSA9IHRoaXMuX3JlcGxhY2VkU2NlbmU7XG5cbiAgdmFyIG9sZExheWVycyA9IHN0YWdlLmxpc3RMYXllcnMoKTtcblxuICAvLyBUaGUgc3RhZ2UgY29udGFpbnMgbGF5ZXJzIGZyb20gYXQgbW9zdCB0d28gc2NlbmVzOiB0aGUgY3VycmVudCBvbmUsIG9uIHRvcCxcbiAgLy8gYW5kIHRoZSBvbmUgY3VycmVudGx5IGJlaW5nIHN3aXRjaGVkIGF3YXkgZnJvbSwgb24gdGhlIGJvdHRvbS5cbiAgdmFyIG5ld0xheWVycyA9IFtdO1xuICBpZiAocmVwbGFjZWRTY2VuZSkge1xuICAgIG5ld0xheWVycyA9IG5ld0xheWVycy5jb25jYXQocmVwbGFjZWRTY2VuZS5saXN0TGF5ZXJzKCkpO1xuICB9XG4gIGlmIChjdXJyZW50U2NlbmUpIHtcbiAgICBuZXdMYXllcnMgPSBuZXdMYXllcnMuY29uY2F0KGN1cnJlbnRTY2VuZS5saXN0TGF5ZXJzKCkpO1xuICB9XG5cbiAgLy8gQSBzaW5nbGUgbGF5ZXIgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgc2NlbmUgYXQgYSB0aW1lLlxuICBpZiAoTWF0aC5hYnMob2xkTGF5ZXJzLmxlbmd0aCAtIG5ld0xheWVycy5sZW5ndGgpICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdGFnZSBhbmQgc2NlbmUgb3V0IG9mIHN5bmMnKTtcbiAgfVxuXG4gIGlmIChuZXdMYXllcnMubGVuZ3RoIDwgb2xkTGF5ZXJzLmxlbmd0aCkge1xuICAgIC8vIEEgbGF5ZXIgd2FzIHJlbW92ZWQuXG4gICAgZm9yIChpID0gMDsgaSA8IG9sZExheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGF5ZXIgPSBvbGRMYXllcnNbaV07XG4gICAgICBpZiAobmV3TGF5ZXJzLmluZGV4T2YobGF5ZXIpIDwgMCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVMYXllckZyb21TdGFnZShsYXllcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobmV3TGF5ZXJzLmxlbmd0aCA+IG9sZExheWVycy5sZW5ndGgpIHtcbiAgICAvLyBBIGxheWVyIHdhcyBhZGRlZC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbmV3TGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsYXllciA9IG5ld0xheWVyc1tpXTtcbiAgICAgIGlmIChvbGRMYXllcnMuaW5kZXhPZihsYXllcikgPCAwKSB7XG4gICAgICAgIHRoaXMuX2FkZExheWVyVG9TdGFnZShsYXllciwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogV2hlbiBpbiB0aGUgbWlkZGxlIG9mIGEgc2NlbmUgdHJhbnNpdGlvbiwgY2FsbCB0aGUgdHJhbnNpdGlvbiB1cGRhdGVcbiAgLy8gZnVuY3Rpb24gaW1tZWRpYXRlbHkgdG8gcHJldmVudCBhbiBhZGRlZCBsYXllciBmcm9tIGZsYXNoaW5nIHdpdGggdGhlIHdyb25nXG4gIC8vIG9wYWNpdHkuXG59O1xuXG5cblZpZXdlci5wcm90b3R5cGUuX2FkZExheWVyVG9TdGFnZSA9IGZ1bmN0aW9uKGxheWVyLCBpKSB7XG4gIC8vIFBpbiB0aGUgZmlyc3QgbGV2ZWwgdG8gZW5zdXJlIGEgZmFsbGJhY2sgd2hpbGUgdGhlIGxheWVyIGlzIHZpc2libGUuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIGlzIGRpc3RpbmN0IGZyb20gdGhlIGBwaW5GaXJzdExldmVsYCBvcHRpb24gcGFzc2VkIHRvXG4gIC8vIGNyZWF0ZVNjZW5lKCksIHdoaWNoIHBpbnMgdGhlIGxheWVyIGV2ZW4gd2hlbiBpdCdzIG5vdCB2aXNpYmxlLlxuICBsYXllci5waW5GaXJzdExldmVsKCk7XG4gIHRoaXMuX3N0YWdlLmFkZExheWVyKGxheWVyLCBpKTtcbn07XG5cblxuVmlld2VyLnByb3RvdHlwZS5fcmVtb3ZlTGF5ZXJGcm9tU3RhZ2UgPSBmdW5jdGlvbihsYXllcikge1xuICB0aGlzLl9zdGFnZS5yZW1vdmVMYXllcihsYXllcik7XG4gIGxheWVyLnVucGluRmlyc3RMZXZlbCgpO1xuICBsYXllci50ZXh0dXJlU3RvcmUoKS5jbGVhck5vdFBpbm5lZCgpO1xufTtcblxuXG5WaWV3ZXIucHJvdG90eXBlLl9hZGRTY2VuZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgc2NlbmUuYWRkRXZlbnRMaXN0ZW5lcignbGF5ZXJDaGFuZ2UnLCB0aGlzLl9sYXllckNoYW5nZUhhbmRsZXIpO1xuICBzY2VuZS5hZGRFdmVudExpc3RlbmVyKCd2aWV3Q2hhbmdlJywgdGhpcy5fdmlld0NoYW5nZUhhbmRsZXIpO1xufTtcblxuXG5WaWV3ZXIucHJvdG90eXBlLl9yZW1vdmVTY2VuZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgc2NlbmUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbGF5ZXJDaGFuZ2UnLCB0aGlzLl9sYXllckNoYW5nZUhhbmRsZXIpO1xuICBzY2VuZS5yZW1vdmVFdmVudExpc3RlbmVyKCd2aWV3Q2hhbmdlJywgdGhpcy5fdmlld0NoYW5nZUhhbmRsZXIpO1xufTtcblxuXG4vKipcbiAqIERlc3Ryb3lzIGEge0BsaW5rIFNjZW5lIHNjZW5lfSBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSB2aWV3ZXIuXG4gKiBAcGFyYW0ge1NjZW5lfSBzY2VuZVxuICovXG5WaWV3ZXIucHJvdG90eXBlLmRlc3Ryb3lTY2VuZSA9IGZ1bmN0aW9uKHNjZW5lKSB7XG4gIHZhciBpID0gdGhpcy5fc2NlbmVzLmluZGV4T2Yoc2NlbmUpO1xuICBpZiAoaSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1Y2ggc2NlbmUgaW4gdmlld2VyJyk7XG4gIH1cblxuICB2YXIgajtcbiAgdmFyIGxheWVycztcblxuICBpZiAodGhpcy5fY3VycmVudFNjZW5lID09PSBzY2VuZSkge1xuICAgIC8vIFRoZSBkZXN0cm95ZWQgc2NlbmUgaXMgdGhlIGN1cnJlbnQgc2NlbmUuXG4gICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVycywgcmVtb3ZlIGxheWVycyBmcm9tIHN0YWdlIGFuZCBjYW5jZWwgdHJhbnNpdGlvbi5cbiAgICB0aGlzLl9yZW1vdmVTY2VuZUV2ZW50TGlzdGVuZXJzKHNjZW5lKTtcbiAgICBsYXllcnMgPSBzY2VuZS5saXN0TGF5ZXJzKCk7XG4gICAgZm9yIChqID0gMDsgaiA8IGxheWVycy5sZW5ndGg7IGorKykge1xuICAgICAgdGhpcy5fcmVtb3ZlTGF5ZXJGcm9tU3RhZ2UobGF5ZXJzW2pdKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhbmNlbEN1cnJlbnRUd2Vlbikge1xuICAgICAgdGhpcy5fY2FuY2VsQ3VycmVudFR3ZWVuKCk7XG4gICAgICB0aGlzLl9jYW5jZWxDdXJyZW50VHdlZW4gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50U2NlbmUgPSBudWxsO1xuICAgIHRoaXMuZW1pdCgnc2NlbmVDaGFuZ2UnKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9yZXBsYWNlZFNjZW5lID09PSBzY2VuZSkge1xuICAgIC8vIFRoZSBkZXN0cm95ZWQgc2NlbmUgaXMgYmVpbmcgc3dpdGNoZWQgYXdheSBmcm9tLlxuICAgIC8vIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgYW5kIHJlbW92ZSBsYXllcnMgZnJvbSBzdGFnZS5cbiAgICB0aGlzLl9yZW1vdmVTY2VuZUV2ZW50TGlzdGVuZXJzKHNjZW5lKTtcbiAgICBsYXllcnMgPSBzY2VuZS5saXN0TGF5ZXJzKCk7XG4gICAgZm9yIChqID0gMDsgaiA8IGxheWVycy5sZW5ndGg7IGorKykge1xuICAgICAgdGhpcy5fcmVtb3ZlTGF5ZXJGcm9tU3RhZ2UobGF5ZXJzW2pdKTtcbiAgICB9XG4gICAgdGhpcy5fcmVwbGFjZWRTY2VuZSA9IG51bGw7XG4gIH1cblxuICB0aGlzLl9zY2VuZXMuc3BsaWNlKGksIDEpO1xuXG4gIHNjZW5lLmRlc3Ryb3koKTtcbn07XG5cblxuLyoqXG4gKiBEZXN0cm95cyBhbGwge0BsaW5rIFNjZW5lIHNjZW5lc30gYW5kIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSB2aWV3ZXIuXG4gKi9cblZpZXdlci5wcm90b3R5cGUuZGVzdHJveUFsbFNjZW5lcyA9IGZ1bmN0aW9uKCkge1xuICB3aGlsZSAodGhpcy5fc2NlbmVzLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLmRlc3Ryb3lTY2VuZSh0aGlzLl9zY2VuZXNbMF0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSB2aWV3ZXIgY29udGFpbnMgYSB7QGxpbmsgU2NlbmUgc2NlbmV9LlxuICogQHBhcmFtIHtTY2VuZX0gc2NlbmVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblZpZXdlci5wcm90b3R5cGUuaGFzU2NlbmUgPSBmdW5jdGlvbihzY2VuZSkge1xuICByZXR1cm4gdGhpcy5fc2NlbmVzLmluZGV4T2Yoc2NlbmUpID49IDA7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHtAbGluayBTY2VuZSBzY2VuZXN9LlxuICogQHJldHVybiB7U2NlbmVbXX1cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5saXN0U2NlbmVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbXS5jb25jYXQodGhpcy5fc2NlbmVzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHtAbGluayBTY2VuZSBzY2VuZX0sIG9yIG51bGwgaWYgdGhlcmUgaXNuJ3Qgb25lLlxuICpcbiAqIFRvIGNoYW5nZSB0aGUgY3VycmVudCBzY2VuZSwgY2FsbCB7QGxpbmsgVmlld2VyI3N3aXRjaFNjZW5lfS5cbiAqXG4gKiBAcmV0dXJuIHtTY2VuZX1cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5zY2VuZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY3VycmVudFNjZW5lO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHtAbGluayBWaWV3IHZpZXd9IGZvciB0aGUgY3VycmVudCB7QGxpbmsgU2NlbmUgc2NlbmV9LCBvciBudWxsXG4gKiBpZiB0aGVyZSBpc24ndCBvbmUuXG4gKiBAcmV0dXJuIHtWaWV3fVxuICovXG5WaWV3ZXIucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNjZW5lID0gdGhpcy5fY3VycmVudFNjZW5lO1xuICBpZiAoc2NlbmUpIHtcbiAgICByZXR1cm4gc2NlbmUudmlldygpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuXG4vKipcbiAqIFR3ZWVucyB0aGUge0BsaW5rIFZpZXcgdmlld30gZm9yIHRoZSBjdXJyZW50IHtAbGluayBTY2VuZSBzY2VuZX0uXG4gKlxuICogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nIHtAbGluayBTY2VuZSNsb29rVG99IG9uIHRoZSBjdXJyZW50XG4gKiBzY2VuZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25zIHRvIHBhc3MgaW50byB7QGxpbmsgU2NlbmUjbG9va1RvfS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRvbmUgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSB0d2VlbiBpcyBjb21wbGV0ZS5cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5sb29rVG8gPSBmdW5jdGlvbihwYXJhbXMsIG9wdHMsIGRvbmUpIHtcbiAgLy8gVE9ETzogaXMgaXQgYW4gZXJyb3IgdG8gY2FsbCBsb29rVG8gd2hlbiBubyBzY2VuZSBpcyBkaXNwbGF5ZWQ/XG4gIHZhciBzY2VuZSA9IHRoaXMuX2N1cnJlbnRTY2VuZTtcbiAgaWYgKHNjZW5lKSB7XG4gICAgc2NlbmUubG9va1RvKHBhcmFtcywgb3B0cywgZG9uZSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTdGFydHMgYSBtb3ZlbWVudCwgcG9zc2libHkgcmVwbGFjaW5nIHRoZSBjdXJyZW50IG1vdmVtZW50LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB7QGxpbmsgU2NlbmUjc3RhcnRNb3ZlbWVudH0gb24gdGhlXG4gKiBjdXJyZW50IHNjZW5lLiBJZiB0aGVyZSBpcyBubyBjdXJyZW50IHNjZW5lLCB0aGlzIGlzIGEgbm8tb3AuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIG1vdmVtZW50IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZG9uZSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgbW92ZW1lbnQgZmluaXNoZXMgb3IgaXNcbiAqICAgICBpbnRlcnJ1cHRlZC5cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5zdGFydE1vdmVtZW50ID0gZnVuY3Rpb24oZm4sIGRvbmUpIHtcbiAgdmFyIHNjZW5lID0gdGhpcy5fY3VycmVudFNjZW5lO1xuICBpZiAoIXNjZW5lKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNjZW5lLnN0YXJ0TW92ZW1lbnQoZm4sIGRvbmUpO1xufTtcblxuXG4vKipcbiAqIFN0b3BzIHRoZSBjdXJyZW50IG1vdmVtZW50LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB7QGxpbmsgU2NlbmUjc3RvcE1vdmVtZW50fSBvbiB0aGVcbiAqIGN1cnJlbnQgc2NlbmUuIElmIHRoZXJlIGlzIG5vIGN1cnJlbnQgc2NlbmUsIHRoaXMgaXMgYSBuby1vcC5cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5zdG9wTW92ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNjZW5lID0gdGhpcy5fY3VycmVudFNjZW5lO1xuICBpZiAoIXNjZW5lKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNjZW5lLnN0b3BNb3ZlbWVudCgpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbW92ZW1lbnQuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nIHtAbGluayBTY2VuZSNtb3ZlbWVudH0gb24gdGhlXG4gKiBjdXJyZW50IHNjZW5lLiBJZiB0aGVyZSBpcyBubyBjdXJyZW50IHNjZW5lLCB0aGlzIGlzIGEgbm8tb3AuXG4gKlxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cblZpZXdlci5wcm90b3R5cGUubW92ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNjZW5lID0gdGhpcy5fY3VycmVudFNjZW5lO1xuICBpZiAoIXNjZW5lKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBzY2VuZS5tb3ZlbWVudCgpO1xufTtcblxuXG4vKipcbiAqIFNjaGVkdWxlcyBhbiBpZGxlIG1vdmVtZW50IHRvIGJlIGF1dG9tYXRpY2FsbHkgc3RhcnRlZCB3aGVuIHRoZSB2aWV3IHJlbWFpbnNcbiAqIHVuY2hhbmdlZCBmb3IgdGhlIGdpdmVuIHRpbWVvdXQgcGVyaW9kLlxuICpcbiAqIENoYW5naW5nIHRoZSB2aWV3IHdoaWxlIHRoZSBpZGxlIG1vdmVtZW50IGlzIGFjdGl2ZSBzdG9wcyB0aGUgbW92ZW1lbnQgYW5kXG4gKiBzY2hlZHVsZXMgaXQgdG8gc3RhcnQgYWdhaW4gYWZ0ZXIgdGhlIHNhbWUgdGltZW91dCBwZXJpb2QuIFRvIGRpc2FibGUgaXRcbiAqIHBlcm1hbmVudGx5LCBjYWxsIHdpdGggYSBudWxsIG1vdmVtZW50IG9yIGFuIGluZmluaXRlIHRpbWVvdXQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgVGltZW91dCBwZXJpb2QgaW4gbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbW92ZW1lbnQgQXV0b21hdGljIG1vdmVtZW50IGZ1bmN0aW9uLCBvciBudWxsIHRvIGRpc2FibGUuXG4gKi9cblZpZXdlci5wcm90b3R5cGUuc2V0SWRsZU1vdmVtZW50ID0gZnVuY3Rpb24odGltZW91dCwgbW92ZW1lbnQpIHtcbiAgdGhpcy5faWRsZVRpbWVyLnNldER1cmF0aW9uKHRpbWVvdXQpO1xuICB0aGlzLl9pZGxlTW92ZW1lbnQgPSBtb3ZlbWVudDtcbn07XG5cblxuLyoqXG4gKiBTdG9wcyB0aGUgaWRsZSBtb3ZlbWVudC4gSXQgd2lsbCBiZSBzdGFydGVkIGFnYWluIGFmdGVyIHRoZSB0aW1lb3V0IHNldCBieVxuICoge0BsaW5rIFZpZXdlciNzZXRJZGxlTW92ZW1lbnR9LlxuICovXG5WaWV3ZXIucHJvdG90eXBlLmJyZWFrSWRsZU1vdmVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc3RvcE1vdmVtZW50KCk7XG4gIHRoaXMuX3Jlc2V0SWRsZVRpbWVyKCk7XG59O1xuXG5cblZpZXdlci5wcm90b3R5cGUuX3Jlc2V0SWRsZVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2lkbGVUaW1lci5zdGFydCgpO1xufTtcblxuXG5WaWV3ZXIucHJvdG90eXBlLl90cmlnZ2VySWRsZVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpZGxlTW92ZW1lbnQgPSB0aGlzLl9pZGxlTW92ZW1lbnQ7XG4gIGlmICghaWRsZU1vdmVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuc3RhcnRNb3ZlbWVudChpZGxlTW92ZW1lbnQpO1xufTtcblxuXG52YXIgZGVmYXVsdFN3aXRjaER1cmF0aW9uID0gMTAwMDtcblxuZnVuY3Rpb24gZGVmYXVsdFRyYW5zaXRpb25VcGRhdGUodmFsLCBuZXdTY2VuZSwgb2xkU2NlbmUpIHtcbiAgdmFyIGxheWVycyA9IG5ld1NjZW5lLmxpc3RMYXllcnMoKTtcbiAgbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICBsYXllci5tZXJnZUVmZmVjdHMoeyBvcGFjaXR5OiB2YWwgfSk7XG4gIH0pO1xuXG4gIG5ld1NjZW5lLl9ob3RzcG90Q29udGFpbmVyLmRvbUVsZW1lbnQoKS5zdHlsZS5vcGFjaXR5ID0gdmFsO1xufVxuXG5cbi8qKlxuICogU3dpdGNoZXMgdG8gYW5vdGhlciB7QGxpbmsgU2NlbmUgc2NlbmV9IHdpdGggYSBmYWRlIHRyYW5zaXRpb24uIFRoaXMgc2NlbmVcbiAqIGJlY29tZXMgdGhlIGN1cnJlbnQgb25lLlxuICpcbiAqIElmIGEgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IHRha2luZyBwbGFjZSwgaXQgaXMgaW50ZXJydXB0ZWQgYmVmb3JlIHRoZSBuZXcgb25lXG4gKiBzdGFydHMuXG4gKlxuICogQHBhcmFtIHtTY2VuZX0gbmV3U2NlbmUgVGhlIHNjZW5lIHRvIHN3aXRjaCB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRyYW5zaXRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50cmFuc2l0aW9uRHVyYXRpb249MTAwMF0gVHJhbnNpdGlvbiBkdXJhdGlvbiwgaW5cbiAqICAgICBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMudHJhbnNpdGlvblVwZGF0ZT1kZWZhdWx0VHJhbnNpdGlvblVwZGF0ZV1cbiAqICAgICBUcmFuc2l0aW9uIHVwZGF0ZSBmdW5jdGlvbiwgd2l0aCBzaWduYXR1cmUgYGYodCwgbmV3U2NlbmUsIG9sZFNjZW5lKWAuXG4gKiAgICAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCBmcmFtZSB3aXRoIGB0YCBpbmNyZWFzaW5nIGZyb20gMCB0byAxLlxuICogICAgIEFuIGluaXRpYWwgY2FsbCB3aXRoIGB0PTBgIGFuZCBhIGZpbmFsIGNhbGwgd2l0aCBgdD0xYCBhcmUgZ3VhcmFudGVlZC5cbiAqICAgICBUaGUgZGVmYXVsdCBmdW5jdGlvbiBzZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBuZXcgc2NlbmUgdG8gYHRgLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZG9uZSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHRyYW5zaXRpb24gZmluaXNoZXMgb3IgaXNcbiAqICAgICBpbnRlcnJ1cHRlZC4gSWYgdGhlIG5ldyBzY2VuZSBpcyBlcXVhbCB0byB0aGUgb2xkIG9uZSwgbm8gdHJhbnNpdGlvblxuICogICAgIHRha2VzIHBsYWNlLCBidXQgdGhpcyBmdW5jdGlvbiBpcyBzdGlsbCBjYWxsZWQuXG4gKi9cblZpZXdlci5wcm90b3R5cGUuc3dpdGNoU2NlbmUgPSBmdW5jdGlvbihuZXdTY2VuZSwgb3B0cywgZG9uZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIGRvbmUgPSBkb25lIHx8IG5vb3A7XG5cbiAgdmFyIHN0YWdlID0gdGhpcy5fc3RhZ2U7XG5cbiAgdmFyIG9sZFNjZW5lID0gdGhpcy5fY3VycmVudFNjZW5lO1xuXG4gIC8vIERvIG5vdGhpbmcgaWYgdGhlIHRhcmdldCBzY2VuZSBpcyB0aGUgY3VycmVudCBvbmUuXG4gIGlmIChvbGRTY2VuZSA9PT0gbmV3U2NlbmUpIHtcbiAgICBkb25lKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX3NjZW5lcy5pbmRleE9mKG5ld1NjZW5lKSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1Y2ggc2NlbmUgaW4gdmlld2VyJyk7XG4gIH1cblxuICAvLyBDYW5jZWwgYW4gYWxyZWFkeSBvbmdvaW5nIHRyYW5zaXRpb24uIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBzdGFnZSBjb250YWluc1xuICAvLyBsYXllcnMgZnJvbSBleGFjdGx5IG9uZSBzY2VuZSBiZWZvcmUgdGhlIHRyYW5zaXRpb24gYmVnaW5zLlxuICBpZiAodGhpcy5fY2FuY2VsQ3VycmVudFR3ZWVuKSB7XG4gICAgdGhpcy5fY2FuY2VsQ3VycmVudFR3ZWVuKCk7XG4gICAgdGhpcy5fY2FuY2VsQ3VycmVudFR3ZWVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBvbGRTY2VuZUxheWVycyA9IG9sZFNjZW5lID8gb2xkU2NlbmUubGlzdExheWVycygpIDogW107XG4gIHZhciBuZXdTY2VuZUxheWVycyA9IG5ld1NjZW5lLmxpc3RMYXllcnMoKTtcbiAgdmFyIHN0YWdlTGF5ZXJzID0gc3RhZ2UubGlzdExheWVycygpO1xuXG4gIC8vIENoZWNrIHRoYXQgdGhlIHN0YWdlIGNvbnRhaW5zIGV4YWN0bHkgYXMgbWFueSBsYXllcnMgYXMgdGhlIGN1cnJlbnQgc2NlbmUsXG4gIC8vIGFuZCB0aGF0IHRoZSB0b3AgbGF5ZXIgaXMgdGhlIHJpZ2h0IG9uZS4gSWYgdGhpcyB0ZXN0IGZhaWxzLCBlaXRoZXIgdGhlcmVcbiAgLy8gaXMgYSBidWcgb3IgdGhlIHVzZXIgdHJpZWQgdG8gbW9kaWZ5IHRoZSBzdGFnZSBjb25jdXJyZW50bHkuXG4gIGlmIChvbGRTY2VuZSAmJiAoKHN0YWdlTGF5ZXJzLmxlbmd0aCAhPT0gb2xkU2NlbmVMYXllcnMubGVuZ3RoKSB8fFxuICAgICAgKHN0YWdlTGF5ZXJzLmxlbmd0aCA+IDEgJiYgc3RhZ2VMYXllcnNbMF0gIT0gb2xkU2NlbmVMYXllcnNbMF0pKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3RhZ2Ugbm90IGluIHN5bmMgd2l0aCB2aWV3ZXInKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgdHJhbnNpdGlvbiBwYXJhbWV0ZXJzLlxuICB2YXIgZHVyYXRpb24gPSBvcHRzLnRyYW5zaXRpb25EdXJhdGlvbiAhPSBudWxsID9cbiAgICAgIG9wdHMudHJhbnNpdGlvbkR1cmF0aW9uIDogZGVmYXVsdFN3aXRjaER1cmF0aW9uO1xuICB2YXIgdXBkYXRlID0gb3B0cy50cmFuc2l0aW9uVXBkYXRlICE9IG51bGwgP1xuICAgICAgb3B0cy50cmFuc2l0aW9uVXBkYXRlIDogZGVmYXVsdFRyYW5zaXRpb25VcGRhdGU7XG5cbiAgLy8gQWRkIG5ldyBzY2VuZSBsYXllcnMgaW50byB0aGUgc3RhZ2UgYmVmb3JlIHN0YXJ0aW5nIHRoZSB0cmFuc2l0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1NjZW5lTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fYWRkTGF5ZXJUb1N0YWdlKG5ld1NjZW5lTGF5ZXJzW2ldKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gZXZlcnkgZnJhbWUuXG4gIGZ1bmN0aW9uIHR3ZWVuVXBkYXRlKHZhbCkge1xuICAgIHVwZGF0ZSh2YWwsIG5ld1NjZW5lLCBvbGRTY2VuZSk7XG4gIH1cblxuICAvLyBPbmNlIHRoZSB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlLCByZW1vdmUgb2xkIHNjZW5lIGxheWVycyBmcm9tIHRoZSBzdGFnZSBhbmRcbiAgLy8gcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnMuIElmIHRoZSBvbGQgc2NlbmUgd2FzIGRlc3Ryb3llZCBkdXJpbmcgdGhlXG4gIC8vIHRyYW5zaXRpb24sIHRoaXMgaGFzIGFscmVhZHkgYmVlbiB0YWtlbiBjYXJlIG9mLiBPdGhlcndpc2UsIHdlIHN0aWxsIG5lZWRcbiAgLy8gdG8gZ2V0IGEgZnJlc2ggY29weSBvZiB0aGUgc2NlbmUncyBsYXllcnMsIHNpbmNlIHRoZXkgbWlnaHQgaGF2ZSBjaGFuZ2VkXG4gIC8vIGR1cmluZyB0aGUgdHJhbnNpdGlvbi5cbiAgZnVuY3Rpb24gdHdlZW5Eb25lKCkge1xuICAgIGlmIChzZWxmLl9yZXBsYWNlZFNjZW5lKSB7XG4gICAgICBzZWxmLl9yZW1vdmVTY2VuZUV2ZW50TGlzdGVuZXJzKHNlbGYuX3JlcGxhY2VkU2NlbmUpO1xuICAgICAgb2xkU2NlbmVMYXllcnMgPSBzZWxmLl9yZXBsYWNlZFNjZW5lLmxpc3RMYXllcnMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkU2NlbmVMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5fcmVtb3ZlTGF5ZXJGcm9tU3RhZ2Uob2xkU2NlbmVMYXllcnNbaV0pO1xuICAgICAgfVxuICAgICAgc2VsZi5fcmVwbGFjZWRTY2VuZSA9IG51bGw7XG4gICAgfVxuICAgIHNlbGYuX2NhbmNlbEN1cnJlbnRUd2VlbiA9IG51bGw7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgLy8gU3RvcmUgdGhlIGNhbmNlbGFibGUgZm9yIHRoZSB0cmFuc2l0aW9uLlxuICB0aGlzLl9jYW5jZWxDdXJyZW50VHdlZW4gPSB0d2VlbihkdXJhdGlvbiwgdHdlZW5VcGRhdGUsIHR3ZWVuRG9uZSk7XG5cbiAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGFuZCByZXBsYWNlZCBzY2VuZS5cbiAgdGhpcy5fY3VycmVudFNjZW5lID0gbmV3U2NlbmU7XG4gIHRoaXMuX3JlcGxhY2VkU2NlbmUgPSBvbGRTY2VuZTtcblxuICAvLyBFbWl0IHNjZW5lIGFuZCB2aWV3IGNoYW5nZSBldmVudHMuXG4gIHRoaXMuZW1pdCgnc2NlbmVDaGFuZ2UnKTtcbiAgdGhpcy5lbWl0KCd2aWV3Q2hhbmdlJyk7XG5cbiAgLy8gQWRkIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgbmV3IHNjZW5lLlxuICAvLyBOb3RlIHRoYXQgZXZlbnQgbGlzdGVuZXJzIGNhbiBvbmx5IGJlIHJlbW92ZWQgZnJvbSB0aGUgb2xkIHNjZW5lIG9uY2UgdGhlXG4gIC8vIHRyYW5zaXRpb24gaXMgY29tcGxldGUsIHNpbmNlIGxheWVycyBtaWdodCBnZXQgYWRkZWQgb3IgcmVtb3ZlZCBpbiB0aGVcbiAgLy8gaW50ZXJpbS5cbiAgdGhpcy5fYWRkU2NlbmVFdmVudExpc3RlbmVycyhuZXdTY2VuZSk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVmlld2VyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RhdGljQXNzZXQgPSByZXF1aXJlKCcuL1N0YXRpYycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbC9pbmhlcml0cycpO1xudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogQGNsYXNzIER5bmFtaWNBc3NldFxuICogQGltcGxlbWVudHMgQXNzZXRcbiAqIEBleHRlbmRzIFN0YXRpY0Fzc2V0XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQW4ge0BsaW5rIEFzc2V0fSB3aG9zZSBwaXhlbCBjb250ZW50cyBtYXkgY2hhbmdlLlxuICpcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gZWxlbWVudCBUaGVcbiAqICAgICB1bmRlcmx5aW5nIHBpeGVsIHNvdXJjZS5cbiAqIEB0aHJvd3MgSWYgdGhlIHBpeGVsIHNvdXJjZSBpcyB1bnN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gRHluYW1pY0Fzc2V0KGVsZW1lbnQpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uY2FsbCh0aGlzLCBlbGVtZW50KTtcbiAgdGhpcy5fdGltZXN0YW1wID0gMDtcbn1cblxuaW5oZXJpdHMoRHluYW1pY0Fzc2V0LCBTdGF0aWNBc3NldCk7XG5ldmVudEVtaXR0ZXIoRHluYW1pY0Fzc2V0KTtcblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5EeW5hbWljQXNzZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuRHluYW1pY0Fzc2V0LnByb3RvdHlwZS50aW1lc3RhbXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3RpbWVzdGFtcDtcbn07XG5cbkR5bmFtaWNBc3NldC5wcm90b3R5cGUuaXNEeW5hbWljID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBNYXJrcyB0aGUgYXNzZXQgZGlydHksIHNpZ25hbGluZyB0aGF0IHRoZSBjb250ZW50cyBvZiB0aGUgdW5kZXJseWluZyBwaXhlbFxuICogc291cmNlIGhhdmUgY2hhbmdlZC5cbiAqXG4gKiBAdGhyb3dzIElmIHRoZSBhc3NldCBpcyBub3QgZHluYW1pYy5cbiAqL1xuRHluYW1pY0Fzc2V0LnByb3RvdHlwZS5tYXJrRGlydHkgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdGltZXN0YW1wKys7XG4gIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IER5bmFtaWNBc3NldDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2xvYmFsJyk7XG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxudmFyIHByb3BlcnR5TWFwID0ge1xuICBIVE1MSW1hZ2VFbGVtZW50OiBbJ25hdHVyYWxXaWR0aCcsICduYXR1cmFsSGVpZ2h0J10sXG4gIEhUTUxDYW52YXNFbGVtZW50OiBbJ3dpZHRoJywgJ2hlaWdodCddLFxuICBJbWFnZUJpdG1hcDogWyd3aWR0aCcsICdoZWlnaHQnXVxufTtcblxuLyoqXG4gKiBAY2xhc3MgU3RhdGljQXNzZXRcbiAqIEBpbXBsZW1lbnRzIEFzc2V0XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQW4ge0BsaW5rIEFzc2V0fSB3aG9zZSBwaXhlbCBjb250ZW50cyBuZXZlciBjaGFuZ2UuXG4gKlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEltYWdlQml0bWFwfSBlbGVtZW50IFRoZVxuICogICAgIHVuZGVybHlpbmcgcGl4ZWwgc291cmNlLlxuICogQHRocm93cyBJZiB0aGUgcGl4ZWwgc291cmNlIGlzIHVuc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBTdGF0aWNBc3NldChlbGVtZW50KSB7XG4gIHZhciBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgZm9yICh2YXIgdHlwZSBpbiBwcm9wZXJ0eU1hcCkge1xuICAgIGlmIChnbG9iYWxbdHlwZV0gJiYgZWxlbWVudCBpbnN0YW5jZW9mIGdsb2JhbFt0eXBlXSkge1xuICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3dpZHRoUHJvcCA9IHByb3BlcnR5TWFwW3R5cGVdWzBdO1xuICAgICAgdGhpcy5faGVpZ2h0UHJvcCA9IHByb3BlcnR5TWFwW3R5cGVdWzFdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghc3VwcG9ydGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwaXhlbCBzb3VyY2UnKTtcbiAgfVxuXG4gIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xufVxuXG5ldmVudEVtaXR0ZXIoU3RhdGljQXNzZXQpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cblN0YXRpY0Fzc2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblN0YXRpY0Fzc2V0LnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbGVtZW50O1xufTtcblxuU3RhdGljQXNzZXQucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbGVtZW50W3RoaXMuX3dpZHRoUHJvcF07XG59O1xuXG5TdGF0aWNBc3NldC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbGVtZW50W3RoaXMuX2hlaWdodFByb3BdO1xufTtcblxuU3RhdGljQXNzZXQucHJvdG90eXBlLnRpbWVzdGFtcCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMDtcbn07XG5cblN0YXRpY0Fzc2V0LnByb3RvdHlwZS5pc0R5bmFtaWMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0aWNBc3NldDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi91dGlsL2RlZmF1bHRzJyk7XG5cbnZhciBkZWZhdWx0U3BlZWQgPSAwLjE7XG52YXIgZGVmYXVsdEFjY2VsID0gMC4wMTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICB5YXdTcGVlZDogZGVmYXVsdFNwZWVkLFxuICBwaXRjaFNwZWVkOiBkZWZhdWx0U3BlZWQsXG4gIGZvdlNwZWVkOiBkZWZhdWx0U3BlZWQsXG4gIHlhd0FjY2VsOiBkZWZhdWx0QWNjZWwsXG4gIHBpdGNoQWNjZWw6IGRlZmF1bHRBY2NlbCxcbiAgZm92QWNjZWw6IGRlZmF1bHRBY2NlbCxcbiAgdGFyZ2V0UGl0Y2g6IDAsXG4gIHRhcmdldEZvdjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLnlhd1NwZWVkPTAuMV0gWWF3IG1heGltdW0gc3BlZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy5waXRjaFNwZWVkPTAuMV0gUGl0Y2ggbWF4aW11bSBzcGVlZFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLmZvdlNwZWVkPTAuMV0gRm92IG1heGltdW0gc3BlZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy55YXdBY2NlbD0wLjAxXSBZYXcgYWNjZWxlcmF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdHMucGl0Y2hBY2NlbD0wLjAxXSBQaXRjaCBhY2NlbGVyYXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy5mb3ZBY2NlbD0wLjAxXSBGb3YgYWNjZWxlcmF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdHMudGFyZ2V0UGl0Y2g9MF0gVmFsdWUgdGhhdCBwaXRjaCBjb252ZXJnZXMgdG8uIGBudWxsYCBtZWFucyB0aGF0IHRoZSBwaXRjaCB3aWxsIG5vdCBjaGFuZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdHMudGFyZ2V0Rm92PW51bGxdIFZhbHVlIHRoYXQgZm92IGNvbnZlcmdlcyB0by4gYG51bGxgIG1lYW5zIHRoYXQgdGhlIGZvdiB3aWxsIG5vdCBjaGFuZ2UuXG4gKiBAcmV0dXJucyBNb3ZlbWVudCBmdW5jdGlvbiB0aGF0IGNhbiBiZSBwYXNzZWQgdG8ge0BsaW5rIFZpZXdlciNzZXRJZGxlTW92ZW1lbnR9IG9yIHtAbGluayBTY2VuZSNzdGFydE1vdmVtZW50fVxuKi9cbmZ1bmN0aW9uIGF1dG9yb3RhdGUob3B0cykge1xuXG4gIG9wdHMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCBkZWZhdWx0T3B0aW9ucyk7XG5cbiAgdmFyIHlhd1NwZWVkID0gb3B0cy55YXdTcGVlZDtcbiAgdmFyIHBpdGNoU3BlZWQgPSBvcHRzLnBpdGNoU3BlZWQ7XG4gIHZhciBmb3ZTcGVlZCA9IG9wdHMuZm92U3BlZWQ7XG4gIHZhciB5YXdBY2NlbCA9IG9wdHMueWF3QWNjZWw7XG4gIHZhciBwaXRjaEFjY2VsID0gb3B0cy5waXRjaEFjY2VsO1xuICB2YXIgZm92QWNjZWwgPSBvcHRzLmZvdkFjY2VsO1xuICB2YXIgdGFyZ2V0UGl0Y2ggPSBvcHRzLnRhcmdldFBpdGNoO1xuICB2YXIgdGFyZ2V0Rm92ID0gb3B0cy50YXJnZXRGb3Y7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHN0YXJ0KCkge1xuXG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB2YXIgbGFzdFlhd1NwZWVkID0gMDtcbiAgICB2YXIgbGFzdFBpdGNoU3BlZWQgPSAwO1xuICAgIHZhciBsYXN0Rm92U3BlZWQgPSAwO1xuXG4gICAgdmFyIGN1cnJlbnRZYXdTcGVlZCA9IDA7XG4gICAgdmFyIGN1cnJlbnRQaXRjaFNwZWVkID0gMDtcbiAgICB2YXIgY3VycmVudEZvdlNwZWVkID0gMDtcblxuICAgIHZhciB0aW1lRGVsdGE7XG4gICAgdmFyIHlhd0RlbHRhO1xuICAgIHZhciBwaXRjaERlbHRhO1xuICAgIHZhciBmb3ZEZWx0YTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBzdGVwKHBhcmFtcywgY3VycmVudFRpbWUpIHtcblxuICAgICAgdGltZURlbHRhID0gKGN1cnJlbnRUaW1lIC0gbGFzdFRpbWUpIC8gMTAwMDtcbiAgICAgIGN1cnJlbnRZYXdTcGVlZCA9IE1hdGgubWluKGxhc3RZYXdTcGVlZCArIHRpbWVEZWx0YSAqIHlhd0FjY2VsLCB5YXdTcGVlZCk7XG4gICAgICB5YXdEZWx0YSA9IGN1cnJlbnRZYXdTcGVlZCAqIHRpbWVEZWx0YTtcbiAgICAgIHBhcmFtcy55YXcgPSBwYXJhbXMueWF3ICsgeWF3RGVsdGE7XG5cbiAgICAgIGlmICh0YXJnZXRQaXRjaCAhPSBudWxsICYmIHBhcmFtcy5waXRjaCAhPT0gdGFyZ2V0UGl0Y2gpIHtcbiAgICAgICAgdmFyIHBpdGNoVGhyZXNoID0gMC41ICogbGFzdFBpdGNoU3BlZWQgKiBsYXN0UGl0Y2hTcGVlZCAvIHBpdGNoQWNjZWw7XG4gICAgICAgIGlmIChNYXRoLmFicyh0YXJnZXRQaXRjaCAtIHBhcmFtcy5waXRjaCkgPiBwaXRjaFRocmVzaCkge1xuICAgICAgICAgIC8vIEFjY2VsZXJhdGlvbiBwaGFzZVxuICAgICAgICAgIGN1cnJlbnRQaXRjaFNwZWVkID0gTWF0aC5taW4obGFzdFBpdGNoU3BlZWQgKyB0aW1lRGVsdGEgKiBwaXRjaEFjY2VsLCBwaXRjaFNwZWVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZWNlbGVyYXRpb24gcGhhc2VcbiAgICAgICAgICBjdXJyZW50UGl0Y2hTcGVlZCA9IE1hdGgubWF4KGxhc3RQaXRjaFNwZWVkIC0gdGltZURlbHRhICogcGl0Y2hBY2NlbCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3VycmVudFBpdGNoU3BlZWQgaXMgdGhlIGFic29sdXRlIHZhbHVlICg+PSAwKVxuICAgICAgICBwaXRjaERlbHRhID0gY3VycmVudFBpdGNoU3BlZWQgKiB0aW1lRGVsdGE7XG4gICAgICAgIGlmICh0YXJnZXRQaXRjaCA8IHBhcmFtcy5waXRjaCkge1xuICAgICAgICAgIHBhcmFtcy5waXRjaCA9IE1hdGgubWF4KHRhcmdldFBpdGNoLCBwYXJhbXMucGl0Y2ggLSBwaXRjaERlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0UGl0Y2ggPiBwYXJhbXMucGl0Y2gpIHtcbiAgICAgICAgICBwYXJhbXMucGl0Y2ggPSBNYXRoLm1pbih0YXJnZXRQaXRjaCwgcGFyYW1zLnBpdGNoICsgcGl0Y2hEZWx0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldEZvdiAhPSBudWxsICYmIHBhcmFtcy5mb3YgIT09IHRhcmdldFBpdGNoKSB7XG4gICAgICAgIHZhciBmb3ZUaHJlc2ggPSAwLjUgKiBsYXN0Rm92U3BlZWQgKiBsYXN0Rm92U3BlZWQgLyBmb3ZBY2NlbDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHRhcmdldEZvdiAtIHBhcmFtcy5mb3YpID4gZm92VGhyZXNoKSB7XG4gICAgICAgICAgLy8gQWNjZWxlcmF0aW9uIHBoYXNlXG4gICAgICAgICAgY3VycmVudEZvdlNwZWVkID0gTWF0aC5taW4obGFzdEZvdlNwZWVkICsgdGltZURlbHRhICogZm92QWNjZWwsIGZvdlNwZWVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZWNlbGVyYXRpb24gcGhhc2VcbiAgICAgICAgICBjdXJyZW50Rm92U3BlZWQgPSBNYXRoLm1heChsYXN0Rm92U3BlZWQgLSB0aW1lRGVsdGEgKiBmb3ZBY2NlbCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3VycmVudEZvdlNwZWVkIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSAoPj0gMClcbiAgICAgICAgZm92RGVsdGEgPSBjdXJyZW50Rm92U3BlZWQgKiB0aW1lRGVsdGE7XG4gICAgICAgIGlmICh0YXJnZXRGb3YgPCBwYXJhbXMuZm92KSB7XG4gICAgICAgICAgcGFyYW1zLmZvdiA9IE1hdGgubWF4KHRhcmdldEZvdiwgcGFyYW1zLmZvdiAtIGZvdkRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0Rm92ID4gcGFyYW1zLmZvdikge1xuICAgICAgICAgIHBhcmFtcy5mb3YgPSBNYXRoLm1pbih0YXJnZXRGb3YsIHBhcmFtcy5mb3YgKyBmb3ZEZWx0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIGxhc3RZYXdTcGVlZCA9IGN1cnJlbnRZYXdTcGVlZDtcbiAgICAgIGxhc3RQaXRjaFNwZWVkID0gY3VycmVudFBpdGNoU3BlZWQ7XG4gICAgICBsYXN0Rm92U3BlZWQgPSBjdXJyZW50Rm92U3BlZWQ7XG5cbiAgICAgIHJldHVybiBwYXJhbXM7XG5cbiAgICB9O1xuXG4gIH07XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhdXRvcm90YXRlOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1vZCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kJyk7XG5cbi8vIEFuIExydU1hcCBob2xkcyB1cCB0byBhIG1heGltdW0gbnVtYmVyIG9mIGtleS12YWx1ZSBwYWlycywgb3JkZXJlZCBieSB0aGVpclxuLy8gdGltZSBvZiBpbnNlcnRpb24uIFdoZW4gdGhlIGFkZGl0aW9uIG9mIGEga2V5LXZhbHVlIHBhaXIgd291bGQgY2F1c2UgdGhlXG4vLyBjYXBhY2l0eSB0byBiZSBleGNlZWRlZCwgdGhlIG9sZGVzdCBrZXktdmFsdWUgcGFpciBpbiB0aGUgc2V0IGlzIGV2aWN0ZWQuXG4vLyBBcyBhIHNwZWNpYWwgY2FzZSwgYW4gTHJ1TWFwIHdpdGggemVybyBjYXBhY2l0eSBhbHdheXMgcmVqZWN0cyB0aGUgaW5zZXJ0aW9uXG4vLyBvZiBhIGtleS12YWx1ZSBwYWlyLlxuLy9cbi8vIEtleXMgbXVzdCBpbXBsZW1lbnQgaGFzaCgpIGFuZCBlcXVhbHMoKS4gTm90ZSB0aGF0IHRoZSBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0XG4vLyBjdXJyZW50bHkgdXNlIGhhc2goKSwgYnV0IGEgZnV0dXJlIHZlcnNpb24gbWlnaHQuXG5mdW5jdGlvbiBMcnVNYXAoY2FwYWNpdHkpIHtcbiAgaWYgKCFpc0Zpbml0ZShjYXBhY2l0eSkgfHwgTWF0aC5mbG9vcihjYXBhY2l0eSkgIT09IGNhcGFjaXR5IHx8IGNhcGFjaXR5IDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTHJ1TWFwOiBpbnZhbGlkIGNhcGFjaXR5Jyk7XG4gIH1cbiAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcblxuICAvLyBLZXlzIGFuZCB2YWx1ZXMgYXJlIHN0b3JlZCBpbiBjaXJjdWxhciBhcnJheXMgb3JkZXJlZCBieSBkZWNyZWFzaW5nIGFnZS5cbiAgLy8gU3RhcnQgaXMgdGhlIGluZGV4IG9mIHRoZSBvbGRlc3Qga2V5L3ZhbHVlIGFuZCBzaXplIGlzIHRoZSBudW1iZXIgb2YgdmFsaWRcbiAgLy8ga2V5L3ZhbHVlczsgdGhlIHJlZ2lvbiBjb250YWluaW5nIHZhbGlkIGtleXMvdmFsdWVzIG1heSB3cmFwIGFyb3VuZC5cbiAgdGhpcy5fa2V5cyA9IG5ldyBBcnJheSh0aGlzLl9jYXBhY2l0eSk7XG4gIHRoaXMuX3ZhbHVlcyA9IG5ldyBBcnJheSh0aGlzLl9jYXBhY2l0eSk7XG4gIHRoaXMuX3N0YXJ0ID0gMDtcbiAgdGhpcy5fc2l6ZSA9IDA7XG59XG5cbkxydU1hcC5wcm90b3R5cGUuX2luZGV4ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gbW9kKHRoaXMuX3N0YXJ0ICsgaSwgdGhpcy5fY2FwYWNpdHkpO1xufTtcblxuLy8gUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB0byB0aGUgc3BlY2lmaWVkIGtleSwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG5McnVNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NpemU7IGkrKykge1xuICAgIHZhciBleGlzdGluZ0tleSA9IHRoaXMuX2tleXNbdGhpcy5faW5kZXgoaSldO1xuICAgIGlmIChrZXkuZXF1YWxzKGV4aXN0aW5nS2V5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlc1t0aGlzLl9pbmRleChpKV07XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gQXNzb2NpYXRlcyB0aGUgc3BlY2lmaWVkIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCBrZXksIHBvc3NpYmx5IHJlcGxhY2luZyB0aGVcbi8vIGN1cnJlbnRseSBhc3NvY2lhdGVkIHZhbHVlLiBUaGUga2V5LXZhbHVlIHBhaXIgYmVjb21lcyB0aGUgbmV3ZXN0LiBJZiB0aGUgbWFwXG4vLyBpcyBhdCBjYXBhY2l0eSwgdGhlIG9sZGVzdCBrZXktdmFsdWUgcGFpciBpcyByZW1vdmVkLiBSZXR1cm5zIHRoZSByZW1vdmVkXG4vLyBrZXksIG9yIG51bGwgb3RoZXJ3aXNlLiBJZiB0aGUgY2FwYWNpdHkgaXMgemVybywgZG9lcyBub3RoaW5nIGFuZCByZXR1cm5zXG4vLyB0aGUga2V5LlxuTHJ1TWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gIGlmICh0aGlzLl9jYXBhY2l0eSA9PT0gMCkge1xuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgdGhpcy5kZWwoa2V5KTtcbiAgdmFyIGV2aWN0ZWRLZXkgPVxuICAgICAgdGhpcy5fc2l6ZSA9PT0gdGhpcy5fY2FwYWNpdHkgPyB0aGlzLl9rZXlzW3RoaXMuX2luZGV4KDApXSA6IG51bGw7XG4gIHRoaXMuX2tleXNbdGhpcy5faW5kZXgodGhpcy5fc2l6ZSldID0ga2V5O1xuICB0aGlzLl92YWx1ZXNbdGhpcy5faW5kZXgodGhpcy5fc2l6ZSldID0gdmFsdWU7XG4gIGlmICh0aGlzLl9zaXplIDwgdGhpcy5fY2FwYWNpdHkpIHtcbiAgICB0aGlzLl9zaXplKys7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc3RhcnQgPSB0aGlzLl9pbmRleCgxKTtcbiAgfVxuICByZXR1cm4gZXZpY3RlZEtleTtcbn07XG5cbi8vIFJlbW92ZXMgdGhlIGtleS12YWx1ZSBwYWlyIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS5cbi8vIFJldHVybnMgdGhlIHJlbW92ZWQgdmFsdWUsIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuTHJ1TWFwLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbihrZXkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcbiAgICBpZiAoa2V5LmVxdWFscyh0aGlzLl9rZXlzW3RoaXMuX2luZGV4KGkpXSkpIHtcbiAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0gdGhpcy5fdmFsdWVzW3RoaXMuX2luZGV4KGkpXTtcbiAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgdGhpcy5fc2l6ZSAtIDE7IGorKykge1xuICAgICAgICB0aGlzLl9rZXlzW3RoaXMuX2luZGV4KGopXSA9IHRoaXMuX2tleXNbdGhpcy5faW5kZXgoaiArIDEpXTtcbiAgICAgICAgdGhpcy5fdmFsdWVzW3RoaXMuX2luZGV4KGopXSA9IHRoaXMuX3ZhbHVlc1t0aGlzLl9pbmRleChqICsgMSldO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gUmV0dXJucyB3aGV0aGVyIHRoZXJlIGlzIGEgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LlxuTHJ1TWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcbiAgICBpZiAoa2V5LmVxdWFscyh0aGlzLl9rZXlzW3RoaXMuX2luZGV4KGkpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2Yga2V5LXZhbHVlIHBhaXJzIGluIHRoZSBtYXAuXG5McnVNYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3NpemU7XG59O1xuXG4vLyBSZW1vdmVzIGFsbCBrZXktdmFsdWUgcGFpcnMgZnJvbSB0aGUgbWFwLlxuTHJ1TWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9rZXlzLmxlbmd0aCA9IDA7XG4gIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSAwO1xuICB0aGlzLl9zdGFydCA9IDA7XG4gIHRoaXMuX3NpemUgPSAwO1xufTtcblxuLy8gQ2FsbHMgZm4oa2V5LCB2YWx1ZSkgZm9yIGVhY2ggaXRlbSBpbiB0aGUgbWFwLCBpbiBhbiB1bnNwZWNpZmllZCBvcmRlci5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiB0aW1lcyBmbiB3YXMgY2FsbGVkLlxuLy8gVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiB0aGUgbWFwIGlzIG11dGF0ZWQgZHVyaW5nIGl0ZXJhdGlvbi5cbkxydU1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XG4gICAgZm4odGhpcy5fa2V5c1t0aGlzLl9pbmRleChpKV0sIHRoaXMuX3ZhbHVlc1t0aGlzLl9pbmRleChpKV0pO1xuICAgIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMcnVNYXA7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtb2QgPSByZXF1aXJlKCcuLi91dGlsL21vZCcpO1xuXG4vLyBBbiBMcnVTZXQgaG9sZHMgdXAgdG8gYSBtYXhpbXVtIG51bWJlciBvZiBlbGVtZW50cywgb3JkZXJlZCBieSB0aGVpciB0aW1lIG9mXG4vLyBpbnNlcnRpb24uIFdoZW4gdGhlIGFkZGl0aW9uIG9mIGFuIGVsZW1lbnQgd291bGQgY2F1c2UgdGhlIGNhcGFjaXR5IHRvIGJlXG4vLyBleGNlZWRlZCwgdGhlIG9sZGVzdCBlbGVtZW50IGluIHRoZSBzZXQgaXMgZXZpY3RlZC4gQXMgYSBzcGVjaWFsIGNhc2UsIGFuXG4vLyBMcnVTZXQgd2l0aCB6ZXJvIGNhcGFjaXR5IGFsd2F5cyByZWplY3RzIHRoZSBpbnNlcnRpb24gb2YgYW4gZWxlbWVudC5cbi8vXG4vLyBFbGVtZW50cyBtdXN0IGltcGxlbWVudCBoYXNoKCkgYW5kIGVxdWFscygpLiBOb3RlIHRoYXQgdGhlIGltcGxlbWVudGF0aW9uXG4vLyBkb2Vzbid0IGN1cnJlbnRseSB1c2UgaGFzaCgpLCBidXQgYSBmdXR1cmUgdmVyc2lvbiBtaWdodC5cbmZ1bmN0aW9uIExydVNldChjYXBhY2l0eSkge1xuICBpZiAoIWlzRmluaXRlKGNhcGFjaXR5KSB8fCBNYXRoLmZsb29yKGNhcGFjaXR5KSAhPT0gY2FwYWNpdHkgfHwgY2FwYWNpdHkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMcnVTZXQ6IGludmFsaWQgY2FwYWNpdHknKTtcbiAgfVxuICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuXG4gIC8vIEVsZW1lbnRzIGFyZSBzdG9yZWQgaW4gYSBjaXJjdWxhciBhcnJheSBvcmRlcmVkIGJ5IGRlY3JlYXNpbmcgYWdlLlxuICAvLyBTdGFydCBpcyB0aGUgaW5kZXggb2YgdGhlIG9sZGVzdCBlbGVtZW50IGFuZCBzaXplIGlzIHRoZSBudW1iZXIgb2YgdmFsaWRcbiAgLy8gZWxlbWVudHM7IHRoZSByZWdpb24gY29udGFpbmluZyB2YWxpZCBlbGVtZW50cyBtYXkgd3JhcCBhcm91bmQuXG4gIHRoaXMuX2VsZW1lbnRzID0gbmV3IEFycmF5KHRoaXMuX2NhcGFjaXR5KTtcbiAgdGhpcy5fc3RhcnQgPSAwO1xuICB0aGlzLl9zaXplID0gMDtcbn1cblxuTHJ1U2V0LnByb3RvdHlwZS5faW5kZXggPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiBtb2QodGhpcy5fc3RhcnQgKyBpLCB0aGlzLl9jYXBhY2l0eSk7XG59O1xuXG4vLyBBZGRzIGFuIGVsZW1lbnQgaW50byB0aGUgc2V0LCBwb3NzaWJseSByZXBsYWNpbmcgYW4gZXF1YWwgZWxlbWVudCBhbHJlYWR5IGluXG4vLyB0aGUgc2V0LiBUaGUgZWxlbWVudCBiZWNvbWVzIHRoZSBuZXdlc3QuIElmIHRoZSBzZXQgaXMgYXQgY2FwYWNpdHksIHRoZVxuLy8gb2xkZXN0IGVsZW1lbnQgaXMgcmVtb3ZlZC4gUmV0dXJucyB0aGUgcmVtb3ZlZCBlbGVtZW50IGlmIGl0IGRvZXMgbm90IGVxdWFsXG4vLyB0aGUgaW5zZXJ0ZWQgZWxlbWVudCwgb3IgbnVsbCBvdGhlcndpc2UuIElmIHRoZSBjYXBhY2l0eSBpcyB6ZXJvLCBkb2VzXG4vLyBub3RoaW5nIGFuZCByZXR1cm5zIHRoZSBlbGVtZW50LlxuTHJ1U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGlmICh0aGlzLl9jYXBhY2l0eSA9PT0gMCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHRoaXMucmVtb3ZlKGVsZW1lbnQpO1xuICB2YXIgZXZpY3RlZEVsZW1lbnQgPVxuICAgICAgdGhpcy5fc2l6ZSA9PT0gdGhpcy5fY2FwYWNpdHkgPyB0aGlzLl9lbGVtZW50c1t0aGlzLl9pbmRleCgwKV0gOiBudWxsO1xuICB0aGlzLl9lbGVtZW50c1t0aGlzLl9pbmRleCh0aGlzLl9zaXplKV0gPSBlbGVtZW50O1xuICBpZiAodGhpcy5fc2l6ZSA8IHRoaXMuX2NhcGFjaXR5KSB7XG4gICAgdGhpcy5fc2l6ZSsrO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3N0YXJ0ID0gdGhpcy5faW5kZXgoMSk7XG4gIH1cbiAgcmV0dXJuIGV2aWN0ZWRFbGVtZW50O1xufTtcblxuLy8gUmVtb3ZlcyBhbiBlbGVtZW50IGZyb20gdGhlIHNldC5cbi8vIFJldHVybnMgdGhlIHJlbW92ZWQgZWxlbWVudCwgb3IgbnVsbCBpZiB0aGUgZWxlbWVudCB3YXMgbm90IGZvdW5kLlxuTHJ1U2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XG4gICAgdmFyIGV4aXN0aW5nRWxlbWVudCA9IHRoaXMuX2VsZW1lbnRzW3RoaXMuX2luZGV4KGkpXTtcbiAgICBpZiAoZWxlbWVudC5lcXVhbHMoZXhpc3RpbmdFbGVtZW50KSkge1xuICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCB0aGlzLl9zaXplIC0gMTsgaisrKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzW3RoaXMuX2luZGV4KGopXSA9IHRoaXMuX2VsZW1lbnRzW3RoaXMuX2luZGV4KGogKyAxKV07XG4gICAgICB9XG4gICAgICB0aGlzLl9zaXplLS07XG4gICAgICByZXR1cm4gZXhpc3RpbmdFbGVtZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIFJldHVybnMgd2hldGhlciBhbiBlbGVtZW50IGlzIGluIHRoZSBzZXQuXG5McnVTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcbiAgICBpZiAoZWxlbWVudC5lcXVhbHModGhpcy5fZWxlbWVudHNbdGhpcy5faW5kZXgoaSldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgc2V0LlxuTHJ1U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zaXplO1xufTtcblxuLy8gUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSB0aGUgc2V0LlxuTHJ1U2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9lbGVtZW50cy5sZW5ndGggPSAwO1xuICB0aGlzLl9zdGFydCA9IDA7XG4gIHRoaXMuX3NpemUgPSAwO1xufTtcblxuLy8gQ2FsbHMgZm4oZWxlbWVudCkgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LCBpbiBhbiB1bnNwZWNpZmllZCBvcmRlci5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiB0aW1lcyBmbiB3YXMgY2FsbGVkLlxuLy8gVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiB0aGUgc2V0IGlzIG11dGF0ZWQgZHVyaW5nIGl0ZXJhdGlvbi5cbkxydVNldC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XG4gICAgZm4odGhpcy5fZWxlbWVudHNbdGhpcy5faW5kZXgoaSldKTtcbiAgICBjb3VudCArPSAxO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTHJ1U2V0O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbW9kID0gcmVxdWlyZSgnLi4vdXRpbC9tb2QnKTtcblxudmFyIGRlZmF1bHRDYXBhY2l0eSA9IDY0O1xuXG4vLyBBIG1hcCBkYXRhIHN0cnVjdHVyZSBmb3Iga2V5cyBpbXBsZW1lbnRpbmcgaGFzaCgpIGFuZCBlcXVhbHMoKSBhbmQgYXJiaXRyYXJ5XG4vLyB2YWx1ZXMuIFRoZSBjYXBhY2l0eSwgaWYgZ2l2ZW4sIGlzIGp1c3QgYSBoaW50OyB0aGUgbWFwIGlzIGFsbG93ZWQgdG8gZXhjZWVkXG4vLyBpdCwgYnV0IHBlcmZvcm1hbmNlIG1heSBzdWZmZXIuXG5mdW5jdGlvbiBNYXAoY2FwYWNpdHkpIHtcbiAgaWYgKGNhcGFjaXR5ICE9IG51bGwgJiZcbiAgICAgICghaXNGaW5pdGUoY2FwYWNpdHkpIHx8IE1hdGguZmxvb3IoY2FwYWNpdHkpICE9PSBjYXBhY2l0eSB8fCBjYXBhY2l0eSA8IDEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXA6IGludmFsaWQgY2FwYWNpdHknKTtcbiAgfVxuICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5IHx8IGRlZmF1bHRDYXBhY2l0eTtcblxuICB0aGlzLl9rZXlCdWNrZXRzID0gW107XG4gIHRoaXMuX3ZhbEJ1Y2tldHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jYXBhY2l0eTsgaSsrKSB7XG4gICAgdGhpcy5fa2V5QnVja2V0cy5wdXNoKFtdKTtcbiAgICB0aGlzLl92YWxCdWNrZXRzLnB1c2goW10pO1xuICB9XG4gIHRoaXMuX3NpemUgPSAwO1xufVxuXG4vLyBSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBrZXksIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGggPSBtb2Qoa2V5Lmhhc2goKSwgdGhpcy5fY2FwYWNpdHkpO1xuICB2YXIga2V5QnVja2V0ID0gdGhpcy5fa2V5QnVja2V0c1toXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlCdWNrZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXhpc3RpbmdLZXkgPSBrZXlCdWNrZXRbaV07XG4gICAgaWYgKGtleS5lcXVhbHMoZXhpc3RpbmdLZXkpKSB7XG4gICAgICB2YXIgdmFsQnVja2V0ID0gdGhpcy5fdmFsQnVja2V0c1toXTtcbiAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0gdmFsQnVja2V0W2ldO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gQXNzb2NpYXRlcyB0aGUgc3BlY2lmaWVkIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCBrZXksIHBvc3NpYmx5IHJlcGxhY2luZyB0aGVcbi8vIGN1cnJlbnRseSBhc3NvY2lhdGVkIHZhbHVlLlxuLy8gUmV0dXJucyB0aGUgcmVwbGFjZWQgdmFsdWUsIG9yIG51bGwgaWYgbm8gdmFsdWUgd2FzIHJlcGxhY2VkLlxuTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbCkge1xuICB2YXIgaCA9IG1vZChrZXkuaGFzaCgpLCB0aGlzLl9jYXBhY2l0eSk7XG4gIHZhciBrZXlCdWNrZXQgPSB0aGlzLl9rZXlCdWNrZXRzW2hdO1xuICB2YXIgdmFsQnVja2V0ID0gdGhpcy5fdmFsQnVja2V0c1toXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlCdWNrZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXhpc3RpbmdLZXkgPSBrZXlCdWNrZXRbaV07XG4gICAgaWYgKGtleS5lcXVhbHMoZXhpc3RpbmdLZXkpKSB7XG4gICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHZhbEJ1Y2tldFtpXTtcbiAgICAgIGtleUJ1Y2tldFtpXSA9IGtleTtcbiAgICAgIHZhbEJ1Y2tldFtpXSA9IHZhbDtcbiAgICAgIHJldHVybiBleGlzdGluZ1ZhbHVlO1xuICAgIH1cbiAgfVxuICBrZXlCdWNrZXQucHVzaChrZXkpO1xuICB2YWxCdWNrZXQucHVzaCh2YWwpO1xuICB0aGlzLl9zaXplKys7XG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gUmVtb3ZlcyB0aGUga2V5LXZhbHVlIHBhaXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LlxuLy8gUmV0dXJucyB0aGUgcmVtb3ZlZCB2YWx1ZSwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG5NYXAucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKGtleSkge1xuICB2YXIgaCA9IG1vZChrZXkuaGFzaCgpLCB0aGlzLl9jYXBhY2l0eSk7XG4gIHZhciBrZXlCdWNrZXQgPSB0aGlzLl9rZXlCdWNrZXRzW2hdO1xuICB2YXIgdmFsQnVja2V0ID0gdGhpcy5fdmFsQnVja2V0c1toXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlCdWNrZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXhpc3RpbmdLZXkgPSBrZXlCdWNrZXRbaV07XG4gICAgaWYgKGtleS5lcXVhbHMoZXhpc3RpbmdLZXkpKSB7XG4gICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHZhbEJ1Y2tldFtpXTtcbiAgICAgIC8vIFNwbGljZSBtYW51YWxseSB0byBhdm9pZCBBcnJheSNzcGxpY2UgcmV0dXJuIHZhbHVlIGFsbG9jYXRpb24uXG4gICAgICBmb3IgKHZhciBqID0gaTsgaiA8IGtleUJ1Y2tldC5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAga2V5QnVja2V0W2pdID0ga2V5QnVja2V0W2orMV07XG4gICAgICAgIHZhbEJ1Y2tldFtqXSA9IHZhbEJ1Y2tldFtqKzFdO1xuICAgICAgfVxuICAgICAga2V5QnVja2V0Lmxlbmd0aCA9IGtleUJ1Y2tldC5sZW5ndGggLSAxO1xuICAgICAgdmFsQnVja2V0Lmxlbmd0aCA9IHZhbEJ1Y2tldC5sZW5ndGggLSAxO1xuICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gUmV0dXJucyB3aGV0aGVyIHRoZXJlIGlzIGEgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LlxuTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGggPSBtb2Qoa2V5Lmhhc2goKSwgdGhpcy5fY2FwYWNpdHkpO1xuICB2YXIga2V5QnVja2V0ID0gdGhpcy5fa2V5QnVja2V0c1toXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlCdWNrZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXhpc3RpbmdLZXkgPSBrZXlCdWNrZXRbaV07XG4gICAgaWYgKGtleS5lcXVhbHMoZXhpc3RpbmdLZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGtleS12YWx1ZSBwYWlycyBpbiB0aGUgbWFwLlxuTWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zaXplO1xufTtcblxuLy8gUmVtb3ZlcyBhbGwga2V5LXZhbHVlIHBhaXJzIGZyb20gdGhlIG1hcC5cbk1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jYXBhY2l0eTsgaSsrKSB7XG4gICAgdGhpcy5fa2V5QnVja2V0c1tpXS5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3ZhbEJ1Y2tldHNbaV0ubGVuZ3RoID0gMDtcbiAgfVxuICB0aGlzLl9zaXplID0gMDtcbn07XG5cbi8vIENhbGxzIGZuKGtleSwgdmFsdWUpIGZvciBlYWNoIGtleS12YWx1ZSBwYWlyIGluIHRoZSBtYXAsIGluIGFuIHVuc3BlY2lmaWVkXG4vLyBvcmRlci4gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRpbWVzIGZuIHdhcyBjYWxsZWQuXG4vLyBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIHRoZSBtYXAgaXMgbXV0YXRlZCBkdXJpbmcgaXRlcmF0aW9uLlxuTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jYXBhY2l0eTsgaSsrKSB7XG4gICAgdmFyIGtleUJ1Y2tldCA9IHRoaXMuX2tleUJ1Y2tldHNbaV07XG4gICAgdmFyIHZhbEJ1Y2tldCA9IHRoaXMuX3ZhbEJ1Y2tldHNbaV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlCdWNrZXQubGVuZ3RoOyBqKyspIHtcbiAgICAgIGZuKGtleUJ1Y2tldFtqXSwgdmFsQnVja2V0W2pdKTtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbW9kID0gcmVxdWlyZSgnLi4vdXRpbC9tb2QnKTtcblxudmFyIGRlZmF1bHRDYXBhY2l0eSA9IDY0O1xuXG4vLyBBIHNldCBkYXRhIHN0cnVjdHVyZSBmb3IgZWxlbWVudHMgaW1wbGVtZW50aW5nIGhhc2goKSBhbmQgZXF1YWxzKCkuXG4vLyBUaGUgY2FwYWNpdHksIGlmIGdpdmVuLCBpcyBqdXN0IGEgaGludDsgdGhlIHNldCBpcyBhbGxvd2VkIHRvIGV4Y2VlZCBpdCwgYnV0XG4vLyBwZXJmb3JtYW5jZSBtYXkgc3VmZmVyLlxuZnVuY3Rpb24gU2V0KGNhcGFjaXR5KSB7XG4gIGlmIChjYXBhY2l0eSAhPSBudWxsICYmXG4gICAgICAoIWlzRmluaXRlKGNhcGFjaXR5KSB8fCBNYXRoLmZsb29yKGNhcGFjaXR5KSAhPT0gY2FwYWNpdHkgfHwgY2FwYWNpdHkgPCAxKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2V0OiBpbnZhbGlkIGNhcGFjaXR5Jyk7XG4gIH1cbiAgdGhpcy5fY2FwYWNpdHkgPSB0aGlzLl9jYXBhY2l0eSB8fCBkZWZhdWx0Q2FwYWNpdHk7XG5cbiAgdGhpcy5fYnVja2V0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NhcGFjaXR5OyBpKyspIHtcbiAgICB0aGlzLl9idWNrZXRzLnB1c2goW10pO1xuICB9XG4gIHRoaXMuX3NpemUgPSAwO1xufVxuXG4vLyBBZGRzIGFuIGVsZW1lbnQsIHJlcGxhY2luZyBhbiBleGlzdGluZyBlbGVtZW50LlxuLy8gUmV0dXJucyB0aGUgcmVwbGFjZWQgZWxlbWVudCwgb3IgbnVsbCBpZiBubyBlbGVtZW50IHdhcyByZXBsYWNlZC5cblNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB2YXIgaCA9IG1vZChlbGVtZW50Lmhhc2goKSwgdGhpcy5fY2FwYWNpdHkpO1xuICB2YXIgYnVja2V0ID0gdGhpcy5fYnVja2V0c1toXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXhpc3RpbmdFbGVtZW50ID0gYnVja2V0W2ldO1xuICAgIGlmIChlbGVtZW50LmVxdWFscyhleGlzdGluZ0VsZW1lbnQpKSB7XG4gICAgICBidWNrZXRbaV0gPSBlbGVtZW50O1xuICAgICAgcmV0dXJuIGV4aXN0aW5nRWxlbWVudDtcbiAgICB9XG4gIH1cbiAgYnVja2V0LnB1c2goZWxlbWVudCk7XG4gIHRoaXMuX3NpemUrKztcbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBSZW1vdmVzIGFuIGVsZW1lbnQuXG4vLyBSZXR1cm5zIHRoZSByZW1vdmVkIGVsZW1lbnQsIG9yIG51bGwgaWYgdGhlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZC5cblNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB2YXIgaCA9IG1vZChlbGVtZW50Lmhhc2goKSwgdGhpcy5fY2FwYWNpdHkpO1xuICB2YXIgYnVja2V0ID0gdGhpcy5fYnVja2V0c1toXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXhpc3RpbmdFbGVtZW50ID0gYnVja2V0W2ldO1xuICAgIGlmIChlbGVtZW50LmVxdWFscyhleGlzdGluZ0VsZW1lbnQpKSB7XG4gICAgICAvLyBTcGxpY2UgbWFudWFsbHkgdG8gYXZvaWQgQXJyYXkjc3BsaWNlIHJldHVybiB2YWx1ZSBhbGxvY2F0aW9uLlxuICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCBidWNrZXQubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgIGJ1Y2tldFtqXSA9IGJ1Y2tldFtqKzFdO1xuICAgICAgfVxuICAgICAgYnVja2V0Lmxlbmd0aCA9IGJ1Y2tldC5sZW5ndGggLSAxO1xuICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nRWxlbWVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBSZXR1cm5zIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBpbiB0aGUgc2V0LlxuU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBoID0gbW9kKGVsZW1lbnQuaGFzaCgpLCB0aGlzLl9jYXBhY2l0eSk7XG4gIHZhciBidWNrZXQgPSB0aGlzLl9idWNrZXRzW2hdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBleGlzdGluZ0VsZW1lbnQgPSBidWNrZXRbaV07XG4gICAgaWYgKGVsZW1lbnQuZXF1YWxzKGV4aXN0aW5nRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHNldC5cblNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc2l6ZTtcbn07XG5cbi8vIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIHNldC5cblNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jYXBhY2l0eTsgaSsrKSB7XG4gICAgdGhpcy5fYnVja2V0c1tpXS5sZW5ndGggPSAwO1xuICB9XG4gIHRoaXMuX3NpemUgPSAwO1xufTtcblxuLy8gQ2FsbHMgZm4oZWxlbWVudCkgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LCBpbiBhbiB1bnNwZWNpZmllZCBvcmRlci5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiB0aW1lcyBmbiB3YXMgY2FsbGVkLlxuLy8gVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiB0aGUgc2V0IGlzIG11dGF0ZWQgZHVyaW5nIGl0ZXJhdGlvbi5cblNldC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2FwYWNpdHk7IGkrKykge1xuICAgIHZhciBidWNrZXQgPSB0aGlzLl9idWNrZXRzW2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYnVja2V0Lmxlbmd0aDsgaisrKSB7XG4gICAgICBmbihidWNrZXRbal0pO1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBXb3JrUXVldWUgPSByZXF1aXJlKCcuL1dvcmtRdWV1ZScpO1xudmFyIG1vZCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kJyk7XG5cblxuZnVuY3Rpb24gV29ya1Bvb2wob3B0cykge1xuICB0aGlzLl9jb25jdXJyZW5jeSA9IG9wdHMgJiYgb3B0cy5jb25jdXJyZW5jeSB8fCAxO1xuICB0aGlzLl9wYXVzZWQgPSBvcHRzICYmICEhb3B0cy5wYXVzZWQgfHwgZmFsc2U7XG5cbiAgdGhpcy5fcG9vbCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NvbmN1cnJlbmN5OyBpKyspIHtcbiAgICB0aGlzLl9wb29sLnB1c2gobmV3IFdvcmtRdWV1ZShvcHRzKSk7XG4gIH1cblxuICB0aGlzLl9uZXh0ID0gMDtcbn1cblxuXG5Xb3JrUG9vbC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsZW4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Bvb2wubGVuZ3RoOyBpKyspIHtcbiAgICBsZW4gKz0gdGhpcy5fcG9vbFtpXS5sZW5ndGgoKTtcbiAgfVxuICByZXR1cm4gbGVuO1xufTtcblxuXG5Xb3JrUG9vbC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGZuLCBjYikge1xuICB2YXIgaSA9IHRoaXMuX25leHQ7XG4gIHZhciBjYW5jZWwgPSB0aGlzLl9wb29sW2ldLnB1c2goZm4sIGNiKTtcbiAgdGhpcy5fbmV4dCA9IG1vZCh0aGlzLl9uZXh0ICsgMSwgdGhpcy5fY29uY3VycmVuY3kpO1xuICByZXR1cm4gY2FuY2VsO1xufTtcblxuXG5Xb3JrUG9vbC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29uY3VycmVuY3k7IGkrKykge1xuICAgICAgdGhpcy5fcG9vbFtpXS5wYXVzZSgpO1xuICAgIH1cbiAgfVxufTtcblxuXG5Xb3JrUG9vbC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NvbmN1cnJlbmN5OyBpKyspIHtcbiAgICAgIHRoaXMuX3Bvb2xbaV0ucmVzdW1lKCk7XG4gICAgfVxuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gV29ya1Bvb2w7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBub3cgPSByZXF1aXJlKCcuLi91dGlsL25vdycpO1xuXG5cbmZ1bmN0aW9uIFdvcmtUYXNrKGZuLCBjYikge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5jZm4gPSBudWxsO1xufVxuXG5cbmZ1bmN0aW9uIFdvcmtRdWV1ZShvcHRzKSB7XG4gIHRoaXMuX3F1ZXVlID0gW107XG4gIHRoaXMuX2RlbGF5ID0gb3B0cyAmJiBvcHRzLmRlbGF5IHx8IDA7XG4gIHRoaXMuX3BhdXNlZCA9IG9wdHMgJiYgISFvcHRzLnBhdXNlZCB8fCBmYWxzZTtcbiAgdGhpcy5fY3VycmVudFRhc2sgPSBudWxsO1xuICB0aGlzLl9sYXN0RmluaXNoZWQgPSBudWxsO1xufVxuXG5cbldvcmtRdWV1ZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9xdWV1ZS5sZW5ndGg7XG59O1xuXG5cbldvcmtRdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGZuLCBjYikge1xuXG4gIHZhciB0YXNrID0gbmV3IFdvcmtUYXNrKGZuLCBjYik7XG5cbiAgdmFyIGNhbmNlbCA9IHRoaXMuX2NhbmNlbC5iaW5kKHRoaXMsIHRhc2spO1xuXG4gIC8vIFB1c2ggdGhlIHRhc2sgaW50byB0aGUgcXVldWUuXG4gIHRoaXMuX3F1ZXVlLnB1c2godGFzayk7XG5cbiAgLy8gUnVuIHRoZSB0YXNrIGlmIGlkbGUuXG4gIHRoaXMuX25leHQoKTtcblxuICByZXR1cm4gY2FuY2VsO1xuXG59O1xuXG5cbldvcmtRdWV1ZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICB9XG59O1xuXG5cbldvcmtRdWV1ZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9uZXh0KCk7XG4gIH1cbn07XG5cblxuV29ya1F1ZXVlLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbih0YXNrKSB7XG5cbiAgLy8gQ29uc2lzdGVuY3kgY2hlY2suXG4gIGlmICh0aGlzLl9jdXJyZW50VGFzaykge1xuICAgIHRocm93IG5ldyBFcnJvcignV29ya1F1ZXVlOiBjYWxsZWQgc3RhcnQgd2hpbGUgcnVubmluZyB0YXNrJyk7XG4gIH1cblxuICAvLyBNYXJrIHF1ZXVlIGFzIGJ1c3ksIHNvIHRoYXQgY29uY3VycmVudCB0YXNrcyB3YWl0LlxuICB0aGlzLl9jdXJyZW50VGFzayA9IHRhc2s7XG5cbiAgLy8gRXhlY3V0ZSB0aGUgdGFzay5cbiAgdmFyIGZpbmlzaCA9IHRoaXMuX2ZpbmlzaC5iaW5kKHRoaXMsIHRhc2spO1xuICB0YXNrLmNmbiA9IHRhc2suZm4oZmluaXNoKTtcblxuICAvLyBEZXRlY3Qgd2hlbiBhIG5vbi1jYW5jZWxsYWJsZSBmdW5jdGlvbiBoYXMgYmVlbiBxdWV1ZWQuXG4gIGlmICh0eXBlb2YgdGFzay5jZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtRdWV1ZTogZnVuY3Rpb24gaXMgbm90IGNhbmNlbGxhYmxlJyk7XG4gIH1cblxufTtcblxuXG5Xb3JrUXVldWUucHJvdG90eXBlLl9maW5pc2ggPSBmdW5jdGlvbih0YXNrKSB7XG5cbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIC8vIENvbnNpc3RlbmN5IGNoZWNrLlxuICBpZiAodGhpcy5fY3VycmVudFRhc2sgIT09IHRhc2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtRdWV1ZTogY2FsbGVkIGZpbmlzaCBvbiB3cm9uZyB0YXNrJyk7XG4gIH1cblxuICAvLyBDYWxsIHRoZSB0YXNrIGNhbGxiYWNrIG9uIHRoZSByZXR1cm4gdmFsdWVzLlxuICB0YXNrLmNiLmFwcGx5KG51bGwsIGFyZ3MpO1xuXG4gIC8vIE1hcmsgYXMgbm90IGJ1c3kgYW5kIHJlY29yZCB0YXNrIGZpbmlzaCB0aW1lLCB0aGVuIGFkdmFuY2UgdG8gbmV4dCB0YXNrLlxuICB0aGlzLl9jdXJyZW50VGFzayA9IG51bGw7XG4gIHRoaXMuX2xhc3RGaW5pc2hlZCA9IG5vdygpO1xuICB0aGlzLl9uZXh0KCk7XG5cbn07XG5cblxuV29ya1F1ZXVlLnByb3RvdHlwZS5fY2FuY2VsID0gZnVuY3Rpb24odGFzaykge1xuXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpZiAodGhpcy5fY3VycmVudFRhc2sgPT09IHRhc2spIHtcblxuICAgIC8vIENhbmNlbCBydW5uaW5nIHRhc2suIEJlY2F1c2UgY2FuY2VsIHBhc3NlcyBjb250cm9sIHRvIHRoZSBfZmluaXNoXG4gICAgLy8gY2FsbGJhY2sgd2UgcGFzc2VkIGludG8gZm4sIHRoZSBjbGVhbnVwIGxvZ2ljIHdpbGwgYmUgaGFuZGxlZCB0aGVyZS5cbiAgICB0YXNrLmNmbi5hcHBseShudWxsLCBhcmdzKTtcblxuICB9IGVsc2Uge1xuXG4gICAgLy8gUmVtb3ZlIHRhc2sgZnJvbSBxdWV1ZS5cbiAgICB2YXIgcG9zID0gdGhpcy5fcXVldWUuaW5kZXhPZih0YXNrKTtcbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIHRoaXMuX3F1ZXVlLnNwbGljZShwb3MsIDEpO1xuICAgICAgdGFzay5jYi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG5cbiAgfVxuXG59O1xuXG5cbldvcmtRdWV1ZS5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgLy8gRG8gbm90IHN0YXJ0IHRhc2tzIHdoaWxlIHBhdXNlZC5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgIC8vIE5vIHRhc2tzIHRvIHJ1bi5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5fY3VycmVudFRhc2spIHtcbiAgICAvLyBXaWxsIGJlIGNhbGxlZCBhZ2FpbiB3aGVuIHRoZSBjdXJyZW50IHRhc2sgZmluaXNoZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX2xhc3RGaW5pc2hlZCAhPSBudWxsKSB7XG4gICAgdmFyIGVsYXBzZWQgPSBub3coKSAtIHRoaXMuX2xhc3RGaW5pc2hlZDtcbiAgICB2YXIgcmVtYWluaW5nID0gdGhpcy5fZGVsYXkgLSBlbGFwc2VkO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAvLyBUb28gc29vbi4gUnVuIGFnYWluIGFmdGVyIHRoZSBpbnRlci10YXNrIGRlbGF5LlxuICAgICAgc2V0VGltZW91dCh0aGlzLl9uZXh0LmJpbmQodGhpcyksIHJlbWFpbmluZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gUnVuIHRoZSBuZXh0IHRhc2suXG4gIHZhciB0YXNrID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgdGhpcy5fc3RhcnQodGFzayk7XG5cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBXb3JrUXVldWU7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB2ZWM0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjNDtcbnZhciBtYXQ0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0NDtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBjb2xvciB0cmFuc2Zvcm1hdGlvbiB7QGxpbmsgRWZmZWN0c30uXG4gKlxuICogUmVmZXJlbmNlczpcbiAqXG4gKiAgIC0gW0NvbG9yTWF0cml4IEd1aWRlXShodHRwOi8vZG9jcy5yYWlubWV0ZXIubmV0L3RpcHMvY29sb3JtYXRyaXgtZ3VpZGUpXG4gKiAgIC0gW01hdHJpeCBPcGVyYXRpb25zIGZvciBJbWFnZSBQcm9jZXNzaW5nXShodHRwOi8vd3d3LmdyYWZpY2FvYnNjdXJhLmNvbS9tYXRyaXgvaW5kZXguaHRtbClcbiAqICAgLSBbV2ViR0xJbWFnZUZpbHRlcl0oaHR0cHM6Ly9naXRodWIuY29tL3Bob2Jvc2xhYi9XZWJHTEltYWdlRmlsdGVyKVxuICogICAtIFtnbGZ4LmpzXShodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZ2xmeC5qcylcbiAqXG4gKiBAbmFtZXNwYWNlIGNvbG9yRWZmZWN0c1xuICovXG5cbi8qKlxuICogQSB2ZWN0b3IgYW5kIG1hdHJpeCBjb3JyZXNwb25kaW5nIHRvIGFuIGlkZW50aXR5IHRyYW5zZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHQgT2JqZWN0IHRvIHN0b3JlIHJlc3VsdFxuICogQHBhcmFtIHt2ZWM0fSByZXN1bHQuY29sb3JPZmZzZXQgQXJyYXkgd2l0aCB6ZXJvZXMuXG4gKiBAcGFyYW0ge21hdDR9IHJlc3VsdC5jb2xvck1hdHJpeCBJZGVudGl0eSBtYXRyaXguXG4gKlxuICogQG1lbWJlcm9mIGNvbG9yRWZmZWN0c1xuICovXG5mdW5jdGlvbiBpZGVudGl0eShyZXN1bHRBcmcpIHtcbiAgdmFyIHJlc3VsdCA9IHJlc3VsdEFyZyB8fCB7fTtcbiAgcmVzdWx0LmNvbG9yT2Zmc2V0ID0gcmVzdWx0LmNvbG9yT2Zmc2V0IHx8IHZlYzQuY3JlYXRlKCk7XG4gIHJlc3VsdC5jb2xvck1hdHJpeCA9IHJlc3VsdC5jb2xvck1hdHJpeCB8fCBtYXQ0LmNyZWF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGx5IGNvbG9yIGVmZmVjdHMgdG8gYSBzaW5nbGUgcGl4ZWxcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IHBpeGVsIFZhbHVlcyBpbiByYW5nZSBbMCwxXVxuICogQHBhcmFtIHtPYmplY3R9IGVmZmVjdFxuICogQHBhcmFtIHt2ZWM0fSBlZmZlY3QuY29sb3JPZmZzZXRcbiAqIEBwYXJhbSB7bWF0NH0gZWZmZWN0LmNvbG9yTWF0cml4XG4gKiBAcGFyYW0ge3ZlYzR9IHJlc3VsdCBPYmplY3QgdG8gc3RvcmUgcmVzdWx0XG4gKlxuICogQG1lbWJlcm9mIGNvbG9yRWZmZWN0c1xuICovXG5mdW5jdGlvbiBhcHBseVRvUGl4ZWwocGl4ZWwsIGVmZmVjdCwgcmVzdWx0KSB7XG4gIHZlYzRUcmFuc2Zvcm1NYXQ0VHJhbnNwb3NlZChyZXN1bHQsIHBpeGVsLCBlZmZlY3QuY29sb3JNYXRyaXgpO1xuICB2ZWM0LmFkZChyZXN1bHQsIHJlc3VsdCwgZWZmZWN0LmNvbG9yT2Zmc2V0KTtcbn1cblxuLy8gT2RkbHksIHRoZSBjb2xvclRyYW5zZm9ybSBtYXRyaXggbmVlZHMgdG8gYmUgdHJhbnNwb3NlZCB0byBiZSB1c2VkIHdpdGhcbi8vIHZlYzQudHJhbnNmb3JtTWF0NC4gSXQgaXMgc3RyYW5nZSB0aGF0IHRyYW5zZm9ybU1hdDQgZG9zbid0IHdvcmsgdGhlIHNhbWVcbi8vIHdheSBhcyBtdWx0aXBseWluZyBvbiB0aGUgc2hhZGVyLlxuLy8gVE9ETzogaW52ZXN0aWdhdGUgdGhpcyBmdXJ0aGVyXG5mdW5jdGlvbiB2ZWM0VHJhbnNmb3JtTWF0NFRyYW5zcG9zZWQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLCB3ID0gYVszXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzFdICogeSArIG1bMl0gKiB6ICsgbVszXSAqIHc7XG4gIG91dFsxXSA9IG1bNF0gKiB4ICsgbVs1XSAqIHkgKyBtWzZdICogeiArIG1bN10gKiB3O1xuICBvdXRbMl0gPSBtWzhdICogeCArIG1bOV0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxMV0gKiB3O1xuICBvdXRbM10gPSBtWzEyXSAqIHggKyBtWzEzXSAqIHkgKyBtWzE0XSAqIHogKyBtWzE1XSAqIHc7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQXBwbHkgY29sb3IgZWZmZWN0cyB0byBhbiBJbWFnZURhdGFcbiAqXG4gKiBAcGFyYW0ge0ltYWdlRGF0YX0gaW1hZ2VEYXRhIFRoaXMgb2JqZWN0IHdpbGwgYmUgbXV0YXRlZFxuICogQHBhcmFtIHtPYmplY3R9IGVmZmVjdFxuICogQHBhcmFtIHt2ZWM0fSBlZmZlY3QuY29sb3JPZmZzZXRcbiAqIEBwYXJhbSB7bWF0NH0gZWZmZWN0LmNvbG9yTWF0cml4XG4gKlxuICogQG1lbWJlcm9mIGNvbG9yRWZmZWN0c1xuICovXG52YXIgdG1wUGl4ZWwgPSB2ZWM0LmNyZWF0ZSgpO1xuZnVuY3Rpb24gYXBwbHlUb0ltYWdlRGF0YShpbWFnZURhdGEsIGVmZmVjdCkge1xuICB2YXIgd2lkdGggPSBpbWFnZURhdGEud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0O1xuICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB3aWR0aCAqIGhlaWdodDsgaSsrKSB7XG4gICAgdmVjNC5zZXQodG1wUGl4ZWwsIGRhdGFbaSo0KzBdLzI1NSwgZGF0YVtpKjQrMV0vMjU1LCBkYXRhW2kqNCsyXS8yNTUsIGRhdGFbaSo0KzNdLzI1NSk7XG4gICAgYXBwbHlUb1BpeGVsKHRtcFBpeGVsLCBlZmZlY3QsIHRtcFBpeGVsKTtcbiAgICBkYXRhW2kqNCswXSA9IHRtcFBpeGVsWzBdKjI1NTtcbiAgICBkYXRhW2kqNCsxXSA9IHRtcFBpeGVsWzFdKjI1NTtcbiAgICBkYXRhW2kqNCsyXSA9IHRtcFBpeGVsWzJdKjI1NTtcbiAgICBkYXRhW2kqNCszXSA9IHRtcFBpeGVsWzNdKjI1NTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaWRlbnRpdHk6IGlkZW50aXR5LFxuICBhcHBseVRvUGl4ZWw6IGFwcGx5VG9QaXhlbCxcbiAgYXBwbHlUb0ltYWdlRGF0YTogYXBwbHlUb0ltYWdlRGF0YVxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIER5bmFtaWNzID0gcmVxdWlyZSgnLi9EeW5hbWljcycpO1xudmFyIG5vdyA9IHJlcXVpcmUoJy4uL3V0aWwvbm93Jyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3MgQ29udHJvbENvbXBvc2VyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQ29tYmluZXMgY2hhbmdlcyBpbiBwYXJhbWV0ZXJzIHRyaWdnZXJlZCBieSBtdWx0aXBsZSB7QGxpbmsgQ29udHJvbE1ldGhvZH1cbiAqIGluc3RhbmNlcy5cbiAqXG4gKiBAbGlzdGVucyBDb250cm9sTWV0aG9kI3BhcmFtZXRlckR5bmFtaWNzXG4gKi9cbmZ1bmN0aW9uIENvbnRyb2xDb21wb3NlcihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHRoaXMuX21ldGhvZHMgPSBbXTtcblxuICB0aGlzLl9wYXJhbWV0ZXJzID0gWyAneCcgLCd5JywgJ2F4aXNTY2FsZWRYJywgJ2F4aXNTY2FsZWRZJywgJ3pvb20nLCAneWF3JywgJ3BpdGNoJywgJ3JvbGwnIF07XG5cbiAgdGhpcy5fbm93ID0gb3B0cy5ub3dGb3JUZXN0aW5nIHx8IG5vdztcblxuICB0aGlzLl9jb21wb3NlZE9mZnNldHMgPSB7IH07XG5cbiAgdGhpcy5fY29tcG9zZVJldHVybiA9IHsgb2Zmc2V0czogdGhpcy5fY29tcG9zZWRPZmZzZXRzLCBjaGFuZ2luZzogbnVsbCB9O1xufVxuXG5ldmVudEVtaXR0ZXIoQ29udHJvbENvbXBvc2VyKTtcblxuXG5Db250cm9sQ29tcG9zZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGlmICh0aGlzLmhhcyhpbnN0YW5jZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZHluYW1pY3MgPSB7fTtcbiAgdGhpcy5fcGFyYW1ldGVycy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtZXRlcikge1xuICAgIGR5bmFtaWNzW3BhcmFtZXRlcl0gPSB7XG4gICAgICBkeW5hbWljczogbmV3IER5bmFtaWNzKCksXG4gICAgICB0aW1lOiBudWxsXG4gICAgfTtcbiAgfSk7XG5cbiAgdmFyIHBhcmFtZXRlckR5bmFtaWNzSGFuZGxlciA9IHRoaXMuX3VwZGF0ZUR5bmFtaWNzLmJpbmQodGhpcywgZHluYW1pY3MpO1xuXG4gIHZhciBtZXRob2QgPSB7XG4gICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgIGR5bmFtaWNzOiBkeW5hbWljcyxcbiAgICBwYXJhbWV0ZXJEeW5hbWljc0hhbmRsZXI6IHBhcmFtZXRlckR5bmFtaWNzSGFuZGxlclxuICB9O1xuXG4gIGluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3BhcmFtZXRlckR5bmFtaWNzJywgcGFyYW1ldGVyRHluYW1pY3NIYW5kbGVyKTtcblxuICB0aGlzLl9tZXRob2RzLnB1c2gobWV0aG9kKTtcbn07XG5cblxuQ29udHJvbENvbXBvc2VyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpbnN0YW5jZSkge1xuICB2YXIgaW5kZXggPSB0aGlzLl9pbmRleE9mSW5zdGFuY2UoaW5zdGFuY2UpO1xuICBpZiAoaW5kZXggPj0gMCkge1xuICAgIHZhciBtZXRob2QgPSB0aGlzLl9tZXRob2RzLnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgbWV0aG9kLmluc3RhbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhcmFtZXRlckR5bmFtaWNzJywgbWV0aG9kLnBhcmFtZXRlckR5bmFtaWNzSGFuZGxlcik7XG4gIH1cbn07XG5cblxuQ29udHJvbENvbXBvc2VyLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihpbnN0YW5jZSkge1xuICByZXR1cm4gdGhpcy5faW5kZXhPZkluc3RhbmNlKGluc3RhbmNlKSA+PSAwO1xufTtcblxuXG5Db250cm9sQ29tcG9zZXIucHJvdG90eXBlLl9pbmRleE9mSW5zdGFuY2UgPSBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5fbWV0aG9kc1tpXS5pbnN0YW5jZSA9PT0gaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbkNvbnRyb2xDb21wb3Nlci5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5zdGFuY2VzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RhbmNlcy5wdXNoKHRoaXMuX21ldGhvZHNbaV0uaW5zdGFuY2UpO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZXM7XG59O1xuXG5cbkNvbnRyb2xDb21wb3Nlci5wcm90b3R5cGUuX3VwZGF0ZUR5bmFtaWNzID0gZnVuY3Rpb24oc3RvcmVkRHluYW1pY3MsIHBhcmFtZXRlciwgZHluYW1pY3MpIHtcbiAgdmFyIHBhcmFtZXRlckR5bmFtaWNzID0gc3RvcmVkRHluYW1pY3NbcGFyYW1ldGVyXTtcblxuICBpZiAoIXBhcmFtZXRlckR5bmFtaWNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb250cm9sIHBhcmFtZXRlciBcIiArIHBhcmFtZXRlcik7XG4gIH1cblxuICB2YXIgbmV3VGltZSA9IHRoaXMuX25vdygpO1xuICBwYXJhbWV0ZXJEeW5hbWljcy5keW5hbWljcy51cGRhdGUoZHluYW1pY3MsIChuZXdUaW1lIC0gcGFyYW1ldGVyRHluYW1pY3MudGltZSkvMTAwMCk7XG4gIHBhcmFtZXRlckR5bmFtaWNzLnRpbWUgPSBuZXdUaW1lO1xuXG4gIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG59O1xuXG5cbkNvbnRyb2xDb21wb3Nlci5wcm90b3R5cGUuX3Jlc2V0Q29tcG9zZWRPZmZzZXRzID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2NvbXBvc2VkT2Zmc2V0c1t0aGlzLl9wYXJhbWV0ZXJzW2ldXSA9IDA7XG4gIH1cbn07XG5cblxuQ29udHJvbENvbXBvc2VyLnByb3RvdHlwZS5vZmZzZXRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXJhbWV0ZXI7XG4gIHZhciBjaGFuZ2luZyA9IGZhbHNlO1xuXG4gIHZhciBjdXJyZW50VGltZSA9IHRoaXMuX25vdygpO1xuXG4gIHRoaXMuX3Jlc2V0Q29tcG9zZWRPZmZzZXRzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9tZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1ldGhvZER5bmFtaWNzID0gdGhpcy5fbWV0aG9kc1tpXS5keW5hbWljcztcblxuICAgIGZvciAodmFyIHAgPSAwOyBwIDwgdGhpcy5fcGFyYW1ldGVycy5sZW5ndGg7IHArKykge1xuICAgICAgcGFyYW1ldGVyID0gdGhpcy5fcGFyYW1ldGVyc1twXTtcbiAgICAgIHZhciBwYXJhbWV0ZXJEeW5hbWljcyA9IG1ldGhvZER5bmFtaWNzW3BhcmFtZXRlcl07XG4gICAgICB2YXIgZHluYW1pY3MgPSBwYXJhbWV0ZXJEeW5hbWljcy5keW5hbWljcztcblxuXG4gICAgICAvLyBBZGQgb2Zmc2V0IHRvIGNvbXBvc2VkIG9mZnNldFxuICAgICAgaWYgKGR5bmFtaWNzLm9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvc2VkT2Zmc2V0c1twYXJhbWV0ZXJdICs9IGR5bmFtaWNzLm9mZnNldDtcbiAgICAgICAgLy8gUmVzZXQgb2Zmc2V0XG4gICAgICAgIGR5bmFtaWNzLm9mZnNldCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBvZmZzZXQgZnJvbSB2ZWxvY2l0eSBhbmQgYWRkIGl0XG4gICAgICB2YXIgZWxhcHNlZCA9IChjdXJyZW50VGltZSAtIHBhcmFtZXRlckR5bmFtaWNzLnRpbWUpLzEwMDA7XG4gICAgICB2YXIgb2Zmc2V0RnJvbVZlbG9jaXR5ID0gZHluYW1pY3Mub2Zmc2V0RnJvbVZlbG9jaXR5KGVsYXBzZWQpO1xuXG4gICAgICBpZihvZmZzZXRGcm9tVmVsb2NpdHkpIHtcbiAgICAgICAgdGhpcy5fY29tcG9zZWRPZmZzZXRzW3BhcmFtZXRlcl0gKz0gb2Zmc2V0RnJvbVZlbG9jaXR5O1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdmVsb2NpdHkgb24gZHluYW1pY3NcbiAgICAgIHZhciBjdXJyZW50VmVsb2NpdHkgPSBkeW5hbWljcy52ZWxvY2l0eUFmdGVyKGVsYXBzZWQpO1xuICAgICAgZHluYW1pY3MudmVsb2NpdHkgPSBjdXJyZW50VmVsb2NpdHk7XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIHN0aWxsIGEgdmVsb2NpdHksIHNldCBjaGFuZ2luZ1xuICAgICAgaWYoY3VycmVudFZlbG9jaXR5KSB7XG4gICAgICAgIGNoYW5naW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcGFyYW1ldGVyRHluYW1pY3MudGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2NvbXBvc2VSZXR1cm4uY2hhbmdpbmcgPSBjaGFuZ2luZztcbiAgcmV0dXJuIHRoaXMuX2NvbXBvc2VSZXR1cm47XG59O1xuXG5cbkNvbnRyb2xDb21wb3Nlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5zdGFuY2VzID0gdGhpcy5saXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5yZW1vdmUoaW5zdGFuY2VzW2ldKTtcbiAgfVxuXG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDb250cm9sQ29tcG9zZXI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVmYXVsdHMnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG52YXIgZGVmYXVsdE9wdHMgPSB7XG4gIGFjdGl2ZTogJ21vdmUnLFxuICBpbmFjdGl2ZTogJ2RlZmF1bHQnLFxuICBkaXNhYmxlZDogJ2RlZmF1bHQnXG59O1xuXG4vKipcbiAqIEBjbGFzcyBDb250cm9sQ3Vyc29yXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogU2V0cyB0aGUgQ1NTIGN1cnNvciBvbiBhIERPTSBlbGVtZW50IGFjY29yZGluZyB0byB0aGUgc3RhdGUgb2YgYVxuICoge0BsaW5rIENvbnRyb2xNZXRob2R9LlxuICpcbiAqIEBwYXJhbSB7Q29udHJvbHN9IGNvbnRyb2xzIENvbnRyb2xzIGluc3RhbmNlIGNvbnRhaW5pbmcgdGhlIGNvbnRyb2wgbWV0aG9kLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBjb250cm9sIG1ldGhvZC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBET00gZWxlbWVudCB3aGVyZSB0aGUgY3Vyc29yIHNob3VsZCBiZSBzZXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgY29udHJvbCBjdXJzb3JzLiBFYWNoIGZpZWxkIG11c3QgYmUgYSB2YWxpZCB2YWx1ZVxuICogICAgIGZvciB0aGUgYGN1cnNvcmAgQ1NTIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmFjdGl2ZT0nbW92ZSddIEN1cnNvciB0byBzZXQgd2hlbiB0aGUgY29udHJvbCBtZXRob2RcbiAqICAgICBpcyBlbmFibGVkIGFuZCBhY3RpdmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaW5hY3RpdmU9J2RlZmF1bHQnXSBDdXJzb3IgdG8gc2V0IHdoZW4gdGhlIGNvbnRyb2xcbiAqICAgICBtZXRob2QgaXMgZW5hYmxlZCBhbmQgaW5hY3RpdmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZGlzYWJsZWQ9J2RlZmF1bHQnXSBDdXJzb3IgdG8gc2V0IHdoZW4gdGhlIGNvbnRyb2xcbiAqICAgICBtZXRob2QgaXMgZGlzYWJsZWQuXG4gKi9cbmZ1bmN0aW9uIENvbnRyb2xDdXJzb3IoY29udHJvbHMsIGlkLCBlbGVtZW50LCBvcHRzKSB7XG4gIG9wdHMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCBkZWZhdWx0T3B0cyk7XG5cbiAgLy8gVE9ETzogVGhpcyBjbGFzcyBtYXkgbWlzYmVoYXZlIGlmIHRoZSBjb250cm9sIG1ldGhvZCBpcyB1bnJlZ2lzdGVyZWQgYW5kIGFcbiAgLy8gZGlmZmVyZW50IGNvbnRyb2wgbWV0aG9kIGlzIHJlZ2lzdGVyZWQgdW5kZXIgdGhlIHNhbWUgaWQuXG5cbiAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuX2NvbnRyb2xzID0gY29udHJvbHM7XG4gIHRoaXMuX2lkID0gaWQ7XG5cbiAgdGhpcy5fYXR0YWNoZWQgPSBmYWxzZTtcblxuICB0aGlzLl9zZXRBY3RpdmVDdXJzb3IgPSB0aGlzLl9zZXRDdXJzb3IuYmluZCh0aGlzLCBvcHRzLmFjdGl2ZSk7XG4gIHRoaXMuX3NldEluYWN0aXZlQ3Vyc29yID0gdGhpcy5fc2V0Q3Vyc29yLmJpbmQodGhpcywgb3B0cy5pbmFjdGl2ZSk7XG4gIHRoaXMuX3NldERpc2FibGVkQ3Vyc29yID0gdGhpcy5fc2V0Q3Vyc29yLmJpbmQodGhpcywgb3B0cy5kaXNhYmxlZCk7XG4gIHRoaXMuX3NldE9yaWdpbmFsQ3Vyc29yID0gdGhpcy5fc2V0Q3Vyc29yLmJpbmQodGhpcywgdGhpcy5fZWxlbWVudC5zdHlsZS5jdXJzb3IpO1xuXG4gIHRoaXMuX3VwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyID0gdGhpcy5fdXBkYXRlQXR0YWNobWVudC5iaW5kKHRoaXMpO1xuXG4gIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ21ldGhvZEVuYWJsZWQnLCB0aGlzLl91cGRhdGVBdHRhY2htZW50SGFuZGxlcik7XG4gIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ21ldGhvZERpc2FibGVkJywgdGhpcy5fdXBkYXRlQXR0YWNobWVudEhhbmRsZXIpO1xuICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdlbmFibGVkJywgdGhpcy5fdXBkYXRlQXR0YWNobWVudEhhbmRsZXIpO1xuICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdkaXNhYmxlZCcsIHRoaXMuX3VwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyKTtcblxuICB0aGlzLl91cGRhdGVBdHRhY2htZW50KCk7XG59XG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuQ29udHJvbEN1cnNvci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9kZXRhY2hGcm9tQ29udHJvbE1ldGhvZCh0aGlzLl9jb250cm9scy5tZXRob2QodGhpcy5faWQpKTtcbiAgdGhpcy5fc2V0T3JpZ2luYWxDdXJzb3IoKTtcblxuICB0aGlzLl9jb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXRob2RFbmFibGVkJyxcbiAgICAgIHRoaXMuX3VwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyKTtcbiAgdGhpcy5fY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWV0aG9kRGlzYWJsZWQnLFxuICAgICAgdGhpcy5fdXBkYXRlQXR0YWNobWVudEhhbmRsZXIpO1xuICB0aGlzLl9jb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmFibGVkJyxcbiAgICAgIHRoaXMuX3VwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyKTtcbiAgdGhpcy5fY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzYWJsZWQnLFxuICAgICAgdGhpcy5fdXBkYXRlQXR0YWNobWVudEhhbmRsZXIpO1xuXG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cbkNvbnRyb2xDdXJzb3IucHJvdG90eXBlLl91cGRhdGVBdHRhY2htZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb250cm9scyA9IHRoaXMuX2NvbnRyb2xzO1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcbiAgaWYgKGNvbnRyb2xzLmVuYWJsZWQoKSAmJiBjb250cm9scy5tZXRob2QoaWQpLmVuYWJsZWQpIHtcbiAgICB0aGlzLl9hdHRhY2hUb0NvbnRyb2xNZXRob2QoY29udHJvbHMubWV0aG9kKGlkKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZGV0YWNoRnJvbUNvbnRyb2xNZXRob2QoY29udHJvbHMubWV0aG9kKGlkKSk7XG4gIH1cbn07XG5cbkNvbnRyb2xDdXJzb3IucHJvdG90eXBlLl9hdHRhY2hUb0NvbnRyb2xNZXRob2QgPSBmdW5jdGlvbihjb250cm9sTWV0aG9kKSB7XG4gIGlmICghdGhpcy5fYXR0YWNoZWQpIHtcbiAgICBjb250cm9sTWV0aG9kLmluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2FjdGl2ZScsIHRoaXMuX3NldEFjdGl2ZUN1cnNvcik7XG4gICAgY29udHJvbE1ldGhvZC5pbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKCdpbmFjdGl2ZScsIHRoaXMuX3NldEluYWN0aXZlQ3Vyc29yKTtcblxuICAgIGlmIChjb250cm9sTWV0aG9kLmFjdGl2ZSkge1xuICAgICAgdGhpcy5fc2V0QWN0aXZlQ3Vyc29yKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldEluYWN0aXZlQ3Vyc29yKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYXR0YWNoZWQgPSB0cnVlO1xuICB9XG59O1xuXG5Db250cm9sQ3Vyc29yLnByb3RvdHlwZS5fZGV0YWNoRnJvbUNvbnRyb2xNZXRob2QgPSBmdW5jdGlvbihjb250cm9sTWV0aG9kKSB7XG4gIGlmICh0aGlzLl9hdHRhY2hlZCkge1xuICAgIGNvbnRyb2xNZXRob2QuaW5zdGFuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWN0aXZlJywgdGhpcy5fc2V0QWN0aXZlQ3Vyc29yKTtcbiAgICBjb250cm9sTWV0aG9kLmluc3RhbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2luYWN0aXZlJywgdGhpcy5fc2V0SW5hY3RpdmVDdXJzb3IpO1xuXG4gICAgdGhpcy5fc2V0RGlzYWJsZWRDdXJzb3IoKTtcblxuICAgIHRoaXMuX2F0dGFjaGVkID0gZmFsc2U7XG4gIH1cbn07XG5cbkNvbnRyb2xDdXJzb3IucHJvdG90eXBlLl9zZXRDdXJzb3IgPSBmdW5jdGlvbihjdXJzb3IpIHtcbiAgdGhpcy5fZWxlbWVudC5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udHJvbEN1cnNvcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIENvbXBvc2VyID0gcmVxdWlyZSgnLi9Db21wb3NlcicpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBkZWJ1ZyA9IHR5cGVvZiBNQVJaSVBBTk9ERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgTUFSWklQQU5PREVCVUcuY29udHJvbHM7XG5cbi8qKlxuICogQGNsYXNzIENvbnRyb2xzXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogU2V0IG9mIGNvbnRyb2xzIHdoaWNoIGFmZmVjdCBhIHZpZXcgKGUuZy4ga2V5Ym9hcmQsIHRvdWNoKVxuICpcbiAqIHtAbGluayBDb250cm9sTWV0aG9kfSBpbnN0YW5jZXMgY2FuIGJlIHJlZ2lzdGVyZWQgb24gdGhpcyBjbGFzcy4gVGhlIG1ldGhvZHNcbiAqIGFyZSB0aGVuIGNvbWJpbmVkIHRvIGNhbGN1bGF0ZSB0aGUgZmluYWwgcGFyYW1ldGVycyB0byBjaGFuZ2UgdGhlIHtAbGluayBWaWV3fS5cbiAqXG4gKiBDb250cm9scyBpcyBhdHRhY2hlZCB0byBhIHtAbGluayBSZW5kZXJMb29wfS4gQ3VycmVudGx5IGl0IGFmZmVjdHMgdGhlXG4gKiB7QGxpbmsgdmlld30gb2YgYWxsIHtAbGluayBMYXllcn0gb24gdGhlIHtAbGluayBTdGFnZX0gb2YgdGhlXG4gKiB7QGxpbmsgUmVuZGVyTG9vcH0gaXQgaXMgYXR0YWNoZWQgdG8uIEEgbW9yZSBmbGV4aWJsZSBBUEkgbWF5IGJlIHByb3ZpZGVkXG4gKiBpbiB0aGUgZnV0dXJlLlxuICpcbiAqIFRoZSBDb250cm9sTWV0aG9kIGluc3RhbmNlcyBhcmUgcmVnaXN0ZXJlZCB3aXRoIGFuIGlkIGFuZCBtYXkgYmUgZW5hYmxlZCxcbiAqIGRpc2FibGVkIGFuZCB1bnJlZ2lzdGVyZWQgdXNpbmcgdGhhdCBpZC4gVGhlIHdob2xlIENvbnRyb2wgY2FuIGFsc28gYmVcbiAqIGVuYWJsZWQgb3IgZGlzYWJsZWQuXG4gKlxuICovXG5mdW5jdGlvbiBDb250cm9scyhvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHRoaXMuX21ldGhvZHMgPSB7fTtcbiAgdGhpcy5fbWV0aG9kR3JvdXBzID0ge307XG4gIHRoaXMuX2NvbXBvc2VyID0gbmV3IENvbXBvc2VyKCk7XG5cbiAgLy8gV2hldGhlciB0aGUgY29udHJvbHMgYXJlIGVuYWJsZWQuXG4gIHRoaXMuX2VuYWJsZWQgPSAob3B0cyAmJiBvcHRzLmVuYWJsZWQpID8gISFvcHRzLmVuYWJsZWQgOiB0cnVlO1xuXG4gIC8vIEhvdyBtYW55IGNvbnRyb2wgbWV0aG9kcyBhcmUgZW5hYmxlZCBhbmQgaW4gdGhlIGFjdGl2ZSBzdGF0ZS5cbiAgdGhpcy5fYWN0aXZlQ291bnQgPSAwO1xuXG4gIHRoaXMudXBkYXRlZFZpZXdzXyA9IFtdO1xuXG4gIHRoaXMuX2F0dGFjaGVkUmVuZGVyTG9vcCA9IG51bGw7XG59XG5cbmV2ZW50RW1pdHRlcihDb250cm9scyk7XG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kZXRhY2goKTtcbiAgdGhpcy5fY29tcG9zZXIuZGVzdHJveSgpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7Q29udHJvbE1ldGhvZFtdfSBMaXN0IG9mIHJlZ2lzdGVyZWQgQHtsaW5rIENvbnRyb2xNZXRob2QgaW5zdGFuY2VzfVxuICovXG5Db250cm9scy5wcm90b3R5cGUubWV0aG9kcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb2JqID0ge307XG4gIGZvciAodmFyIGlkIGluIHRoaXMuX21ldGhvZHMpIHtcbiAgICBvYmpbaWRdID0gdGhpcy5fbWV0aG9kc1tpZF07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtDb250cm9sTWV0aG9kfVxuICovXG5Db250cm9scy5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIHRoaXMuX21ldGhvZHNbaWRdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7Q29udHJvbE1ldGhvZH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VuYWJsZT1mYWxzZV1cbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLnJlZ2lzdGVyTWV0aG9kID0gZnVuY3Rpb24oaWQsIGluc3RhbmNlLCBlbmFibGUpIHtcbiAgaWYgKHRoaXMuX21ldGhvZHNbaWRdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb250cm9sIG1ldGhvZCBhbHJlYWR5IHJlZ2lzdGVyZWQgd2l0aCBpZCAnICsgaWQpO1xuICB9XG5cbiAgdGhpcy5fbWV0aG9kc1tpZF0gPSB7XG4gICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgYWN0aXZlSGFuZGxlcjogdGhpcy5faGFuZGxlQWN0aXZlLmJpbmQodGhpcywgaWQpLFxuICAgIGluYWN0aXZlSGFuZGxlcjogdGhpcy5faGFuZGxlSW5hY3RpdmUuYmluZCh0aGlzLCBpZClcbiAgfTtcblxuICBpZihlbmFibGUpIHtcbiAgICB0aGlzLmVuYWJsZU1ldGhvZChpZCwgaW5zdGFuY2UpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS51bnJlZ2lzdGVyTWV0aG9kID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIG1ldGhvZCA9IHRoaXMuX21ldGhvZHNbaWRdO1xuICBpZiAoIW1ldGhvZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gY29udHJvbCBtZXRob2QgcmVnaXN0ZXJlZCB3aXRoIGlkICcgKyBpZCk7XG4gIH1cbiAgaWYgKG1ldGhvZC5lbmFibGVkKSB7XG4gICAgdGhpcy5kaXNhYmxlTWV0aG9kKGlkKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fbWV0aG9kc1tpZF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICovXG5Db250cm9scy5wcm90b3R5cGUuZW5hYmxlTWV0aG9kID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIG1ldGhvZCA9IHRoaXMuX21ldGhvZHNbaWRdO1xuICBpZiAoIW1ldGhvZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gY29udHJvbCBtZXRob2QgcmVnaXN0ZXJlZCB3aXRoIGlkICcgKyBpZCk7XG4gIH1cbiAgaWYgKG1ldGhvZC5lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG1ldGhvZC5lbmFibGVkID0gdHJ1ZTtcbiAgaWYgKG1ldGhvZC5hY3RpdmUpIHtcbiAgICB0aGlzLl9pbmNyZW1lbnRBY3RpdmVDb3VudCgpO1xuICB9XG4gIHRoaXMuX2xpc3RlbihpZCk7XG4gIHRoaXMuX3VwZGF0ZUNvbXBvc2VyKCk7XG4gIHRoaXMuZW1pdCgnbWV0aG9kRW5hYmxlZCcsIGlkKTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmRpc2FibGVNZXRob2QgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgbWV0aG9kID0gdGhpcy5fbWV0aG9kc1tpZF07XG4gIGlmICghbWV0aG9kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb250cm9sIG1ldGhvZCByZWdpc3RlcmVkIHdpdGggaWQgJyArIGlkKTtcbiAgfVxuICBpZiAoIW1ldGhvZC5lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG1ldGhvZC5lbmFibGVkID0gZmFsc2U7XG4gIGlmIChtZXRob2QuYWN0aXZlKSB7XG4gICAgdGhpcy5fZGVjcmVtZW50QWN0aXZlQ291bnQoKTtcbiAgfVxuICB0aGlzLl91bmxpc3RlbihpZCk7XG4gIHRoaXMuX3VwZGF0ZUNvbXBvc2VyKCk7XG4gIHRoaXMuZW1pdCgnbWV0aG9kRGlzYWJsZWQnLCBpZCk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbWV0aG9kIGdyb3VwLCB3aGljaCBjYW4gYmUgdXNlZCB0byBtb3JlIGNvbnZlbmllbnRseSBlbmFibGUgb3JcbiAqIGRpc2FibGUgc2V2ZXJhbCBjb250cm9sIG1ldGhvZHMgYXQgb25jZVxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwSWRcbiAqIEBwYXJhbSB7U3RyaW5nW119IG1ldGhvZElkc1xuICovXG5Db250cm9scy5wcm90b3R5cGUuYWRkTWV0aG9kR3JvdXAgPSBmdW5jdGlvbihncm91cElkLCBtZXRob2RJZHMpIHtcbiAgdGhpcy5fbWV0aG9kR3JvdXBzW2dyb3VwSWRdID0gbWV0aG9kSWRzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cElkXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5yZW1vdmVNZXRob2RHcm91cCA9IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSB0aGlzLl9tZXRob2RHcm91cHNbaWRdO1xufVxuXG4vKipcbiAqIEByZXR1cm4ge0NvbnRyb2xNZXRob2RHcm91cFtdfSBMaXN0IG9mIGNvbnRyb2wgbWV0aG9kIGdyb3Vwc1xuICovXG5Db250cm9scy5wcm90b3R5cGUubWV0aG9kR3JvdXBzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbWV0aG9kR3JvdXBzKSB7XG4gICAgb2JqW2lkXSA9IHRoaXMuX21ldGhvZEdyb3Vwc1tpZF07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGFsbCB0aGUgY29udHJvbCBtZXRob2RzIGluIHRoZSBncm91cFxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwSWRcbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmVuYWJsZU1ldGhvZEdyb3VwID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLl9tZXRob2RHcm91cHNbaWRdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kSWQpIHtcbiAgICBzZWxmLmVuYWJsZU1ldGhvZChtZXRob2RJZCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIERpc2FibGVzIGFsbCB0aGUgY29udHJvbCBtZXRob2RzIGluIHRoZSBncm91cFxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwSWRcbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmRpc2FibGVNZXRob2RHcm91cCA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5fbWV0aG9kR3JvdXBzW2lkXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZElkKSB7XG4gICAgc2VsZi5kaXNhYmxlTWV0aG9kKG1ldGhvZElkKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbmFibGVkO1xufTtcblxuLyoqXG4gKiBFbmFibGVzIHRoZSBjb250cm9sc1xuICovXG5Db250cm9scy5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICBpZiAodGhpcy5fYWN0aXZlQ291bnQgPiAwKSB7XG4gICAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbiAgfVxuICB0aGlzLmVtaXQoJ2VuYWJsZWQnKTtcbiAgdGhpcy5fdXBkYXRlQ29tcG9zZXIoKTtcbn07XG5cblxuLyoqXG4gKiBEaXNhYmxlcyB0aGUgY29udHJvbHNcbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgaWYgKHRoaXMuX2FjdGl2ZUNvdW50ID4gMCkge1xuICAgIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcbiAgfVxuICB0aGlzLmVtaXQoJ2Rpc2FibGVkJyk7XG4gIHRoaXMuX3VwZGF0ZUNvbXBvc2VyKCk7XG59O1xuXG5cblxuLyoqXG4gKiBBdHRhY2hlcyB0aGUgY29udHJvbHMgdG8gYSB7QGxpbmsgUmVuZGVyTG9vcH0uIFRoZSBSZW5kZXJMb29wIHdpbGwgYmUgd29rZW5cbiAqIHVwIHdoZW4gdGhlIGNvbnRyb2xzIGFyZSBhY3RpdmF0ZWRcbiAqXG4gKiBAcGFyYW0ge1JlbmRlckxvb3B9XG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbihyZW5kZXJMb29wKSB7XG4gIGlmICh0aGlzLl9hdHRhY2hlZFJlbmRlckxvb3ApIHtcbiAgICB0aGlzLmRldGFjaCgpO1xuICB9XG5cbiAgdGhpcy5fYXR0YWNoZWRSZW5kZXJMb29wID0gcmVuZGVyTG9vcDtcbiAgdGhpcy5fYmVmb3JlUmVuZGVySGFuZGxlciA9IHRoaXMuX3VwZGF0ZVZpZXdzV2l0aENvbnRyb2xzLmJpbmQodGhpcyk7XG4gIHRoaXMuX2NoYW5nZUhhbmRsZXIgPSByZW5kZXJMb29wLnJlbmRlck9uTmV4dEZyYW1lLmJpbmQocmVuZGVyTG9vcCk7XG5cbiAgdGhpcy5fYXR0YWNoZWRSZW5kZXJMb29wLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZVJlbmRlcicsIHRoaXMuX2JlZm9yZVJlbmRlckhhbmRsZXIpO1xuICB0aGlzLl9jb21wb3Nlci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9jaGFuZ2VIYW5kbGVyKTtcbn07XG5cbi8qKlxuICogRGV0YWNoZXMgdGhlIGNvbnRyb2xzXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9hdHRhY2hlZFJlbmRlckxvb3ApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9hdHRhY2hlZFJlbmRlckxvb3AucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JlUmVuZGVyJywgdGhpcy5fYmVmb3JlUmVuZGVySGFuZGxlcik7XG4gIHRoaXMuX2NvbXBvc2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2NoYW5nZUhhbmRsZXIpO1xuXG4gIHRoaXMuX2JlZm9yZVJlbmRlckhhbmRsZXIgPSBudWxsO1xuICB0aGlzLl9jaGFuZ2VIYW5kbGVyID0gbnVsbDtcbiAgdGhpcy5fYXR0YWNoZWRSZW5kZXJMb29wID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtCb29sZWFufVxuICovXG5Db250cm9scy5wcm90b3R5cGUuYXR0YWNoZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2F0dGFjaGVkUmVuZGVyTG9vcCAhPSBudWxsO1xufTtcblxuXG5Db250cm9scy5wcm90b3R5cGUuX2xpc3RlbiA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBtZXRob2QgPSB0aGlzLl9tZXRob2RzW2lkXTtcbiAgaWYgKCFtZXRob2QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBtZXRob2QgaWQnKTtcbiAgfVxuICBtZXRob2QuaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcignYWN0aXZlJywgbWV0aG9kLmFjdGl2ZUhhbmRsZXIpO1xuICBtZXRob2QuaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcignaW5hY3RpdmUnLCBtZXRob2QuaW5hY3RpdmVIYW5kbGVyKTtcbn07XG5cblxuQ29udHJvbHMucHJvdG90eXBlLl91bmxpc3RlbiA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBtZXRob2QgPSB0aGlzLl9tZXRob2RzW2lkXTtcbiAgaWYgKCFtZXRob2QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBtZXRob2QgaWQnKTtcbiAgfVxuICBtZXRob2QuaW5zdGFuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWN0aXZlJywgbWV0aG9kLmFjdGl2ZUhhbmRsZXIpO1xuICBtZXRob2QuaW5zdGFuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5hY3RpdmUnLCBtZXRob2QuaW5hY3RpdmVIYW5kbGVyKTtcbn07XG5cblxuQ29udHJvbHMucHJvdG90eXBlLl9oYW5kbGVBY3RpdmUgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgbWV0aG9kID0gdGhpcy5fbWV0aG9kc1tpZF07XG4gIGlmICghbWV0aG9kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgbWV0aG9kIGlkJyk7XG4gIH1cbiAgaWYgKCFtZXRob2QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCByZWNlaXZlIGV2ZW50IGZyb20gZGlzYWJsZWQgY29udHJvbCBtZXRob2QnKTtcbiAgfVxuICBpZiAoIW1ldGhvZC5hY3RpdmUpIHtcbiAgICBtZXRob2QuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9pbmNyZW1lbnRBY3RpdmVDb3VudCgpO1xuICB9XG59O1xuXG5cbkNvbnRyb2xzLnByb3RvdHlwZS5faGFuZGxlSW5hY3RpdmUgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgbWV0aG9kID0gdGhpcy5fbWV0aG9kc1tpZF07XG4gIGlmICghbWV0aG9kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgbWV0aG9kIGlkJyk7XG4gIH1cbiAgaWYgKCFtZXRob2QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCByZWNlaXZlIGV2ZW50IGZyb20gZGlzYWJsZWQgY29udHJvbCBtZXRob2QnKTtcbiAgfVxuICBpZiAobWV0aG9kLmFjdGl2ZSkge1xuICAgIG1ldGhvZC5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9kZWNyZW1lbnRBY3RpdmVDb3VudCgpO1xuICB9XG59O1xuXG5cbkNvbnRyb2xzLnByb3RvdHlwZS5faW5jcmVtZW50QWN0aXZlQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fYWN0aXZlQ291bnQrKztcbiAgaWYgKGRlYnVnKSB7XG4gICAgdGhpcy5fY2hlY2tBY3RpdmVDb3VudCgpO1xuICB9XG4gIGlmICh0aGlzLl9lbmFibGVkICYmIHRoaXMuX2FjdGl2ZUNvdW50ID09PSAxKSB7XG4gICAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbiAgfVxufTtcblxuXG5Db250cm9scy5wcm90b3R5cGUuX2RlY3JlbWVudEFjdGl2ZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2FjdGl2ZUNvdW50LS07XG4gIGlmIChkZWJ1Zykge1xuICAgIHRoaXMuX2NoZWNrQWN0aXZlQ291bnQoKTtcbiAgfVxuICBpZiAodGhpcy5fZW5hYmxlZCAmJiB0aGlzLl9hY3RpdmVDb3VudCA9PT0gMCkge1xuICAgIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcbiAgfVxufTtcblxuXG5Db250cm9scy5wcm90b3R5cGUuX2NoZWNrQWN0aXZlQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbWV0aG9kcykge1xuICAgIHZhciBtZXRob2QgPSB0aGlzLl9tZXRob2RzW2lkXTtcbiAgICBpZiAobWV0aG9kLmVuYWJsZWQgJiYgbWV0aG9kLmFjdGl2ZSkge1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH1cbiAgaWYgKGNvdW50ICE9IHRoaXMuX2FjdGl2ZUNvdW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgY29udHJvbCBzdGF0ZScpO1xuICB9XG59O1xuXG5cbkNvbnRyb2xzLnByb3RvdHlwZS5fdXBkYXRlQ29tcG9zZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbXBvc2VyID0gdGhpcy5fY29tcG9zZXI7XG5cbiAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbWV0aG9kcykge1xuICAgIHZhciBtZXRob2QgPSB0aGlzLl9tZXRob2RzW2lkXTtcbiAgICB2YXIgZW5hYmxlZCA9IHRoaXMuX2VuYWJsZWQgJiYgbWV0aG9kLmVuYWJsZWQ7XG5cbiAgICBpZiAoZW5hYmxlZCAmJiAhY29tcG9zZXIuaGFzKG1ldGhvZC5pbnN0YW5jZSkpIHtcbiAgICAgIGNvbXBvc2VyLmFkZChtZXRob2QuaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAoIWVuYWJsZWQgJiYgY29tcG9zZXIuaGFzKG1ldGhvZC5pbnN0YW5jZSkpIHtcbiAgICAgIGNvbXBvc2VyLnJlbW92ZShtZXRob2QuaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxufTtcblxuXG5Db250cm9scy5wcm90b3R5cGUuX3VwZGF0ZVZpZXdzV2l0aENvbnRyb2xzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb250cm9sRGF0YSA9IHRoaXMuX2NvbXBvc2VyLm9mZnNldHMoKTtcbiAgaWYgKGNvbnRyb2xEYXRhLmNoYW5naW5nKSB7XG4gICAgdGhpcy5fYXR0YWNoZWRSZW5kZXJMb29wLnJlbmRlck9uTmV4dEZyYW1lKCk7XG4gIH1cblxuICAvLyBVcGRhdGUgZWFjaCB2aWV3IGF0IG1vc3Qgb25jZSwgZXZlbiB3aGVuIHNoYXJlZCBieSBtdWx0aXBsZSBsYXllcnMuXG4gIC8vIFRoZSBudW1iZXIgb2Ygdmlld3MgaXMgZXhwZWN0ZWQgdG8gYmUgc21hbGwsIHNvIHVzZSBhbiBhcnJheSB0byBrZWVwIHRyYWNrLlxuICB0aGlzLnVwZGF0ZWRWaWV3c18ubGVuZ3RoID0gMDtcblxuICB2YXIgbGF5ZXJzID0gdGhpcy5fYXR0YWNoZWRSZW5kZXJMb29wLnN0YWdlKCkubGlzdExheWVycygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2aWV3ID0gbGF5ZXJzW2ldLnZpZXcoKTtcbiAgICBpZiAodGhpcy51cGRhdGVkVmlld3NfLmluZGV4T2YodmlldykgPCAwKSB7XG4gICAgICBsYXllcnNbaV0udmlldygpLnVwZGF0ZVdpdGhDb250cm9sUGFyYW1ldGVycyhjb250cm9sRGF0YS5vZmZzZXRzKTtcbiAgICAgIHRoaXMudXBkYXRlZFZpZXdzXy5wdXNoKHZpZXcpO1xuICAgIH1cbiAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRyb2xzO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgRHluYW1pY3MgPSByZXF1aXJlKCcuL0R5bmFtaWNzJyk7XG52YXIgSGFtbWVyR2VzdHVyZXMgPSByZXF1aXJlKCcuL0hhbW1lckdlc3R1cmVzJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi91dGlsL2RlZmF1bHRzJyk7XG52YXIgbWF4RnJpY3Rpb24gPSByZXF1aXJlKCcuL3V0aWwnKS5tYXhGcmljdGlvbjtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGZyaWN0aW9uOiA2LFxuICBtYXhGcmljdGlvblRpbWU6IDAuM1xufTtcblxudmFyIGRlYnVnID0gdHlwZW9mIE1BUlpJUEFOT0RFQlVHICE9PSAndW5kZWZpbmVkJyAmJiBNQVJaSVBBTk9ERUJVRy5jb250cm9scztcblxuLyoqXG4gKiBAY2xhc3MgRHJhZ0NvbnRyb2xNZXRob2RcbiAqIEBpbXBsZW1lbnRzIENvbnRyb2xNZXRob2RcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBDb250cm9scyB0aGUgdmlldyBieSBjbGlja2luZy90YXBwaW5nIGFuZCBkcmFnZ2luZy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBsaXN0ZW4gZm9yIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwb2ludGVyVHlwZSBXaGljaCBIYW1tZXIuanMgcG9pbnRlciB0eXBlIHRvIHVzZSAoZS5nLlxuICogYG1vdXNlYCBvciBgdG91Y2hgKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy5mcmljdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMubWF4RnJpY3Rpb25UaW1lXG4gKi9cbmZ1bmN0aW9uIERyYWdDb250cm9sTWV0aG9kKGVsZW1lbnQsIHBvaW50ZXJUeXBlLCBvcHRzKSB7XG4gIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXG4gIHRoaXMuX29wdHMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCBkZWZhdWx0T3B0aW9ucyk7XG5cbiAgdGhpcy5fc3RhcnRFdmVudCA9IG51bGw7XG4gIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cbiAgdGhpcy5fZHluYW1pY3MgPSB7XG4gICAgeDogbmV3IER5bmFtaWNzKCksXG4gICAgeTogbmV3IER5bmFtaWNzKClcbiAgfTtcblxuICB0aGlzLl9oYW1tZXIgPSBIYW1tZXJHZXN0dXJlcy5nZXQoZWxlbWVudCwgcG9pbnRlclR5cGUpO1xuXG4gIHRoaXMuX2hhbW1lci5vbihcImhhbW1lci5pbnB1dFwiLCB0aGlzLl9oYW5kbGVIYW1tZXJFdmVudC5iaW5kKHRoaXMpKTtcblxuICB0aGlzLl9oYW1tZXIub24oJ3BhbnN0YXJ0JywgdGhpcy5faGFuZGxlU3RhcnQuYmluZCh0aGlzKSk7XG4gIHRoaXMuX2hhbW1lci5vbigncGFubW92ZScsIHRoaXMuX2hhbmRsZU1vdmUuYmluZCh0aGlzKSk7XG4gIHRoaXMuX2hhbW1lci5vbigncGFuZW5kJywgdGhpcy5faGFuZGxlRW5kLmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3BhbmNhbmNlbCcsIHRoaXMuX2hhbmRsZUVuZC5iaW5kKHRoaXMpKTtcblxufVxuXG5ldmVudEVtaXR0ZXIoRHJhZ0NvbnRyb2xNZXRob2QpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cbkRyYWdDb250cm9sTWV0aG9kLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2hhbW1lci5yZWxlYXNlKCk7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cbkRyYWdDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlSGFtbWVyRXZlbnQgPSBmdW5jdGlvbihlKSB7XG4gIGlmIChlLmlzRmlyc3QpIHtcbiAgICBpZiAoZGVidWcgJiYgdGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RyYWdDb250cm9sTWV0aG9kIGFjdGl2ZSBkZXRlY3RlZCB3aGVuIGFscmVhZHkgYWN0aXZlJyk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbiAgfVxuICBpZiAoZS5pc0ZpbmFsKSB7XG4gICAgaWYgKGRlYnVnICYmICF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRHJhZ0NvbnRyb2xNZXRob2QgaW5hY3RpdmUgZGV0ZWN0ZWQgd2hlbiBhbHJlYWR5IGluYWN0aXZlJyk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcbiAgfVxufTtcblxuRHJhZ0NvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVTdGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gUHJldmVudCB0aGlzIGV2ZW50IGZyb20gZHJhZ2dpbmcgb3RoZXIgRE9NIGVsZW1lbnRzLCBjYXVzaW5nXG4gIC8vIHVuZXhwZWN0ZWQgYmVoYXZpb3Igb24gQ2hyb21lLlxuICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgdGhpcy5fc3RhcnRFdmVudCA9IGU7XG59O1xuXG5cbkRyYWdDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlTW92ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gUHJldmVudCB0aGlzIGV2ZW50IGZyb20gZHJhZ2dpbmcgb3RoZXIgRE9NIGVsZW1lbnRzLCBjYXVzaW5nXG4gIC8vIHVuZXhwZWN0ZWQgYmVoYXZpb3Igb24gQ2hyb21lLlxuICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgaWYgKHRoaXMuX3N0YXJ0RXZlbnQpIHtcbiAgICB0aGlzLl91cGRhdGVEeW5hbWljc01vdmUoZSk7XG4gICAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsICdheGlzU2NhbGVkWCcsIHRoaXMuX2R5bmFtaWNzLngpO1xuICAgIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCAnYXhpc1NjYWxlZFknLCB0aGlzLl9keW5hbWljcy55KTtcbiAgfVxufTtcblxuXG5EcmFnQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZUVuZCA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gUHJldmVudCB0aGlzIGV2ZW50IGZyb20gZHJhZ2dpbmcgb3RoZXIgRE9NIGVsZW1lbnRzLCBjYXVzaW5nXG4gIC8vIHVuZXhwZWN0ZWQgYmVoYXZpb3Igb24gQ2hyb21lLlxuICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgaWYgKHRoaXMuX3N0YXJ0RXZlbnQpIHtcbiAgICB0aGlzLl91cGRhdGVEeW5hbWljc1JlbGVhc2UoZSk7XG4gICAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsICdheGlzU2NhbGVkWCcsIHRoaXMuX2R5bmFtaWNzLngpO1xuICAgIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCAnYXhpc1NjYWxlZFknLCB0aGlzLl9keW5hbWljcy55KTtcbiAgfVxuXG4gIHRoaXMuX3N0YXJ0RXZlbnQgPSBmYWxzZTtcbiAgdGhpcy5fbGFzdEV2ZW50ID0gZmFsc2U7XG59O1xuXG5cbkRyYWdDb250cm9sTWV0aG9kLnByb3RvdHlwZS5fdXBkYXRlRHluYW1pY3NNb3ZlID0gZnVuY3Rpb24oZSkge1xuICB2YXIgeCA9IGUuZGVsdGFYO1xuICB2YXIgeSA9IGUuZGVsdGFZO1xuXG4gIC8vIFdoZW4gYSBzZWNvbmQgZmluZ2VyIHRvdWNoZXMgdGhlIHNjcmVlbiwgcGFuc3RhcnQgc29tZXRpbWVzIGhhcyBhIGxhcmdlXG4gIC8vIG9mZnNldCBhdCBzdGFydDsgc3VidHJhY3QgdGhhdCBvZmZzZXQgdG8gcHJldmVudCBhIHN1ZGRlbiBqdW1wLlxuICB2YXIgZXZlbnRUb1N1YnRyYWN0ID0gdGhpcy5fbGFzdEV2ZW50IHx8IHRoaXMuX3N0YXJ0RXZlbnQ7XG5cbiAgaWYgKGV2ZW50VG9TdWJ0cmFjdCkge1xuICAgIHggLT0gZXZlbnRUb1N1YnRyYWN0LmRlbHRhWDtcbiAgICB5IC09IGV2ZW50VG9TdWJ0cmFjdC5kZWx0YVk7XG4gIH1cblxuICB2YXIgZWxlbWVudFJlY3QgPSB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgd2lkdGggPSBlbGVtZW50UmVjdC5yaWdodCAtIGVsZW1lbnRSZWN0LmxlZnQ7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50UmVjdC5ib3R0b20gLSBlbGVtZW50UmVjdC50b3A7XG5cbiAgeCAvPSB3aWR0aDtcbiAgeSAvPSBoZWlnaHQ7XG5cbiAgdGhpcy5fZHluYW1pY3MueC5yZXNldCgpO1xuICB0aGlzLl9keW5hbWljcy55LnJlc2V0KCk7XG4gIHRoaXMuX2R5bmFtaWNzLngub2Zmc2V0ID0gLXg7XG4gIHRoaXMuX2R5bmFtaWNzLnkub2Zmc2V0ID0gLXk7XG5cbiAgdGhpcy5fbGFzdEV2ZW50ID0gZTtcbn07XG5cblxudmFyIHRtcFJlbGVhc2VGcmljdGlvbiA9IFsgbnVsbCwgbnVsbCBdO1xuRHJhZ0NvbnRyb2xNZXRob2QucHJvdG90eXBlLl91cGRhdGVEeW5hbWljc1JlbGVhc2UgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBlbGVtZW50UmVjdCA9IHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciB3aWR0aCA9IGVsZW1lbnRSZWN0LnJpZ2h0IC0gZWxlbWVudFJlY3QubGVmdDtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnRSZWN0LmJvdHRvbSAtIGVsZW1lbnRSZWN0LnRvcDtcblxuICB2YXIgeCA9IDEwMDAgKiBlLnZlbG9jaXR5WCAvIHdpZHRoO1xuICB2YXIgeSA9IDEwMDAgKiBlLnZlbG9jaXR5WSAvIGhlaWdodDtcblxuICB0aGlzLl9keW5hbWljcy54LnJlc2V0KCk7XG4gIHRoaXMuX2R5bmFtaWNzLnkucmVzZXQoKTtcbiAgdGhpcy5fZHluYW1pY3MueC52ZWxvY2l0eSA9IHg7XG4gIHRoaXMuX2R5bmFtaWNzLnkudmVsb2NpdHkgPSB5O1xuXG4gIG1heEZyaWN0aW9uKHRoaXMuX29wdHMuZnJpY3Rpb24sIHRoaXMuX2R5bmFtaWNzLngudmVsb2NpdHksIHRoaXMuX2R5bmFtaWNzLnkudmVsb2NpdHksIHRoaXMuX29wdHMubWF4RnJpY3Rpb25UaW1lLCB0bXBSZWxlYXNlRnJpY3Rpb24pO1xuICB0aGlzLl9keW5hbWljcy54LmZyaWN0aW9uID0gdG1wUmVsZWFzZUZyaWN0aW9uWzBdO1xuICB0aGlzLl9keW5hbWljcy55LmZyaWN0aW9uID0gdG1wUmVsZWFzZUZyaWN0aW9uWzFdO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IERyYWdDb250cm9sTWV0aG9kO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjbGFzcyBEeW5hbWljc1xuICogQGNsYXNzZGVzY1xuICpcbiAqIFJlcHJlc2VudHMgaG93IGEgY29udHJvbCBwYXJhbWV0ZXIgY2hhbmdlcy4gVXNlZCBpbiB0aGUgZXZlbnRzIGVtaXR0ZWQgYnlcbiAqIHtAbGluayBDb250cm9sTWV0aG9kfS5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gb2Zmc2V0IFBhcmFtZXRlciBjaGFuZ2VkIGJ5IGEgZml4ZWQgdmFsdWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2ZWxvY2l0eSBQYXJhbWV0ZXIgaXMgY2hhbmdpbmcgYXQgdGhpcyB2ZWxvY2l0eVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZyaWN0aW9uIFRoZSB2ZWxvY2l0eSB3aWxsIGRlY3JlYXNlIGF0IHRoaXMgcmF0ZVxuICovXG5mdW5jdGlvbiBEeW5hbWljcygpIHtcbiAgdGhpcy52ZWxvY2l0eSA9IG51bGw7XG4gIHRoaXMuZnJpY3Rpb24gPSBudWxsO1xuICB0aGlzLm9mZnNldCA9IG51bGw7XG59XG5cbkR5bmFtaWNzLmVxdWFscyA9IGZ1bmN0aW9uKGQxLCBkMikge1xuICByZXR1cm4gZDEudmVsb2NpdHkgPT09IGQyLnZlbG9jaXR5ICYmIGQxLmZyaWN0aW9uID09PSBkMi5mcmljdGlvbiAmJiBkMS5vZmZzZXQgPT09IGQyLm9mZnNldDtcbn07XG5cbkR5bmFtaWNzLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICByZXR1cm4gRHluYW1pY3MuZXF1YWxzKHRoaXMsIG90aGVyKTtcbn07XG5cbkR5bmFtaWNzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvdGhlciwgZWxhcHNlZCkge1xuICBpZiAob3RoZXIub2Zmc2V0KSB7XG4gICAgLy8gSWYgb3RoZXIgaGFzIGFuIG9mZnNldCwgbWFrZSB0aGlzLm9mZnNldCBhIG51bWJlciBpbnN0ZWFkIG9mIG51bGxcbiAgICB0aGlzLm9mZnNldCA9IHRoaXMub2Zmc2V0IHx8IDA7XG4gICAgdGhpcy5vZmZzZXQgKz0gb3RoZXIub2Zmc2V0O1xuICB9XG5cbiAgdmFyIG9mZnNldEZyb21WZWxvY2l0eSA9IHRoaXMub2Zmc2V0RnJvbVZlbG9jaXR5KGVsYXBzZWQpO1xuICBpZiAob2Zmc2V0RnJvbVZlbG9jaXR5KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gb2Zmc2V0IHRvIGFkZCBmcm9tIHRoZSB2ZWxvY2l0eSwgbWFrZSB0aGlzIG9mZnNldCBhIG51bWJlciBpbnN0ZWFkIG9mIG51bGxcbiAgICB0aGlzLm9mZnNldCA9IHRoaXMub2Zmc2V0IHx8IDA7XG4gICAgdGhpcy5vZmZzZXQgKz0gb2Zmc2V0RnJvbVZlbG9jaXR5O1xuICB9XG5cbiAgdGhpcy52ZWxvY2l0eSA9IG90aGVyLnZlbG9jaXR5O1xuICB0aGlzLmZyaWN0aW9uID0gb3RoZXIuZnJpY3Rpb247XG59O1xuXG5EeW5hbWljcy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy52ZWxvY2l0eSA9IG51bGw7XG4gIHRoaXMuZnJpY3Rpb24gPSBudWxsO1xuICB0aGlzLm9mZnNldCA9IG51bGw7XG59O1xuXG5cbkR5bmFtaWNzLnByb3RvdHlwZS52ZWxvY2l0eUFmdGVyID0gZnVuY3Rpb24oZWxhcHNlZCkge1xuICBpZiAoIXRoaXMudmVsb2NpdHkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5mcmljdGlvbikge1xuICAgIHJldHVybiBkZWNyZWFzZUFicyh0aGlzLnZlbG9jaXR5LCB0aGlzLmZyaWN0aW9uICplbGFwc2VkKTtcbiAgfVxuICByZXR1cm4gdGhpcy52ZWxvY2l0eTtcbn07XG5cbkR5bmFtaWNzLnByb3RvdHlwZS5vZmZzZXRGcm9tVmVsb2NpdHkgPSBmdW5jdGlvbihlbGFwc2VkKSB7XG4gIGVsYXBzZWQgPSBNYXRoLm1pbihlbGFwc2VkLCB0aGlzLm51bGxWZWxvY2l0eVRpbWUoKSk7XG5cbiAgdmFyIHZlbG9jaXR5RW5kID0gdGhpcy52ZWxvY2l0eUFmdGVyKGVsYXBzZWQpO1xuICB2YXIgYXZlcmFnZVZlbG9jaXR5ID0gKHRoaXMudmVsb2NpdHkgKyB2ZWxvY2l0eUVuZCkgLyAyO1xuXG4gIHJldHVybiBhdmVyYWdlVmVsb2NpdHkgKiBlbGFwc2VkO1xufTtcblxuXG5EeW5hbWljcy5wcm90b3R5cGUubnVsbFZlbG9jaXR5VGltZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy52ZWxvY2l0eSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHRoaXMudmVsb2NpdHkgJiYgIXRoaXMuZnJpY3Rpb24pIHtcbiAgICByZXR1cm4gSW5maW5pdHk7XG4gIH1cbiAgcmV0dXJuIE1hdGguYWJzKHRoaXMudmVsb2NpdHkgLyB0aGlzLmZyaWN0aW9uKTtcbn07XG5cbmZ1bmN0aW9uIGRlY3JlYXNlQWJzKG51bSwgZGVjKSB7XG4gIGlmIChudW0gPCAwKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKDAsIG51bSArIGRlYyk7XG4gIH1cbiAgaWYgKG51bSA+IDApIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbnVtIC0gZGVjKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEeW5hbWljcztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIER5bmFtaWNzID0gcmVxdWlyZSgnLi9EeW5hbWljcycpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogQGNsYXNzIEVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2RcbiAqIEBpbXBsZW1lbnRzIENvbnRyb2xNZXRob2RcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBTZXRzIHRoZSB2ZWxvY2l0eSBhbmQgZnJpY3Rpb24gb2YgYSBzaW5nbGUgcGFyYW1ldGVyIGJ5IHByZXNzaW5nIGFuZFxuICogdW5wcmVzc2luZyBhIERPTSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHdoaWNoIGFjdGl2YXRlcyB0aGUgbWV0aG9kIHdoZW4gcHJlc3NlZFxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlciBUaGUgcGFyYW1ldGVyIHRvIGJlIGNvbnRyb2xsZWQgKGUuZy4gYHhgLCBgeWAgb3IgYHpvb21gKVxuICogQHBhcmFtIHtudW1iZXJ9IHZlbG9jaXR5IFZlbG9jaXR5IGF0IHdoaWNoIHRoZSBwYXJhbWV0ZXIgY2hhbmdlcy4gVXNlIGFcbiAqIG5lZ2F0aXZlIG51bWJlciBmb3Igb3Bwb3NpdGUgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJpY3Rpb24gRnJpY3Rpb24gYXQgd2hpY2ggdGhlIHBhcmFtZXRlciBzdG9wc1xuKi9cbmZ1bmN0aW9uIEVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2QoZWxlbWVudCwgcGFyYW1ldGVyLCB2ZWxvY2l0eSwgZnJpY3Rpb24pIHtcbiAgaWYoIWVsZW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50UHJlc3NDb250cm9sTWV0aG9kOiBlbGVtZW50IG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuICBpZighcGFyYW1ldGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZDogcGFyYW1ldGVyIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuICBpZighdmVsb2NpdHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50UHJlc3NDb250cm9sTWV0aG9kOiB2ZWxvY2l0eSBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cbiAgaWYoIWZyaWN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZDogZnJpY3Rpb24gbXVzdCBiZSBkZWZpbmVkXCIpO1xuICB9XG5cbiAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgdGhpcy5fcHJlc3NIYW5kbGVyID0gdGhpcy5faGFuZGxlUHJlc3MuYmluZCh0aGlzKTtcbiAgdGhpcy5fcmVsZWFzZUhhbmRsZXIgPSB0aGlzLl9oYW5kbGVSZWxlYXNlLmJpbmQodGhpcyk7XG5cbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9wcmVzc0hhbmRsZXIpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9yZWxlYXNlSGFuZGxlcik7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX3JlbGVhc2VIYW5kbGVyKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fcHJlc3NIYW5kbGVyKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9yZWxlYXNlSGFuZGxlcik7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9yZWxlYXNlSGFuZGxlcik7XG5cbiAgdGhpcy5fcGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICB0aGlzLl92ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICB0aGlzLl9mcmljdGlvbiA9IGZyaWN0aW9uO1xuICB0aGlzLl9keW5hbWljcyA9IG5ldyBEeW5hbWljcygpO1xuXG4gIHRoaXMuX3ByZXNzaW5nID0gZmFsc2U7XG59XG5ldmVudEVtaXR0ZXIoRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZCk7XG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX3ByZXNzSGFuZGxlcik7XG4gIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX3JlbGVhc2VIYW5kbGVyKTtcbiAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5fcmVsZWFzZUhhbmRsZXIpO1xuICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9wcmVzc0hhbmRsZXIpO1xuICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX3JlbGVhc2VIYW5kbGVyKTtcbiAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX3JlbGVhc2VIYW5kbGVyKTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZVByZXNzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3ByZXNzaW5nID0gdHJ1ZTtcblxuICB0aGlzLl9keW5hbWljcy52ZWxvY2l0eSA9IHRoaXMuX3ZlbG9jaXR5O1xuICB0aGlzLl9keW5hbWljcy5mcmljdGlvbiA9IDA7XG4gIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCB0aGlzLl9wYXJhbWV0ZXIsIHRoaXMuX2R5bmFtaWNzKTtcbiAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbn07XG5cbkVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVSZWxlYXNlID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMuX3ByZXNzaW5nKSB7XG4gICAgdGhpcy5fZHluYW1pY3MuZnJpY3Rpb24gPSB0aGlzLl9mcmljdGlvbjtcbiAgICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgdGhpcy5fcGFyYW1ldGVyLCB0aGlzLl9keW5hbWljcyk7XG4gICAgdGhpcy5lbWl0KCdpbmFjdGl2ZScpO1xuICB9XG5cbiAgdGhpcy5fcHJlc3NpbmcgPSBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEhhbW1lciA9IHJlcXVpcmUoJ2hhbW1lcmpzJyk7XG5cbnZhciBuZXh0SWQgPSAxO1xudmFyIGlkUHJvcGVydHkgPSAnTWFyemlwYW5vSGFtbWVyRWxlbWVudElkJztcbmZ1bmN0aW9uIGdldEtleUZvckVsZW1lbnRBbmRUeXBlKGVsZW1lbnQsIHR5cGUpIHtcbiAgaWYgKCFlbGVtZW50W2lkUHJvcGVydHldKSB7XG4gICAgZWxlbWVudFtpZFByb3BlcnR5XSA9IG5leHRJZCsrO1xuICB9XG4gIHJldHVybiB0eXBlICsgZWxlbWVudFtpZFByb3BlcnR5XTtcbn1cblxuXG4vKipcbiAqIEBjbGFzcyBIYW1tZXJHZXN0dXJlc1xuICogQGNsYXNzZGVzY1xuICpcbiAqIE1hbmFnZXMgSGFtbWVyLmpzIGluc3RhbmNlcy4gT25lIGluc3RhbmNlIGlzIGNyZWF0ZWQgZm9yIGVhY2ggY29tYmluYXRpb24gb2ZcbiAqIERPTSBlbGVtZW50IGFuZCBwb2ludGVyIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIEhhbW1lckdlc3R1cmVzKCkge1xuICB0aGlzLl9tYW5hZ2VycyA9IHt9O1xuICB0aGlzLl9yZWZDb3VudCA9IHt9O1xufVxuXG5cbkhhbW1lckdlc3R1cmVzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihlbGVtZW50LCB0eXBlKSB7XG4gIHZhciBrZXkgPSBnZXRLZXlGb3JFbGVtZW50QW5kVHlwZShlbGVtZW50LCB0eXBlKTtcbiAgaWYgKCF0aGlzLl9tYW5hZ2Vyc1trZXldKSB7XG4gICAgdGhpcy5fbWFuYWdlcnNba2V5XSA9IHRoaXMuX2NyZWF0ZU1hbmFnZXIoZWxlbWVudCwgdHlwZSk7XG4gICAgdGhpcy5fcmVmQ291bnRba2V5XSA9IDA7XG4gIH1cbiAgdGhpcy5fcmVmQ291bnRba2V5XSsrO1xuICByZXR1cm4gbmV3IEhhbW1lckdlc3R1cmVzSGFuZGxlKHRoaXMsIHRoaXMuX21hbmFnZXJzW2tleV0sIGVsZW1lbnQsIHR5cGUpO1xufTtcblxuXG5IYW1tZXJHZXN0dXJlcy5wcm90b3R5cGUuX2NyZWF0ZU1hbmFnZXIgPSBmdW5jdGlvbihlbGVtZW50LCB0eXBlKSB7XG4gIHZhciBtYW5hZ2VyID0gbmV3IEhhbW1lci5NYW5hZ2VyKGVsZW1lbnQpO1xuXG4gIC8vIE1hbmFnZXJzIGFyZSBjcmVhdGVkIHdpdGggZGlmZmVyZW50IHBhcmFtZXRlcnMgZm9yIGRpZmZlcmVudCBwb2ludGVyXG4gIC8vIHR5cGVzLlxuICBpZiAodHlwZSA9PT0gJ21vdXNlJykge1xuICAgIG1hbmFnZXIuYWRkKG5ldyBIYW1tZXIuUGFuKHsgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0FMTCwgdGhyZXNob2xkOiAwIH0pKTtcbiAgfVxuICBlbHNlIGlmICh0eXBlID09PSAndG91Y2gnIHx8IHR5cGUgPT09ICdwZW4nIHx8IHR5cGUgPT09ICdraW5lY3QnKSB7XG4gICAgLy8gT24gdG91Y2ggb25lIHdhbnRzIHRvIGhhdmUgYm90aCBwYW5uaW5nIGFuZCBwaW5jaGluZy4gVGhlIHBhbm5pbmdcbiAgICAvLyByZWNvZ25pemVyIG5lZWRzIGEgdGhyZXNob2xkIHRvIGFsbG93IHRoZSBwaW5jaCB0byBiZSByZWNvZ25pemVkLlxuICAgIG1hbmFnZXIuYWRkKG5ldyBIYW1tZXIuUGFuKHsgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0FMTCwgdGhyZXNob2xkOiAyMCwgcG9pbnRlcnM6IDEgfSkpO1xuICAgIG1hbmFnZXIuYWRkKG5ldyBIYW1tZXIuUGluY2goKSk7XG4gIH1cblxuICByZXR1cm4gbWFuYWdlcjtcbn07XG5cblxuSGFtbWVyR2VzdHVyZXMucHJvdG90eXBlLl9yZWxlYXNlSGFuZGxlID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSkge1xuICB2YXIga2V5ID0gZ2V0S2V5Rm9yRWxlbWVudEFuZFR5cGUoZWxlbWVudCwgdHlwZSk7XG4gIGlmICh0aGlzLl9yZWZDb3VudFtrZXldKSB7XG4gICAgdGhpcy5fcmVmQ291bnRba2V5XS0tO1xuICAgIGlmICghdGhpcy5fcmVmQ291bnRba2V5XSkge1xuICAgICAgdGhpcy5fbWFuYWdlcnNba2V5XS5kZXN0cm95KCk7XG4gICAgICBkZWxldGUgdGhpcy5fbWFuYWdlcnNba2V5XTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9yZWZDb3VudFtrZXldO1xuICAgIH1cbiAgfVxufTtcblxuXG5mdW5jdGlvbiBIYW1tZXJHZXN0dXJlc0hhbmRsZShoYW1tZXJHZXN0dXJlcywgbWFuYWdlciwgZWxlbWVudCwgdHlwZSkge1xuICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuX3R5cGUgPSB0eXBlO1xuICB0aGlzLl9oYW1tZXJHZXN0dXJlcyA9IGhhbW1lckdlc3R1cmVzO1xuICB0aGlzLl9ldmVudEhhbmRsZXJzID0gW107XG59XG5cblxuSGFtbWVyR2VzdHVyZXNIYW5kbGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gIHZhciB0eXBlID0gdGhpcy5fdHlwZTtcbiAgdmFyIGhhbmRsZXJGaWx0ZXJlZEV2ZW50cyA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodHlwZSA9PT0gZS5wb2ludGVyVHlwZSkge1xuICAgICAgaGFuZGxlcihlKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5fZXZlbnRIYW5kbGVycy5wdXNoKHsgZXZlbnRzOiBldmVudHMsIGhhbmRsZXI6IGhhbmRsZXJGaWx0ZXJlZEV2ZW50cyB9KTtcbiAgdGhpcy5fbWFuYWdlci5vbihldmVudHMsIGhhbmRsZXJGaWx0ZXJlZEV2ZW50cyk7XG59O1xuXG5cbkhhbW1lckdlc3R1cmVzSGFuZGxlLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRIYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBldmVudEhhbmRsZXIgPSB0aGlzLl9ldmVudEhhbmRsZXJzW2ldO1xuICAgIHRoaXMuX21hbmFnZXIub2ZmKGV2ZW50SGFuZGxlci5ldmVudHMsIGV2ZW50SGFuZGxlci5oYW5kbGVyKTtcbiAgfVxuXG4gIHRoaXMuX2hhbW1lckdlc3R1cmVzLl9yZWxlYXNlSGFuZGxlKHRoaXMuX2VsZW1lbnQsIHRoaXMuX3R5cGUpO1xuICB0aGlzLl9tYW5hZ2VyID0gbnVsbDtcbiAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIHRoaXMuX3R5cGUgPSBudWxsO1xuICB0aGlzLl9oYW1tZXJHZXN0dXJlcyA9IG51bGw7XG59O1xuXG5cbkhhbW1lckdlc3R1cmVzSGFuZGxlLnByb3RvdHlwZS5tYW5hZ2VyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9tYW5hZ2VyO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBIYW1tZXJHZXN0dXJlcygpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgRHluYW1pY3MgPSByZXF1aXJlKCcuL0R5bmFtaWNzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3MgS2V5Q29udHJvbE1ldGhvZFxuICogQGltcGxlbWVudHMgQ29udHJvbE1ldGhvZFxuICogQGNsYXNzZGVzY1xuICpcbiAqIFNldHMgdGhlIHZlbG9jaXR5IGFuZCBmcmljdGlvbiBvZiBhIHNpbmdsZSBwYXJhbWV0ZXIgYnkgcHJlc3NpbmcgYW5kXG4gKiB1bnByZXNzaW5nIGEga2V5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBrZXlDb2RlIEtleSB3aGljaCBhY3RpdmF0ZXMgdGhlIG1ldGhvZCB3aGVuIHByZXNzZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXIgVGhlIHBhcmFtZXRlciB0byBiZSBjb250cm9sbGVkIChlLmcuIGB4YCwgYHlgIG9yIGB6b29tYClcbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZWxvY2l0eSBWZWxvY2l0eSBhdCB3aGljaCB0aGUgcGFyYW1ldGVyIGNoYW5nZXMuIFVzZSBhXG4gKiBuZWdhdGl2ZSBudW1iZXIgZm9yIG9wcG9zaXRlIGRpcmVjdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGZyaWN0aW9uIEZyaWN0aW9uIGF0IHdoaWNoIHRoZSBwYXJhbWV0ZXIgc3RvcHNcbiAqIEBwYXJhbSB7RWxlbWVudH0gW2VsZW1lbnQ9ZG9jdW1lbnRdIERPTSBlbGVtZW50IHdoZXJlIHRoZSBrZXkgZXZlbnRzIGFyZSBsaXN0ZW5lZCB0b1xuICovXG5mdW5jdGlvbiBLZXlDb250cm9sTWV0aG9kKGtleUNvZGUsIHBhcmFtZXRlciwgdmVsb2NpdHksIGZyaWN0aW9uLCBlbGVtZW50KSB7XG4gIGlmKCFrZXlDb2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5Q29udHJvbE1ldGhvZDoga2V5Q29kZSBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cbiAgaWYoIXBhcmFtZXRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIktleUNvbnRyb2xNZXRob2Q6IHBhcmFtZXRlciBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cbiAgaWYoIXZlbG9jaXR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5Q29udHJvbE1ldGhvZDogdmVsb2NpdHkgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICB9XG4gIGlmKCFmcmljdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIktleUNvbnRyb2xNZXRob2Q6IGZyaWN0aW9uIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuXG4gIGVsZW1lbnQgPSBlbGVtZW50IHx8IGRvY3VtZW50O1xuXG4gIHRoaXMuX2tleUNvZGUgPSBrZXlDb2RlO1xuICB0aGlzLl9wYXJhbWV0ZXIgPSBwYXJhbWV0ZXI7XG4gIHRoaXMuX3ZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gIHRoaXMuX2ZyaWN0aW9uID0gZnJpY3Rpb247XG4gIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXG4gIHRoaXMuX2tleWRvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlUHJlc3MuYmluZCh0aGlzKTtcbiAgdGhpcy5fa2V5dXBIYW5kbGVyID0gdGhpcy5faGFuZGxlUmVsZWFzZS5iaW5kKHRoaXMpO1xuICB0aGlzLl9ibHVySGFuZGxlciA9IHRoaXMuX2hhbmRsZUJsdXIuYmluZCh0aGlzKTtcblxuICB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlkb3duSGFuZGxlcik7XG4gIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9rZXl1cEhhbmRsZXIpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2JsdXJIYW5kbGVyKTtcblxuICB0aGlzLl9keW5hbWljcyA9IG5ldyBEeW5hbWljcygpO1xuICB0aGlzLl9wcmVzc2luZyA9IGZhbHNlO1xufVxuZXZlbnRFbWl0dGVyKEtleUNvbnRyb2xNZXRob2QpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cbktleUNvbnRyb2xNZXRob2QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fa2V5ZG93bkhhbmRsZXIpO1xuICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fa2V5dXBIYW5kbGVyKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ibHVySGFuZGxlcik7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cbktleUNvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVQcmVzcyA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYoZS5rZXlDb2RlICE9PSB0aGlzLl9rZXlDb2RlKSB7IHJldHVybjsgfVxuXG4gIHRoaXMuX3ByZXNzaW5nID0gdHJ1ZTtcblxuICB0aGlzLl9keW5hbWljcy52ZWxvY2l0eSA9IHRoaXMuX3ZlbG9jaXR5O1xuICB0aGlzLl9keW5hbWljcy5mcmljdGlvbiA9IDA7XG4gIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCB0aGlzLl9wYXJhbWV0ZXIsIHRoaXMuX2R5bmFtaWNzKTtcbiAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbn07XG5cbktleUNvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVSZWxlYXNlID0gZnVuY3Rpb24oZSkge1xuICBpZihlLmtleUNvZGUgIT09IHRoaXMuX2tleUNvZGUpIHsgcmV0dXJuOyB9XG5cbiAgaWYodGhpcy5fcHJlc3NpbmcpIHtcbiAgICB0aGlzLl9keW5hbWljcy5mcmljdGlvbiA9IHRoaXMuX2ZyaWN0aW9uO1xuICAgIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCB0aGlzLl9wYXJhbWV0ZXIsIHRoaXMuX2R5bmFtaWNzKTtcbiAgICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG4gIH1cblxuICB0aGlzLl9wcmVzc2luZyA9IGZhbHNlO1xufTtcblxuS2V5Q29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZUJsdXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZHluYW1pY3MudmVsb2NpdHkgPSAwO1xuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgdGhpcy5fcGFyYW1ldGVyLCB0aGlzLl9keW5hbWljcyk7XG4gIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcblxuICB0aGlzLl9wcmVzc2luZyA9IGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlDb250cm9sTWV0aG9kO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgRHluYW1pY3MgPSByZXF1aXJlKCcuL0R5bmFtaWNzJyk7XG52YXIgSGFtbWVyR2VzdHVyZXMgPSByZXF1aXJlKCcuL0hhbW1lckdlc3R1cmVzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3MgUGluY2hab29tQ29udHJvbE1ldGhvZFxuICogQGltcGxlbWVudHMgQ29udHJvbE1ldGhvZFxuICogQGNsYXNzZGVzY1xuICpcbiAqIENvbnRyb2wgdGhlIHZpZXcgZm92L3pvb20gYnkgcGluY2hpbmcgd2l0aCB0d28gZmluZ2Vycy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBsaXN0ZW4gZm9yIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwb2ludGVyVHlwZSBXaGljaCBIYW1tZXIuanMgcG9pbnRlciB0eXBlIHRvIHVzZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuZnVuY3Rpb24gUGluY2hab29tQ29udHJvbE1ldGhvZChlbGVtZW50LCBwb2ludGVyVHlwZSwgb3B0cykge1xuICB0aGlzLl9oYW1tZXIgPSBIYW1tZXJHZXN0dXJlcy5nZXQoZWxlbWVudCwgcG9pbnRlclR5cGUpO1xuXG4gIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cbiAgdGhpcy5fZHluYW1pY3MgPSBuZXcgRHluYW1pY3MoKTtcblxuICB0aGlzLl9oYW1tZXIub24oJ3BpbmNoc3RhcnQnLCB0aGlzLl9oYW5kbGVTdGFydC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5faGFtbWVyLm9uKCdwaW5jaCcsIHRoaXMuX2hhbmRsZUV2ZW50LmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3BpbmNoZW5kJywgdGhpcy5faGFuZGxlRW5kLmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3BpbmNoY2FuY2VsJywgdGhpcy5faGFuZGxlRW5kLmJpbmQodGhpcykpO1xufVxuXG5ldmVudEVtaXR0ZXIoUGluY2hab29tQ29udHJvbE1ldGhvZCk7XG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuUGluY2hab29tQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9oYW1tZXIucmVsZWFzZSgpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cblBpbmNoWm9vbUNvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVTdGFydCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbiAgfVxufTtcblxuXG5QaW5jaFpvb21Db250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlRW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcbiAgfVxufTtcblxuXG5QaW5jaFpvb21Db250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlRXZlbnQgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBzY2FsZSA9IGUuc2NhbGU7XG5cbiAgaWYgKHRoaXMuX2xhc3RFdmVudCkge1xuICAgIHNjYWxlIC89IHRoaXMuX2xhc3RFdmVudC5zY2FsZTtcbiAgfVxuXG4gIHRoaXMuX2R5bmFtaWNzLm9mZnNldCA9IChzY2FsZSAtIDEpICogLTE7XG4gIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCAnem9vbScsIHRoaXMuX2R5bmFtaWNzKTtcblxuICB0aGlzLl9sYXN0RXZlbnQgPSBlO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBpbmNoWm9vbUNvbnRyb2xNZXRob2Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBEeW5hbWljcyA9IHJlcXVpcmUoJy4vRHluYW1pY3MnKTtcbnZhciBIYW1tZXJHZXN0dXJlcyA9IHJlcXVpcmUoJy4vSGFtbWVyR2VzdHVyZXMnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVmYXVsdHMnKTtcbnZhciBtYXhGcmljdGlvbiA9IHJlcXVpcmUoJy4vdXRpbCcpLm1heEZyaWN0aW9uO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBzcGVlZDogOCxcbiAgZnJpY3Rpb246IDYsXG4gIG1heEZyaWN0aW9uVGltZTogMC4zXG59O1xuXG5cbi8qKlxuICogQGNsYXNzIFF0dnJDb250cm9sTWV0aG9kXG4gKiBAaW1wbGVtZW50cyBDb250cm9sTWV0aG9kXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQ29udHJvbHMgdGhlIHZpZXcgYnkgaG9sZGluZyB0aGUgbW91c2UgYnV0dG9uIGRvd24gYW5kIG1vdmluZyBpdC5cbiAqIEFsc28ga25vd24gYXMgXCJRVFZSXCIgY29udHJvbCBtb2RlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGxpc3RlbiBmb3IgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHBvaW50ZXJUeXBlIFdoaWNoIEhhbW1lci5qcyBwb2ludGVyIHR5cGUgdG8gdXNlIChlLmcuXG4gKiBgbW91c2VgIG9yIGB0b3VjaGApLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNwZWVkXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy5mcmljdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMubWF4RnJpY3Rpb25UaW1lXG4gKi9cbi8vIFRPRE86IGFsbG93IHNwZWVkIG5vdCBjaGFuZ2UgbGluZWFybHkgd2l0aCBkaXN0YW5jZSB0byBjbGljayBzcG90LlxuLy8gUXVhZHJhdGljIG9yIG90aGVyIHdvdWxkIGFsbG93IGEgbGFyZ2VyIHNwZWVkIHJhbmdlLlxuZnVuY3Rpb24gUXR2ckNvbnRyb2xNZXRob2QoZWxlbWVudCwgcG9pbnRlclR5cGUsIG9wdHMpIHtcbiAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgdGhpcy5fb3B0cyA9IGRlZmF1bHRzKG9wdHMgfHwge30sIGRlZmF1bHRPcHRpb25zKTtcblxuICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblxuICB0aGlzLl9oYW1tZXIgPSBIYW1tZXJHZXN0dXJlcy5nZXQoZWxlbWVudCwgcG9pbnRlclR5cGUpO1xuXG4gIHRoaXMuX2R5bmFtaWNzID0ge1xuICAgIHg6IG5ldyBEeW5hbWljcygpLFxuICAgIHk6IG5ldyBEeW5hbWljcygpXG4gIH07XG5cbiAgdGhpcy5faGFtbWVyLm9uKCdwYW5zdGFydCcsIHRoaXMuX2hhbmRsZVN0YXJ0LmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3Bhbm1vdmUnLCB0aGlzLl9oYW5kbGVNb3ZlLmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3BhbmVuZCcsIHRoaXMuX2hhbmRsZVJlbGVhc2UuYmluZCh0aGlzKSk7XG4gIHRoaXMuX2hhbW1lci5vbigncGFuY2FuY2VsJywgdGhpcy5faGFuZGxlUmVsZWFzZS5iaW5kKHRoaXMpKTtcbn1cblxuZXZlbnRFbWl0dGVyKFF0dnJDb250cm9sTWV0aG9kKTtcblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5RdHZyQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9oYW1tZXIucmVsZWFzZSgpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cblF0dnJDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlU3RhcnQgPSBmdW5jdGlvbihlKSB7XG4gIC8vIFByZXZlbnQgZXZlbnQgZHJhZ2dpbmcgb3RoZXIgRE9NIGVsZW1lbnRzIGFuZCBjYXVzaW5nIHN0cmFuZ2UgYmVoYXZpb3Igb24gQ2hyb21lXG4gIGUucHJldmVudERlZmF1bHQoKTtcblxuICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbiAgfVxufTtcblxuXG5RdHZyQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZU1vdmUgPSBmdW5jdGlvbihlKSB7XG4gIC8vIFByZXZlbnQgZXZlbnQgZHJhZ2dpbmcgb3RoZXIgRE9NIGVsZW1lbnRzIGFuZCBjYXVzaW5nIHN0cmFuZ2UgYmVoYXZpb3Igb24gQ2hyb21lXG4gIGUucHJldmVudERlZmF1bHQoKTtcblxuICB0aGlzLl91cGRhdGVEeW5hbWljcyhlLCBmYWxzZSk7XG59O1xuXG5cblF0dnJDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlUmVsZWFzZSA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gUHJldmVudCBldmVudCBkcmFnZ2luZyBvdGhlciBET00gZWxlbWVudHMgYW5kIGNhdXNpbmcgc3RyYW5nZSBiZWhhdmlvciBvbiBDaHJvbWVcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIHRoaXMuX3VwZGF0ZUR5bmFtaWNzKGUsIHRydWUpO1xuXG4gIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG4gIH1cbn07XG5cblxudmFyIHRtcFJlbGVhc2VGcmljdGlvbiA9IFsgbnVsbCwgbnVsbCBdO1xuUXR2ckNvbnRyb2xNZXRob2QucHJvdG90eXBlLl91cGRhdGVEeW5hbWljcyA9IGZ1bmN0aW9uKGUsIHJlbGVhc2UpIHtcbiAgdmFyIGVsZW1lbnRSZWN0ID0gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHdpZHRoID0gZWxlbWVudFJlY3QucmlnaHQgLSBlbGVtZW50UmVjdC5sZWZ0O1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudFJlY3QuYm90dG9tIC0gZWxlbWVudFJlY3QudG9wO1xuICB2YXIgbWF4RGltID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG5cbiAgdmFyIHggPSBlLmRlbHRhWCAvIG1heERpbSAqIHRoaXMuX29wdHMuc3BlZWQ7XG4gIHZhciB5ID0gZS5kZWx0YVkgLyBtYXhEaW0gKiB0aGlzLl9vcHRzLnNwZWVkO1xuXG4gIHRoaXMuX2R5bmFtaWNzLngucmVzZXQoKTtcbiAgdGhpcy5fZHluYW1pY3MueS5yZXNldCgpO1xuICB0aGlzLl9keW5hbWljcy54LnZlbG9jaXR5ID0geDtcbiAgdGhpcy5fZHluYW1pY3MueS52ZWxvY2l0eSA9IHk7XG5cbiAgaWYgKHJlbGVhc2UpIHtcbiAgICBtYXhGcmljdGlvbih0aGlzLl9vcHRzLmZyaWN0aW9uLCB0aGlzLl9keW5hbWljcy54LnZlbG9jaXR5LCB0aGlzLl9keW5hbWljcy55LnZlbG9jaXR5LCB0aGlzLl9vcHRzLm1heEZyaWN0aW9uVGltZSwgdG1wUmVsZWFzZUZyaWN0aW9uKTtcbiAgICB0aGlzLl9keW5hbWljcy54LmZyaWN0aW9uID0gdG1wUmVsZWFzZUZyaWN0aW9uWzBdO1xuICAgIHRoaXMuX2R5bmFtaWNzLnkuZnJpY3Rpb24gPSB0bXBSZWxlYXNlRnJpY3Rpb25bMV07XG4gIH1cblxuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgJ3gnLCB0aGlzLl9keW5hbWljcy54KTtcbiAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsICd5JywgdGhpcy5fZHluYW1pY3MueSk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUXR2ckNvbnRyb2xNZXRob2Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBEeW5hbWljcyA9IHJlcXVpcmUoJy4vRHluYW1pY3MnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVmYXVsdHMnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGZyaWN0aW9uVGltZTogMC4yLFxuICB6b29tRGVsdGE6IDAuMDAxXG59O1xuXG4vKipcbiAqIEBjbGFzcyBTY3JvbGxab29tQ29udHJvbE1ldGhvZFxuICogQGltcGxlbWVudHMgQ29udHJvbE1ldGhvZFxuICogQGNsYXNzZGVzY1xuICpcbiAqIENvbnRyb2xzIHRoZSBmb3Yvem9vbSB0aHJvdWdoIHRoZSBtb3VzZSB3aGVlbC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBsaXN0ZW4gZm9yIGV2ZW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZnJpY3Rpb25UaW1lPTAuMl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy56b29tRGVsdGE9MC4wMDFdXG4gKi9cbmZ1bmN0aW9uIFNjcm9sbFpvb21Db250cm9sTWV0aG9kKGVsZW1lbnQsIG9wdHMpIHtcbiAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuX29wdHMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCBkZWZhdWx0T3B0aW9ucyk7XG4gIHRoaXMuX2R5bmFtaWNzID0gbmV3IER5bmFtaWNzKCk7XG4gIHRoaXMuX2V2ZW50TGlzdCA9IFtdO1xuXG4gIHZhciBmbiA9IHRoaXMuX29wdHMuZnJpY3Rpb25UaW1lID8gdGhpcy53aXRoU21vb3RoaW5nIDogdGhpcy53aXRob3V0U21vb3RoaW5nO1xuICB0aGlzLl93aGVlbExpc3RlbmVyID0gZm4uYmluZCh0aGlzKTtcbiAgXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl93aGVlbExpc3RlbmVyKTtcbn1cblxuZXZlbnRFbWl0dGVyKFNjcm9sbFpvb21Db250cm9sTWV0aG9kKTtcblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5TY3JvbGxab29tQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fd2hlZWxMaXN0ZW5lcik7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxuU2Nyb2xsWm9vbUNvbnRyb2xNZXRob2QucHJvdG90eXBlLndpdGhvdXRTbW9vdGhpbmcgPSBmdW5jdGlvbihlKSB7XG4gIHRoaXMuX2R5bmFtaWNzLm9mZnNldCA9IHdoZWVsRXZlbnREZWx0YShlKSAqIHRoaXMuX29wdHMuem9vbURlbHRhO1xuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgJ3pvb20nLCB0aGlzLl9keW5hbWljcyk7XG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIHRoaXMuZW1pdCgnYWN0aXZlJyk7XG4gIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcbn07XG5cblxuU2Nyb2xsWm9vbUNvbnRyb2xNZXRob2QucHJvdG90eXBlLndpdGhTbW9vdGhpbmcgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBjdXJyZW50VGltZSA9IGUudGltZVN0YW1wO1xuXG4gIC8vIFJlY29yZCBldmVudC5cbiAgdGhpcy5fZXZlbnRMaXN0LnB1c2goZSk7XG5cbiAgLy8gUmVtb3ZlIGV2ZW50cyB3aG9zZSBzbW9vdGhpbmcgaGFzIGFscmVhZHkgZXhwaXJlZC5cbiAgd2hpbGUgKHRoaXMuX2V2ZW50TGlzdFswXS50aW1lU3RhbXAgPCBjdXJyZW50VGltZSAtIHRoaXMuX29wdHMuZnJpY3Rpb25UaW1lKjEwMDApIHtcbiAgICB0aGlzLl9ldmVudExpc3Quc2hpZnQoMCk7XG4gIH1cblxuICAvLyBHZXQgdGhlIGN1cnJlbnQgdmVsb2NpdHkgZnJvbSB0aGUgcmVjb3JkZWQgZXZlbnRzLlxuICAvLyBFYWNoIHdoZWVsIG1vdmVtZW50IGNhdXNlcyBhIHZlbG9jaXR5IG9mIGNoYW5nZS9mcmljdGlvblRpbWUgZHVyaW5nIGZyaWN0aW9uVGltZS5cbiAgdmFyIHZlbG9jaXR5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ldmVudExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgem9vbUNoYW5nZUZyb21FdmVudCA9IHdoZWVsRXZlbnREZWx0YSh0aGlzLl9ldmVudExpc3RbaV0pICogdGhpcy5fb3B0cy56b29tRGVsdGE7XG4gICAgdmVsb2NpdHkgKz0gem9vbUNoYW5nZUZyb21FdmVudCAvIHRoaXMuX29wdHMuZnJpY3Rpb25UaW1lO1xuICB9XG5cbiAgdGhpcy5fZHluYW1pY3MudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgdGhpcy5fZHluYW1pY3MuZnJpY3Rpb24gPSBNYXRoLmFicyh2ZWxvY2l0eSkgLyB0aGlzLl9vcHRzLmZyaWN0aW9uVGltZTtcblxuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgJ3pvb20nLCB0aGlzLl9keW5hbWljcyk7XG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIHRoaXMuZW1pdCgnYWN0aXZlJyk7XG4gIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcbn07XG5cblxuZnVuY3Rpb24gd2hlZWxFdmVudERlbHRhKGUpIHtcbiAgdmFyIG11bHRpcGxpZXIgPSBlLmRlbHRhTW9kZSA9PSAxID8gMjAgOiAxO1xuICByZXR1cm4gZS5kZWx0YVkgKiBtdWx0aXBsaWVyO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gU2Nyb2xsWm9vbUNvbnRyb2xNZXRob2Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBEeW5hbWljcyA9IHJlcXVpcmUoJy4vRHluYW1pY3MnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vKipcbiAqIEBjbGFzcyBWZWxvY2l0eUNvbnRyb2xNZXRob2RcbiAqIEBpbXBsZW1lbnRzIENvbnRyb2xNZXRob2RcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBTZXRzIHRoZSB2ZWxvY2l0eSBhbmQgZnJpY3Rpb24gb2YgYSBzaW5nbGUgcGFyYW1ldGVyLlxuICpcbiAqIFRoZSB1c2VyIHNob3VsZCBlbWl0ICdhY3RpdmUnIGFuZCAnaW5hY3RpdmUnIGV2ZW50cyBpZiByZXF1aXJlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1ldGVyIFRoZSBwYXJhbWV0ZXIgdG8gYmUgY29udHJvbGxlZCAoZS5nLiBgeGAsIGB5YCBvciBgem9vbWApXG4qL1xuZnVuY3Rpb24gVmVsb2NpdHlDb250cm9sTWV0aG9kKHBhcmFtZXRlcikge1xuICBpZighcGFyYW1ldGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVmVsb2NpdHlDb250cm9sTWV0aG9kOiBwYXJhbWV0ZXIgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICB9XG5cbiAgdGhpcy5fcGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICB0aGlzLl9keW5hbWljcyA9IG5ldyBEeW5hbWljcygpO1xufVxuZXZlbnRFbWl0dGVyKFZlbG9jaXR5Q29udHJvbE1ldGhvZCk7XG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuVmVsb2NpdHlDb250cm9sTWV0aG9kLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBwYXJhbWV0ZXIncyB2ZWxvY2l0eS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZWxvY2l0eVxuICovXG5WZWxvY2l0eUNvbnRyb2xNZXRob2QucHJvdG90eXBlLnNldFZlbG9jaXR5ID0gZnVuY3Rpb24odmVsb2NpdHkpIHtcbiAgdGhpcy5fZHluYW1pY3MudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsIHRoaXMuX3BhcmFtZXRlciwgdGhpcy5fZHluYW1pY3MpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHBhcmFtZXRlcidzIGZyaWN0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IGZyaWN0aW9uXG4gKi9cblZlbG9jaXR5Q29udHJvbE1ldGhvZC5wcm90b3R5cGUuc2V0RnJpY3Rpb24gPSBmdW5jdGlvbihmcmljdGlvbikge1xuICB0aGlzLl9keW5hbWljcy5mcmljdGlvbiA9IGZyaWN0aW9uO1xuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgdGhpcy5fcGFyYW1ldGVyLCB0aGlzLl9keW5hbWljcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlbG9jaXR5Q29udHJvbE1ldGhvZDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vdXRpbC9kZWZhdWx0cycpO1xudmFyIERyYWdDb250cm9sTWV0aG9kID0gcmVxdWlyZSgnLi9EcmFnJyk7XG52YXIgUXR2ckNvbnRyb2xNZXRob2QgPSByZXF1aXJlKCcuL1F0dnInKTtcbnZhciBTY3JvbGxab29tQ29udHJvbE1ldGhvZCA9IHJlcXVpcmUoJy4vU2Nyb2xsWm9vbScpO1xudmFyIFBpbmNoWm9vbUNvbnRyb2xNZXRob2QgPSByZXF1aXJlKCcuL1BpbmNoWm9vbScpO1xudmFyIEtleUNvbnRyb2xNZXRob2QgPSByZXF1aXJlKCcuL0tleScpO1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIG1vdXNlVmlld01vZGU6ICdkcmFnJ1xufTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZSBhbmQgcmVnaXN0ZXIgc29tZSBjb21tb25seSB1c2VkIHtAbGluayBDb250cm9sTWV0aG9kfSBpbnN0YW5jZXMuXG4gKlxuICogVGhlIGZvbGxvd2luZyBpbnN0YW5jZXMgYXJlIHJlZ2lzdGVyZWQ6XG4gKiAgIC0gbW91c2VWaWV3RHJhZ1xuICogICAtIG1vdXNlVmlld1F0dnJcbiAqICAgLSB0b3VjaFZpZXdcbiAqICAgLSBwaW5jaFxuICogICAtIGFycm93S2V5c1xuICogICAtIHBsdXNNaW51c0tleXNcbiAqICAgLSB3YXNkS2V5c1xuICogICAtIHFlS2V5c1xuICpcbiAqIEBwYXJhbSB7Q29udHJvbHN9IGNvbnRyb2xzIFdoZXJlIHRvIHJlZ2lzdGVyIHRoZSBpbnN0YW5jZXMuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBsaXN0ZW4gZm9yIGV2ZW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0geydkcmFnJ3wncXR2cid9IG1vdXNlVmlld01vZGVcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHMoY29udHJvbHMsIGVsZW1lbnQsIG9wdHMpIHtcbiAgb3B0cyA9IGRlZmF1bHRzKG9wdHMgfHwge30sIGRlZmF1bHRPcHRpb25zKTtcblxuICB2YXIgY29udHJvbE1ldGhvZHMgPSB7XG4gICAgbW91c2VWaWV3RHJhZzogbmV3IERyYWdDb250cm9sTWV0aG9kKGVsZW1lbnQsICdtb3VzZScpLFxuICAgIG1vdXNlVmlld1F0dnI6IG5ldyBRdHZyQ29udHJvbE1ldGhvZChlbGVtZW50LCAnbW91c2UnKSxcbiAgICB0b3VjaFZpZXc6IG5ldyBEcmFnQ29udHJvbE1ldGhvZChlbGVtZW50LCAndG91Y2gnKSxcbiAgICBwaW5jaDogbmV3IFBpbmNoWm9vbUNvbnRyb2xNZXRob2QoZWxlbWVudCwgJ3RvdWNoJyksXG5cbiAgICBsZWZ0QXJyb3dLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDM3LCAneCcsIC0wLjcsIDMpLFxuICAgIHJpZ2h0QXJyb3dLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDM5LCAneCcsIDAuNywgMyksXG4gICAgdXBBcnJvd0tleTogbmV3IEtleUNvbnRyb2xNZXRob2QoMzgsICd5JywgLTAuNywgMyksXG4gICAgZG93bkFycm93S2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCg0MCwgJ3knLCAwLjcsIDMpLFxuICAgIHBsdXNLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDEwNywgJ3pvb20nLCAtMC43LCAzKSxcbiAgICBtaW51c0tleTogbmV3IEtleUNvbnRyb2xNZXRob2QoMTA5LCAnem9vbScsIDAuNywgMyksXG5cbiAgICB3S2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCg4NywgJ3knLCAtMC43LCAzKSxcbiAgICBhS2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCg2NSwgJ3gnLCAtMC43LCAzKSxcbiAgICBzS2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCg4MywgJ3knLCAwLjcsIDMpLFxuICAgIGRLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDY4LCAneCcsIDAuNywgMyksXG4gICAgcUtleTogbmV3IEtleUNvbnRyb2xNZXRob2QoODEsICdyb2xsJywgMC43LCAzKSxcbiAgICBlS2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCg2OSwgJ3JvbGwnLCAtMC43LCAzKVxuICB9O1xuXG4gIGlmKG9wdHMuc2Nyb2xsWm9vbSAhPT0gZmFsc2UpIHtcbiAgICBjb250cm9sTWV0aG9kcy5zY3JvbGxab29tID0gbmV3IFNjcm9sbFpvb21Db250cm9sTWV0aG9kKGVsZW1lbnQpOyAvL3sgZnJpY3Rpb25UaW1lOiAwIH1cbiAgfVxuXG4gIHZhciBjb250cm9sTWV0aG9kR3JvdXBzID0ge1xuICAgIGFycm93S2V5czogWyAnbGVmdEFycm93S2V5JywgJ3JpZ2h0QXJyb3dLZXknLCAndXBBcnJvd0tleScsICdkb3duQXJyb3dLZXknIF0sXG4gICAgcGx1c01pbnVzS2V5czogWyAncGx1c0tleScsICdtaW51c0tleScgXSxcbiAgICB3YXNkS2V5czogWyAnd0tleScsICdhS2V5JywgJ3NLZXknLCAnZEtleScgXSxcbiAgICBxZUtleXM6IFsgJ3FLZXknLCAnZUtleScgXVxuICB9O1xuXG5cbiAgdmFyIGVuYWJsZWRDb250cm9scyA9IFsgJ3Njcm9sbFpvb20nLCAndG91Y2hWaWV3JywgJ3BpbmNoJyBdO1xuICBzd2l0Y2ggKG9wdHMubW91c2VWaWV3TW9kZSkge1xuICAgIGNhc2UgJ2RyYWcnOlxuICAgICAgZW5hYmxlZENvbnRyb2xzLnB1c2goJ21vdXNlVmlld0RyYWcnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3F0dnInOlxuICAgICAgZW5hYmxlZENvbnRyb2xzLnB1c2goJ21vdXNlVmlld1F0dnInKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG1vdXNlIHZpZXcgbW9kZTogXCIgKyBvcHRzLm1vdXNlVmlld01vZGUpO1xuICB9XG5cbiAgZm9yICh2YXIgaWQgaW4gY29udHJvbE1ldGhvZHMpIHtcbiAgICB2YXIgbWV0aG9kID0gY29udHJvbE1ldGhvZHNbaWRdO1xuICAgIGNvbnRyb2xzLnJlZ2lzdGVyTWV0aG9kKGlkLCBtZXRob2QpO1xuICAgIGlmIChlbmFibGVkQ29udHJvbHMuaW5kZXhPZihpZCkgPj0gMCkge1xuICAgICAgY29udHJvbHMuZW5hYmxlTWV0aG9kKGlkKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBncm91cElkIGluIGNvbnRyb2xNZXRob2RHcm91cHMpIHtcbiAgICB2YXIgbWV0aG9kR3JvdXAgPSBjb250cm9sTWV0aG9kR3JvdXBzW2dyb3VwSWRdO1xuICAgIGNvbnRyb2xzLmFkZE1ldGhvZEdyb3VwKGdyb3VwSWQsIG1ldGhvZEdyb3VwKTtcbiAgfVxuXG4gIHJldHVybiBjb250cm9sTWV0aG9kcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlckRlZmF1bHRDb250cm9sczsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG1heEZyaWN0aW9uKGZyaWN0aW9uLCB2ZWxvY2l0eVgsIHZlbG9jaXR5WSwgbWF4RnJpY3Rpb25UaW1lLCByZXN1bHQpIHtcbiAgdmFyIHZlbG9jaXR5ID0gTWF0aC5zcXJ0KE1hdGgucG93KHZlbG9jaXR5WCwyKSArIE1hdGgucG93KHZlbG9jaXR5WSwyKSk7XG4gIGZyaWN0aW9uID0gTWF0aC5tYXgoZnJpY3Rpb24sIHZlbG9jaXR5L21heEZyaWN0aW9uVGltZSk7XG4gIGNoYW5nZVZlY3Rvck5vcm0odmVsb2NpdHlYLCB2ZWxvY2l0eVksIGZyaWN0aW9uLCByZXN1bHQpO1xuICByZXN1bHRbMF0gPSBNYXRoLmFicyhyZXN1bHRbMF0pO1xuICByZXN1bHRbMV0gPSBNYXRoLmFicyhyZXN1bHRbMV0pO1xufVxuXG5mdW5jdGlvbiBjaGFuZ2VWZWN0b3JOb3JtKHgsIHksIG4sIHJlc3VsdCkge1xuICB2YXIgdGhldGEgPSBNYXRoLmF0YW4oeS94KTtcbiAgcmVzdWx0WzBdID0gbiAqIE1hdGguY29zKHRoZXRhKTtcbiAgcmVzdWx0WzFdID0gbiAqIE1hdGguc2luKHRoZXRhKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1heEZyaWN0aW9uOiBtYXhGcmljdGlvbixcbiAgY2hhbmdlVmVjdG9yTm9ybTogY2hhbmdlVmVjdG9yTm9ybVxufTsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWwvaW5oZXJpdHMnKTtcbnZhciBoYXNoID0gcmVxdWlyZSgnLi4vdXRpbC9oYXNoJyk7XG52YXIgVGlsZVNlYXJjaGVyID0gcmVxdWlyZSgnLi4vVGlsZVNlYXJjaGVyJyk7XG52YXIgTHJ1TWFwID0gcmVxdWlyZSgnLi4vY29sbGVjdGlvbnMvTHJ1TWFwJyk7XG52YXIgTGV2ZWwgPSByZXF1aXJlKCcuL0xldmVsJyk7XG52YXIgbWFrZUxldmVsTGlzdCA9IHJlcXVpcmUoJy4vY29tbW9uJykubWFrZUxldmVsTGlzdDtcbnZhciBtYWtlU2VsZWN0YWJsZUxldmVsTGlzdCA9IHJlcXVpcmUoJy4vY29tbW9uJykubWFrZVNlbGVjdGFibGVMZXZlbExpc3Q7XG52YXIgY2xhbXAgPSByZXF1aXJlKCcuLi91dGlsL2NsYW1wJyk7XG52YXIgY21wID0gcmVxdWlyZSgnLi4vdXRpbC9jbXAnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi4vdXRpbC90eXBlJyk7XG52YXIgdmVjMyA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLnZlYzM7XG52YXIgdmVjNCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLnZlYzQ7XG5cbnZhciBuZWlnaGJvcnNDYWNoZVNpemUgPSA2NDtcblxuLy8gSW5pdGlhbHMgZm9yIGN1YmUgZmFjZXMuXG52YXIgZmFjZUxpc3QgPSAnZnVkbHJiJztcblxuLy8gUm90YXRpb24gb2YgZWFjaCBmYWNlLCByZWxhdGl2ZSB0byB0aGUgZnJvbnQgZmFjZS5cbnZhciBmYWNlUm90YXRpb24gPSB7XG4gIGY6IHsgeDogMCwgeTogMCB9LFxuICBiOiB7IHg6IDAsIHk6IE1hdGguUEkgfSxcbiAgbDogeyB4OiAwLCB5OiBNYXRoLlBJLzIgfSxcbiAgcjogeyB4OiAwLCB5OiAtTWF0aC5QSS8yIH0sXG4gIHU6IHsgeDogTWF0aC5QSS8yLCB5OiAwIH0sXG4gIGQ6IHsgeDogLU1hdGguUEkvMiwgeTogMCB9XG59O1xuXG4vLyBaZXJvIHZlY3Rvci5cbnZhciBvcmlnaW4gPSB2ZWMzLmNyZWF0ZSgpO1xuXG4vLyBSb3RhdGUgYSB2ZWN0b3IgaW4gWlhZIG9yZGVyLlxuZnVuY3Rpb24gcm90YXRlVmVjdG9yKHZlYywgeiwgeCwgeSkge1xuICBpZiAoeikge1xuICAgIHZlYzMucm90YXRlWih2ZWMsIHZlYywgb3JpZ2luLCB6KTtcbiAgfVxuICBpZiAoeCkge1xuICAgIHZlYzMucm90YXRlWCh2ZWMsIHZlYywgb3JpZ2luLCB4KTtcbiAgfVxuICBpZiAoeSkge1xuICAgIHZlYzMucm90YXRlWSh2ZWMsIHZlYywgb3JpZ2luLCB5KTtcbiAgfVxufVxuXG4vLyBOb3JtYWxpemVkIHZlY3RvcnMgcG9pbnRpbmcgdG8gdGhlIGNlbnRlciBvZiBlYWNoIGZhY2UuXG52YXIgZmFjZVZlY3RvcnMgPSB7fTtcbmZvciAodmFyIGkgPSAwOyBpIDwgZmFjZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgdmFyIGZhY2UgPSBmYWNlTGlzdFtpXTtcbiAgdmFyIHJvdGF0aW9uID0gZmFjZVJvdGF0aW9uW2ZhY2VdO1xuICB2YXIgdiA9IHZlYzMuZnJvbVZhbHVlcygwLCAgMCwgLTEpO1xuICByb3RhdGVWZWN0b3IodiwgMCwgcm90YXRpb24ueCwgcm90YXRpb24ueSk7XG4gIGZhY2VWZWN0b3JzW2ZhY2VdID0gdjtcbn1cblxuLy8gTWFwIGVhY2ggZmFjZSB0byBpdHMgYWRqYWNlbnQgZmFjZXMuXG4vLyBUaGUgb3JkZXIgaXMgYXMgc3VnZ2VzdGVkIGJ5IHRoZSBmcm9udCBmYWNlLlxudmFyIGFkamFjZW50RmFjZSA9IHtcbiAgZjogWyAnbCcsICdyJywgJ3UnLCAnZCcgXSxcbiAgYjogWyAncicsICdsJywgJ3UnLCAnZCcgXSxcbiAgbDogWyAnYicsICdmJywgJ3UnLCAnZCcgXSxcbiAgcjogWyAnZicsICdiJywgJ3UnLCAnZCcgXSxcbiAgdTogWyAnbCcsICdyJywgJ2InLCAnZicgXSxcbiAgZDogWyAnbCcsICdyJywgJ2YnLCAnYicgXVxufTtcblxuLy8gT2Zmc2V0cyB0byBhcHBseSB0byB0aGUgKHgseSkgY29vcmRpbmF0ZXMgb2YgYSB0aWxlIHRvIGdldCBpdHMgbmVpZ2hib3JzLlxudmFyIG5laWdoYm9yT2Zmc2V0cyA9IFtcbiAgWyAgMCwgIDEgXSwgLy8gdG9wXG4gIFsgIDEsICAwIF0sIC8vIHJpZ2h0XG4gIFsgIDAsIC0xIF0sIC8vIGJvdHRvbVxuICBbIC0xLCAgMCBdICAvLyBsZWZ0XG5dO1xuXG5cbi8qKlxuICogQGNsYXNzIEN1YmVUaWxlXG4gKiBAaW1wbGVtZW50cyBUaWxlXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB0aWxlIGluIGEgQHtDdWJlR2VvbWV0cnl9LlxuICovXG5mdW5jdGlvbiBDdWJlVGlsZShmYWNlLCB4LCB5LCB6LCBnZW9tZXRyeSkge1xuICB0aGlzLmZhY2UgPSBmYWNlO1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xuICB0aGlzLnogPSB6O1xuICB0aGlzLl9nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICB0aGlzLl9sZXZlbCA9IGdlb21ldHJ5LmxldmVsTGlzdFt6XTtcbn1cblxuXG5DdWJlVGlsZS5wcm90b3R5cGUucm90WCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmFjZVJvdGF0aW9uW3RoaXMuZmFjZV0ueDtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLnJvdFkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZhY2VSb3RhdGlvblt0aGlzLmZhY2VdLnk7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5jZW50ZXJYID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy54ICsgMC41KSAvIHRoaXMuX2xldmVsLm51bUhvcml6b250YWxUaWxlcygpIC0gMC41O1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUuY2VudGVyWSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMC41IC0gKHRoaXMueSArIDAuNSkgLyB0aGlzLl9sZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCk7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5zY2FsZVggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDEgLyB0aGlzLl9sZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLnNjYWxlWSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMSAvIHRoaXMuX2xldmVsLm51bVZlcnRpY2FsVGlsZXMoKTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLnZlcnRpY2VzID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gW3ZlYzMuY3JlYXRlKCksIHZlYzMuY3JlYXRlKCksIHZlYzMuY3JlYXRlKCksIHZlYzMuY3JlYXRlKCldO1xuICB9XG5cbiAgdmFyIHJvdCA9IGZhY2VSb3RhdGlvblt0aGlzLmZhY2VdO1xuXG4gIGZ1bmN0aW9uIG1ha2VWZXJ0ZXgodmVjLCB4LCB5KSB7XG4gICAgdmVjMy5zZXQodmVjLCB4LCB5LCAtMC41KTtcbiAgICByb3RhdGVWZWN0b3IodmVjLCAwLCByb3QueCwgcm90LnkpO1xuICB9XG5cbiAgdmFyIGxlZnQgPSB0aGlzLmNlbnRlclgoKSAtIHRoaXMuc2NhbGVYKCkgLyAyO1xuICB2YXIgcmlnaHQgPSB0aGlzLmNlbnRlclgoKSArIHRoaXMuc2NhbGVYKCkgLyAyO1xuICB2YXIgYm90dG9tID0gdGhpcy5jZW50ZXJZKCkgLSB0aGlzLnNjYWxlWSgpIC8gMjtcbiAgdmFyIHRvcCA9IHRoaXMuY2VudGVyWSgpICsgdGhpcy5zY2FsZVkoKSAvIDI7XG5cbiAgbWFrZVZlcnRleChyZXN1bHRbMF0sIGxlZnQsIHRvcCk7XG4gIG1ha2VWZXJ0ZXgocmVzdWx0WzFdLCByaWdodCwgdG9wKTtcbiAgbWFrZVZlcnRleChyZXN1bHRbMl0sIHJpZ2h0LCBib3R0b20pO1xuICBtYWtlVmVydGV4KHJlc3VsdFszXSwgbGVmdCwgYm90dG9tKTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMueiA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGZhY2UgPSB0aGlzLmZhY2U7XG4gIHZhciB6ID0gdGhpcy56O1xuICB2YXIgeCA9IHRoaXMueDtcbiAgdmFyIHkgPSB0aGlzLnk7XG5cbiAgdmFyIGdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cnk7XG4gIHZhciBsZXZlbCA9IGdlb21ldHJ5LmxldmVsTGlzdFt6XTtcbiAgdmFyIHBhcmVudExldmVsID0gZ2VvbWV0cnkubGV2ZWxMaXN0W3otMV07XG5cbiAgdmFyIHRpbGVYID0gTWF0aC5mbG9vcih4IC8gbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCkgKiBwYXJlbnRMZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKSk7XG4gIHZhciB0aWxlWSA9IE1hdGguZmxvb3IoeSAvIGxldmVsLm51bVZlcnRpY2FsVGlsZXMoKSAqIHBhcmVudExldmVsLm51bVZlcnRpY2FsVGlsZXMoKSk7XG4gIHZhciB0aWxlWiA9IHotMTtcblxuICByZXR1cm4gbmV3IEN1YmVUaWxlKGZhY2UsIHRpbGVYLCB0aWxlWSwgdGlsZVosIGdlb21ldHJ5KTtcblxufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbihyZXN1bHQpIHtcblxuICBpZiAodGhpcy56ID09PSB0aGlzLl9nZW9tZXRyeS5sZXZlbExpc3QubGVuZ3RoIC0gMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGZhY2UgPSB0aGlzLmZhY2U7XG4gIHZhciB6ID0gdGhpcy56O1xuICB2YXIgeCA9IHRoaXMueDtcbiAgdmFyIHkgPSB0aGlzLnk7XG5cbiAgdmFyIGdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cnk7XG4gIHZhciBsZXZlbCA9IGdlb21ldHJ5LmxldmVsTGlzdFt6XTtcbiAgdmFyIGNoaWxkTGV2ZWwgPSBnZW9tZXRyeS5sZXZlbExpc3RbeisxXTtcblxuICB2YXIgbkhvcml6ID0gY2hpbGRMZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKSAvIGxldmVsLm51bUhvcml6b250YWxUaWxlcygpO1xuICB2YXIgblZlcnQgPSBjaGlsZExldmVsLm51bVZlcnRpY2FsVGlsZXMoKSAvIGxldmVsLm51bVZlcnRpY2FsVGlsZXMoKTtcblxuICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgZm9yICh2YXIgaCA9IDA7IGggPCBuSG9yaXo7IGgrKykge1xuICAgIGZvciAodmFyIHYgPSAwOyB2IDwgblZlcnQ7IHYrKykge1xuICAgICAgdmFyIHRpbGVYID0gbkhvcml6ICogeCArIGg7XG4gICAgICB2YXIgdGlsZVkgPSBuVmVydCAqIHkgKyB2O1xuICAgICAgdmFyIHRpbGVaID0geisxO1xuICAgICAgcmVzdWx0LnB1c2gobmV3IEN1YmVUaWxlKGZhY2UsIHRpbGVYLCB0aWxlWSwgdGlsZVosIGdlb21ldHJ5KSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcblxufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUubmVpZ2hib3JzID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cnk7XG4gIHZhciBjYWNoZSA9IGdlb21ldHJ5Ll9uZWlnaGJvcnNDYWNoZTtcblxuICAvLyBTYXRpc2Z5IGZyb20gY2FjaGUgd2hlbiBhdmFpbGFibGUuXG4gIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZS5nZXQodGhpcyk7XG4gIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICB9XG5cbiAgdmFyIHZlYyA9IGdlb21ldHJ5Ll92ZWM7XG5cbiAgdmFyIGZhY2UgPSB0aGlzLmZhY2U7XG4gIHZhciB4ID0gdGhpcy54O1xuICB2YXIgeSA9IHRoaXMueTtcbiAgdmFyIHogPSB0aGlzLno7XG4gIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsO1xuXG4gIHZhciBudW1YID0gbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCk7XG4gIHZhciBudW1ZID0gbGV2ZWwubnVtVmVydGljYWxUaWxlcygpO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5laWdoYm9yT2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4T2Zmc2V0ID0gbmVpZ2hib3JPZmZzZXRzW2ldWzBdO1xuICAgIHZhciB5T2Zmc2V0ID0gbmVpZ2hib3JPZmZzZXRzW2ldWzFdO1xuXG4gICAgdmFyIG5ld1ggPSB4ICsgeE9mZnNldDtcbiAgICB2YXIgbmV3WSA9IHkgKyB5T2Zmc2V0O1xuICAgIHZhciBuZXdaID0gejtcbiAgICB2YXIgbmV3RmFjZSA9IGZhY2U7XG5cbiAgICBpZiAobmV3WCA8IDAgfHwgbmV3WCA+PSBudW1YIHx8IG5ld1kgPCAwIHx8IG5ld1kgPj0gbnVtWSkge1xuXG4gICAgICAvLyBJZiB0aGUgbmVpZ2hib3JpbmcgdGlsZSBiZWxvbmdzIHRvIGEgZGlmZmVyZW50IGZhY2UsIGNhbGN1bGF0ZSBhXG4gICAgICAvLyB2ZWN0b3IgcG9pbnRpbmcgdG8gdGhlIGVkZ2UgYmV0d2VlbiB0aGUgdHdvIGZhY2VzIGF0IHRoZSBwb2ludCB0aGVcbiAgICAgIC8vIHRpbGUgYW5kIGl0cyBuZWlnaGJvciBtZWV0LCBhbmQgY29udmVydCBpdCBpbnRvIHRpbGUgY29vcmRpbmF0ZXMgZm9yXG4gICAgICAvLyB0aGUgbmVpZ2hib3JpbmcgZmFjZS5cblxuICAgICAgdmFyIHhDb29yZCA9IHRoaXMuY2VudGVyWCgpO1xuICAgICAgdmFyIHlDb29yZCA9IHRoaXMuY2VudGVyWSgpO1xuXG4gICAgICAvLyBGaXJzdCwgY2FsY3VsYXRlIHRoZSB2ZWN0b3IgYXMgaWYgdGhlIGluaXRpYWwgdGlsZSBiZWxvbmdzIHRvIHRoZVxuICAgICAgLy8gZnJvbnQgZmFjZSwgc28gdGhhdCB0aGUgdGlsZSB4LHkgY29vcmRpbmF0ZXMgbWFwIGRpcmVjdGx5IGludG8gdGhlXG4gICAgICAvLyB4LHkgYXhlcy5cblxuICAgICAgaWYgKG5ld1ggPCAwKSB7XG4gICAgICAgIHZlYzMuc2V0KHZlYywgLTAuNSwgeUNvb3JkLCAtMC41KTtcbiAgICAgICAgbmV3RmFjZSA9IGFkamFjZW50RmFjZVtmYWNlXVswXTtcbiAgICAgIH0gZWxzZSBpZiAobmV3WCA+PSBudW1YKSB7XG4gICAgICAgIHZlYzMuc2V0KHZlYywgMC41LCB5Q29vcmQsIC0wLjUpO1xuICAgICAgICBuZXdGYWNlID0gYWRqYWNlbnRGYWNlW2ZhY2VdWzFdO1xuICAgICAgfSBlbHNlIGlmIChuZXdZIDwgMCkge1xuICAgICAgICB2ZWMzLnNldCh2ZWMsIHhDb29yZCwgMC41LCAtMC41KTtcbiAgICAgICAgbmV3RmFjZSA9IGFkamFjZW50RmFjZVtmYWNlXVsyXTtcbiAgICAgIH0gZWxzZSBpZiAobmV3WSA+PSBudW1ZKSB7XG4gICAgICAgIHZlYzMuc2V0KHZlYywgeENvb3JkLCAtMC41LCAtMC41KTtcbiAgICAgICAgbmV3RmFjZSA9IGFkamFjZW50RmFjZVtmYWNlXVszXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJvdDtcblxuICAgICAgLy8gVGhlbiwgcm90YXRlIHRoZSB2ZWN0b3IgaW50byB0aGUgYWN0dWFsIGZhY2UgdGhlIGluaXRpYWwgdGlsZVxuICAgICAgLy8gYmVsb25ncyB0by5cblxuICAgICAgcm90ID0gZmFjZVJvdGF0aW9uW2ZhY2VdO1xuICAgICAgcm90YXRlVmVjdG9yKHZlYywgMCwgcm90LngsIHJvdC55KTtcblxuICAgICAgLy8gRmluYWxseSwgcm90YXRlIHRoZSB2ZWN0b3IgZnJvbSB0aGUgbmVpZ2hib3JpbmcgZmFjZSBpbnRvIHRoZSBmcm9udFxuICAgICAgLy8gZmFjZS4gQWdhaW4sIHRoaXMgaXMgc28gdGhhdCB0aGUgbmVpZ2hib3JpbmcgdGlsZSB4LHkgY29vcmRpbmF0ZXNcbiAgICAgIC8vIG1hcCBkaXJlY3RseSBpbnRvIHRoZSB4LHkgYXhlcy5cblxuICAgICAgcm90ID0gZmFjZVJvdGF0aW9uW25ld0ZhY2VdO1xuICAgICAgcm90YXRlVmVjdG9yKHZlYywgMCwgLXJvdC54LCAtcm90LnkpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIG5laWdoYm9yaW5nIHRpbGUgY29vcmRpbmF0ZXMuXG5cbiAgICAgIG5ld1ggPSBjbGFtcChNYXRoLmZsb29yKCgwLjUgKyB2ZWNbMF0pICogbnVtWCksIDAsIG51bVggLSAxKTtcbiAgICAgIG5ld1kgPSBjbGFtcChNYXRoLmZsb29yKCgwLjUgLSB2ZWNbMV0pICogbnVtWSksIDAsIG51bVkgLSAxKTtcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChuZXcgQ3ViZVRpbGUobmV3RmFjZSwgbmV3WCwgbmV3WSwgbmV3WiwgZ2VvbWV0cnkpKTtcbiAgfVxuXG4gIC8vIFN0b3JlIGludG8gY2FjaGUgdG8gc2F0aXNmeSBmdXR1cmUgcmVxdWVzdHMuXG4gIGNhY2hlLnNldCh0aGlzLCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGhhc2goZmFjZUxpc3QuaW5kZXhPZih0aGlzLmZhY2UpLCB0aGlzLnosIHRoaXMueSwgdGhpcy54KTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHRoYXQpIHtcbiAgcmV0dXJuICh0aGlzLl9nZW9tZXRyeSA9PT0gdGhhdC5fZ2VvbWV0cnkgJiZcbiAgICAgIHRoaXMuZmFjZSA9PT0gdGhhdC5mYWNlICYmXG4gICAgICB0aGlzLnogPT09IHRoYXQueiAmJlxuICAgICAgdGhpcy55ID09PSB0aGF0LnkgJiZcbiAgICAgIHRoaXMueCA9PT0gdGhhdC54KTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uKHRoYXQpIHtcbiAgcmV0dXJuIChjbXAodGhpcy56LCB0aGF0LnopIHx8XG4gIGNtcChmYWNlTGlzdC5pbmRleE9mKHRoaXMuZmFjZSksIGZhY2VMaXN0LmluZGV4T2YodGhhdC5mYWNlKSkgfHxcbiAgY21wKHRoaXMueSwgdGhhdC55KSB8fCBjbXAodGhpcy54LCB0aGF0LngpKTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLnN0ciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ0N1YmVUaWxlKCcgKyB0aWxlLmZhY2UgKyAnLCAnICsgdGlsZS54ICsgJywgJyArIHRpbGUueSArICcsICcgKyB0aWxlLnogKyAnKSc7XG59O1xuXG5cbmZ1bmN0aW9uIEN1YmVMZXZlbChsZXZlbFByb3BlcnRpZXMpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uY2FsbCh0aGlzLCBsZXZlbFByb3BlcnRpZXMpO1xuXG4gIHRoaXMuX3NpemUgPSBsZXZlbFByb3BlcnRpZXMuc2l6ZTtcbiAgdGhpcy5fdGlsZVNpemUgPSBsZXZlbFByb3BlcnRpZXMudGlsZVNpemU7XG5cbiAgaWYgKHRoaXMuX3NpemUgJSB0aGlzLl90aWxlU2l6ZSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTGV2ZWwgc2l6ZSBpcyBub3QgbXVsdGlwbGUgb2YgdGlsZSBzaXplOiAnICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2l6ZSArICcgJyArIHRoaXMuX3RpbGVTaXplKTtcbiAgfVxufVxuXG5pbmhlcml0cyhDdWJlTGV2ZWwsIExldmVsKTtcblxuXG5DdWJlTGV2ZWwucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zaXplO1xufTtcblxuXG5DdWJlTGV2ZWwucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc2l6ZTtcbn07XG5cblxuQ3ViZUxldmVsLnByb3RvdHlwZS50aWxlV2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3RpbGVTaXplO1xufTtcblxuXG5DdWJlTGV2ZWwucHJvdG90eXBlLnRpbGVIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3RpbGVTaXplO1xufTtcblxuXG5DdWJlTGV2ZWwucHJvdG90eXBlLl92YWxpZGF0ZVdpdGhQYXJlbnRMZXZlbCA9IGZ1bmN0aW9uKHBhcmVudExldmVsKSB7XG5cbiAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQoKTtcbiAgdmFyIHRpbGVXaWR0aCA9IHRoaXMudGlsZVdpZHRoKCk7XG4gIHZhciB0aWxlSGVpZ2h0ID0gdGhpcy50aWxlSGVpZ2h0KCk7XG4gIHZhciBudW1Ib3Jpem9udGFsID0gdGhpcy5udW1Ib3Jpem9udGFsVGlsZXMoKTtcbiAgdmFyIG51bVZlcnRpY2FsID0gdGhpcy5udW1WZXJ0aWNhbFRpbGVzKCk7XG5cbiAgdmFyIHBhcmVudFdpZHRoID0gcGFyZW50TGV2ZWwud2lkdGgoKTtcbiAgdmFyIHBhcmVudEhlaWdodCA9IHBhcmVudExldmVsLmhlaWdodCgpO1xuICB2YXIgcGFyZW50VGlsZVdpZHRoID0gcGFyZW50TGV2ZWwudGlsZVdpZHRoKCk7XG4gIHZhciBwYXJlbnRUaWxlSGVpZ2h0ID0gcGFyZW50TGV2ZWwudGlsZUhlaWdodCgpO1xuICB2YXIgcGFyZW50TnVtSG9yaXpvbnRhbCA9IHBhcmVudExldmVsLm51bUhvcml6b250YWxUaWxlcygpO1xuICB2YXIgcGFyZW50TnVtVmVydGljYWwgPSBwYXJlbnRMZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCk7XG5cbiAgaWYgKHdpZHRoICUgcGFyZW50V2lkdGggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xldmVsIHdpZHRoIG11c3QgYmUgbXVsdGlwbGUgb2YgcGFyZW50IGxldmVsOiAnICtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggKyAnIHZzLiAnICsgcGFyZW50V2lkdGgpO1xuICB9XG5cbiAgaWYgKGhlaWdodCAlIHBhcmVudEhlaWdodCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTGV2ZWwgaGVpZ2h0IG11c3QgYmUgbXVsdGlwbGUgb2YgcGFyZW50IGxldmVsOiAnICtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICsgJyB2cy4gJyArIHBhcmVudEhlaWdodCk7XG4gIH1cblxuICBpZiAobnVtSG9yaXpvbnRhbCAlIHBhcmVudE51bUhvcml6b250YWwgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciBvZiBob3Jpem9udGFsIHRpbGVzIG11c3QgYmUgbXVsdGlwbGUgb2YgcGFyZW50IGxldmVsOiAnICtcbiAgICAgIG51bUhvcml6b250YWwgKyBcIiAoXCIgKyB3aWR0aCArICcvJyArIHRpbGVXaWR0aCArICcpJyArIFwiIHZzLiBcIiArXG4gICAgICBwYXJlbnROdW1Ib3Jpem9udGFsICsgXCIgKFwiICsgcGFyZW50V2lkdGggKyAnLycgKyBwYXJlbnRUaWxlV2lkdGggKyAnKScpO1xuICB9XG5cbiAgaWYgKG51bVZlcnRpY2FsICUgcGFyZW50TnVtVmVydGljYWwgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciBvZiB2ZXJ0aWNhbCB0aWxlcyBtdXN0IGJlIG11bHRpcGxlIG9mIHBhcmVudCBsZXZlbDogJyArXG4gICAgICBudW1WZXJ0aWNhbCArIFwiIChcIiArIGhlaWdodCArICcvJyArIHRpbGVIZWlnaHQgKyAnKScgKyBcIiB2cy4gXCIgK1xuICAgICAgcGFyZW50TnVtVmVydGljYWwgKyBcIiAoXCIgKyBwYXJlbnRIZWlnaHQgKyAnLycgKyBwYXJlbnRUaWxlSGVpZ2h0ICsgJyknKTtcbiAgfVxuXG59O1xuXG5cbi8qKlxuICogQGNsYXNzIEN1YmVHZW9tZXRyeVxuICogQGltcGxlbWVudHMgR2VvbWV0cnlcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHtAbGluayBHZW9tZXRyeX0gaW1wbGVtZW50YXRpb24gc3VpdGFibGUgZm9yIHRpbGVkIGN1YmUgaW1hZ2VzIHdpdGhcbiAqIG11bHRpcGxlIHJlc29sdXRpb24gbGV2ZWxzLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zIGFwcGx5OlxuICogICAtIEFsbCB0aWxlcyBpbiBhIGxldmVsIG11c3QgYmUgc3F1YXJlIGFuZCBmb3JtIGEgcmVjdGFuZ3VsYXIgZ3JpZDtcbiAqICAgLSBUaGUgc2l6ZSBvZiBhIGxldmVsIG11c3QgYmUgYSBtdWx0aXBsZSBvZiB0aGUgdGlsZSBzaXplO1xuICogICAtIFRoZSBzaXplIG9mIGEgbGV2ZWwgbXVzdCBiZSBhIG11bHRpcGxlIG9mIHRoZSBwYXJlbnQgbGV2ZWwgc2l6ZTtcbiAqICAgLSBUaGUgbnVtYmVyIG9mIHRpbGVzIGluIGEgbGV2ZWwgbXVzdCBiZSBhIG11bHRpcGxlIG9mIHRoZSBudW1iZXIgb2YgdGlsZXNcbiAqICAgICBpbiB0aGUgcGFyZW50IGxldmVsLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IGxldmVsUHJvcGVydGllc0xpc3QgTGV2ZWwgZGVzY3JpcHRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFByb3BlcnRpZXNMaXN0W10uc2l6ZSBDdWJlIGZhY2Ugc2l6ZSBpbiBwaXhlbHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFByb3BlcnRpZXNMaXN0W10udGlsZVNpemUgVGlsZSBzaXplIGluIHBpeGVsc1xuICovXG5mdW5jdGlvbiBDdWJlR2VvbWV0cnkobGV2ZWxQcm9wZXJ0aWVzTGlzdCkge1xuICBpZiAodHlwZShsZXZlbFByb3BlcnRpZXNMaXN0KSAhPT0gJ2FycmF5Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignTGV2ZWwgbGlzdCBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gIH1cblxuICB0aGlzLmxldmVsTGlzdCA9IG1ha2VMZXZlbExpc3QobGV2ZWxQcm9wZXJ0aWVzTGlzdCwgQ3ViZUxldmVsKTtcbiAgdGhpcy5zZWxlY3RhYmxlTGV2ZWxMaXN0ID0gbWFrZVNlbGVjdGFibGVMZXZlbExpc3QodGhpcy5sZXZlbExpc3QpO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5sZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmxldmVsTGlzdFtpXS5fdmFsaWRhdGVXaXRoUGFyZW50TGV2ZWwodGhpcy5sZXZlbExpc3RbaS0xXSk7XG4gIH1cblxuICB0aGlzLl90aWxlU2VhcmNoZXIgPSBuZXcgVGlsZVNlYXJjaGVyKHRoaXMpO1xuXG4gIHRoaXMuX25laWdoYm9yc0NhY2hlID0gbmV3IExydU1hcChuZWlnaGJvcnNDYWNoZVNpemUpO1xuXG4gIHRoaXMuX3ZlYyA9IHZlYzQuY3JlYXRlKCk7XG5cbiAgdGhpcy5fdmlld1NpemUgPSB7fTtcbn1cblxuXG5DdWJlR2VvbWV0cnkucHJvdG90eXBlLm1heFRpbGVTaXplID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtYXhUaWxlU2l6ZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsTGlzdFtpXTtcbiAgICBtYXhUaWxlU2l6ZSA9IE1hdGgubWF4KG1heFRpbGVTaXplLCBsZXZlbC50aWxlV2lkdGgsIGxldmVsLnRpbGVIZWlnaHQpO1xuICB9XG4gIHJldHVybiBtYXhUaWxlU2l6ZTtcbn07XG5cblxuQ3ViZUdlb21ldHJ5LnByb3RvdHlwZS5sZXZlbFRpbGVzID0gZnVuY3Rpb24obGV2ZWwsIHJlc3VsdCkge1xuXG4gIHZhciBsZXZlbEluZGV4ID0gdGhpcy5sZXZlbExpc3QuaW5kZXhPZihsZXZlbCk7XG4gIHZhciBtYXhYID0gbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCkgLSAxO1xuICB2YXIgbWF4WSA9IGxldmVsLm51bVZlcnRpY2FsVGlsZXMoKSAtIDE7XG5cbiAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuXG4gIGZvciAodmFyIGYgPSAwOyBmIDwgZmFjZUxpc3QubGVuZ3RoOyBmKyspIHtcbiAgICB2YXIgZmFjZSA9IGZhY2VMaXN0W2ZdO1xuICAgIGZvciAodmFyIHggPSAwOyB4IDw9IG1heFg7IHgrKykge1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPD0gbWF4WTsgeSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBDdWJlVGlsZShmYWNlLCB4LCB5LCBsZXZlbEluZGV4LCB0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcblxufTtcblxuXG5DdWJlR2VvbWV0cnkucHJvdG90eXBlLl9jbG9zZXN0VGlsZSA9IGZ1bmN0aW9uKHZpZXcsIGxldmVsKSB7XG4gIHZhciByYXkgPSB0aGlzLl92ZWM7XG5cbiAgLy8gQ29tcHV0ZSBhIHZpZXcgcmF5IGludG8gdGhlIGNlbnRyYWwgc2NyZWVuIHBvaW50LlxuICB2ZWM0LnNldChyYXksIDAsIDAsIDEsIDEpO1xuICB2ZWM0LnRyYW5zZm9ybU1hdDQocmF5LCByYXksIHZpZXcuaW52ZXJzZVByb2plY3Rpb24oKSk7XG5cbiAgdmFyIG1pbkFuZ2xlID0gSW5maW5pdHk7XG4gIHZhciBjbG9zZXN0RmFjZSA9IG51bGw7XG5cbiAgLy8gRmluZCB0aGUgZmFjZSB3aG9zZSB2ZWN0b3IgbWFrZXMgYSBtaW5pbWFsIGFuZ2xlIHdpdGggdGhlIHZpZXcgcmF5LlxuICAvLyBUaGlzIGlzIHRoZSBmYWNlIGludG8gd2hpY2ggdGhlIHZpZXcgcmF5IHBvaW50cy5cbiAgZm9yICh2YXIgZmFjZSBpbiBmYWNlVmVjdG9ycykge1xuICAgIHZhciB2ZWN0b3IgPSBmYWNlVmVjdG9yc1tmYWNlXTtcbiAgICAvLyBGb3IgYSBzbWFsbCBhbmdsZSBiZXR3ZWVuIHR3byBub3JtYWxpemVkIHZlY3RvcnMsIGFuZ2xlIH4gMS1jb3MoYW5nbGUpLlxuICAgIHZhciBhbmdsZSA9IDEgLSB2ZWMzLmRvdCh2ZWN0b3IsIHJheSk7XG4gICAgaWYgKGFuZ2xlIDwgbWluQW5nbGUpIHtcbiAgICAgIG1pbkFuZ2xlID0gYW5nbGU7XG4gICAgICBjbG9zZXN0RmFjZSA9IGZhY2U7XG4gICAgfVxuICB9XG5cbiAgLy8gUHJvamVjdCB2aWV3IHJheSBvbnRvIGN1YmUsIGkuZS4sIG5vcm1hbGl6ZSB0aGUgY29vcmRpbmF0ZSB3aXRoXG4gIC8vIGxhcmdlc3QgYWJzb2x1dGUgdmFsdWUgdG8gwrEwLjUuXG4gIHZhciBtYXggPSBNYXRoLm1heChNYXRoLmFicyhyYXlbMF0pLCBNYXRoLmFicyhyYXlbMV0pLCBNYXRoLmFicyhyYXlbMl0pKSAvIDAuNTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICByYXlbaV0gPSByYXlbaV0gLyBtYXg7XG4gIH1cblxuICAvLyBSb3RhdGUgdmlldyByYXkgaW50byBmcm9udCBmYWNlLlxuICB2YXIgcm90ID0gZmFjZVJvdGF0aW9uW2Nsb3Nlc3RGYWNlXTtcbiAgcm90YXRlVmVjdG9yKHJheSwgMCwgLXJvdC54LCAtcm90LnkpO1xuXG4gIC8vIEdldCB0aGUgZGVzaXJlZCB6b29tIGxldmVsLlxuICB2YXIgdGlsZVogPSB0aGlzLmxldmVsTGlzdC5pbmRleE9mKGxldmVsKTtcbiAgdmFyIG51bVggPSBsZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKTtcbiAgdmFyIG51bVkgPSBsZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCk7XG5cbiAgLy8gRmluZCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHRpbGUgdGhhdCB0aGUgdmlldyByYXkgcG9pbnRzIGludG8uXG4gIHZhciB0aWxlWCA9IGNsYW1wKE1hdGguZmxvb3IoKDAuNSArIHJheVswXSkgKiBudW1YKSwgMCwgbnVtWCAtIDEpO1xuICB2YXIgdGlsZVkgPSBjbGFtcChNYXRoLmZsb29yKCgwLjUgLSByYXlbMV0pICogbnVtWSksIDAsIG51bVkgLSAxKTtcblxuICByZXR1cm4gbmV3IEN1YmVUaWxlKGNsb3Nlc3RGYWNlLCB0aWxlWCwgdGlsZVksIHRpbGVaLCB0aGlzKTtcbn07XG5cblxuQ3ViZUdlb21ldHJ5LnByb3RvdHlwZS52aXNpYmxlVGlsZXMgPSBmdW5jdGlvbih2aWV3LCBsZXZlbCwgcmVzdWx0KSB7XG4gIHZhciB2aWV3U2l6ZSA9IHRoaXMuX3ZpZXdTaXplO1xuICB2YXIgdGlsZVNlYXJjaGVyID0gdGhpcy5fdGlsZVNlYXJjaGVyO1xuXG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICB2aWV3LnNpemUodmlld1NpemUpO1xuICBpZiAodmlld1NpemUud2lkdGggPT09IDAgfHwgdmlld1NpemUuaGVpZ2h0ID09PSAwKSB7XG4gICAgLy8gTm8gdGlsZXMgYXJlIHZpc2libGUgaWYgdGhlIHZpZXdwb3J0IGlzIGVtcHR5LlxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgc3RhcnRpbmdUaWxlID0gdGhpcy5fY2xvc2VzdFRpbGUodmlldywgbGV2ZWwpO1xuICB2YXIgY291bnQgPSB0aWxlU2VhcmNoZXIuc2VhcmNoKHZpZXcsIHN0YXJ0aW5nVGlsZSwgcmVzdWx0KTtcbiAgaWYgKCFjb3VudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3RhcnRpbmcgdGlsZSBpcyBub3QgdmlzaWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuQ3ViZUdlb21ldHJ5LlRpbGUgPSBDdWJlR2VvbWV0cnkucHJvdG90eXBlLlRpbGUgPSBDdWJlVGlsZTtcbkN1YmVHZW9tZXRyeS50eXBlID0gQ3ViZUdlb21ldHJ5LnByb3RvdHlwZS50eXBlID0gJ2N1YmUnO1xuQ3ViZVRpbGUudHlwZSA9IEN1YmVUaWxlLnByb3RvdHlwZS50eXBlID0gJ2N1YmUnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ3ViZUdlb21ldHJ5O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlsL2luaGVyaXRzJyk7XG52YXIgaGFzaCA9IHJlcXVpcmUoJy4uL3V0aWwvaGFzaCcpO1xudmFyIGNtcCA9IHJlcXVpcmUoJy4uL3V0aWwvY21wJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbnZhciBMZXZlbCA9IHJlcXVpcmUoJy4vTGV2ZWwnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi4vdXRpbC90eXBlJyk7XG5cblxuLyoqXG4gKiBAY2xhc3MgRXF1aXJlY3RUaWxlXG4gKiBAaW1wbGVtZW50cyBUaWxlXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB0aWxlIGluIGFuIEB7RXF1aXJlY3RHZW9tZXRyeX0uXG4gKi9cbmZ1bmN0aW9uIEVxdWlyZWN0VGlsZSh6LCBnZW9tZXRyeSkge1xuICB0aGlzLnogPSB6O1xuICB0aGlzLl9nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICB0aGlzLl9sZXZlbCA9IGdlb21ldHJ5LmxldmVsTGlzdFt6XTtcbn1cblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLnJvdFggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUucm90WSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMDtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5jZW50ZXJYID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwLjU7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuY2VudGVyWSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMC41O1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLnNjYWxlWCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5zY2FsZVkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDE7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnogPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbmV3IEVxdWlyZWN0VGlsZSh0aGlzLnogLSAxLCB0aGlzLl9nZW9tZXRyeSk7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgaWYgKHRoaXMueiA9PT0gdGhpcy5fZ2VvbWV0cnkubGV2ZWxMaXN0Lmxlbmd0aCAtIDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXN1bHQgPSByZXN1bHQgfHwgW107XG4gIHJlc3VsdC5wdXNoKG5ldyBFcXVpcmVjdFRpbGUodGhpcy56ICsgMSwgdGhpcy5fZ2VvbWV0cnkpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5uZWlnaGJvcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFtdO1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGhhc2godGhpcy56KTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbih0aGF0KSB7XG4gIHJldHVybiB0aGlzLl9nZW9tZXRyeSA9PT0gdGhhdC5fZ2VvbWV0cnkgJiYgdGhpcy56ID09PSB0aGF0Lno7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24odGhhdCkge1xuICByZXR1cm4gY21wKHRoaXMueiwgdGhhdC56KTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5zdHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdFcXVpcmVjdFRpbGUoJyArIHRpbGUueiArICcpJztcbn07XG5cblxuZnVuY3Rpb24gRXF1aXJlY3RMZXZlbChsZXZlbFByb3BlcnRpZXMpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uY2FsbCh0aGlzLCBsZXZlbFByb3BlcnRpZXMpO1xuICB0aGlzLl93aWR0aCA9IGxldmVsUHJvcGVydGllcy53aWR0aDtcbn1cblxuaW5oZXJpdHMoRXF1aXJlY3RMZXZlbCwgTGV2ZWwpO1xuXG5cbkVxdWlyZWN0TGV2ZWwucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aDtcbn07XG5cblxuRXF1aXJlY3RMZXZlbC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aC8yO1xufTtcblxuXG5FcXVpcmVjdExldmVsLnByb3RvdHlwZS50aWxlV2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3dpZHRoO1xufTtcblxuXG5FcXVpcmVjdExldmVsLnByb3RvdHlwZS50aWxlSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aC8yO1xufTtcblxuXG4vKipcbiAqIEBjbGFzcyBFcXVpcmVjdEdlb21ldHJ5XG4gKiBAaW1wbGVtZW50cyBHZW9tZXRyeVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEge0BsaW5rIEdlb21ldHJ5fSBpbXBsZW1lbnRhdGlvbiBzdWl0YWJsZSBmb3IgZXF1aXJlY3Rhbmd1bGFyIGltYWdlcyB3aXRoIGFcbiAqIDI6MSBhc3BlY3QgcmF0aW8uXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gbGV2ZWxQcm9wZXJ0aWVzTGlzdCBMZXZlbCBkZXNjcmlwdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsUHJvcGVydGllc0xpc3RbXS53aWR0aCBMZXZlbCB3aWR0aCBpbiBwaXhlbHNcbiovXG5mdW5jdGlvbiBFcXVpcmVjdEdlb21ldHJ5KGxldmVsUHJvcGVydGllc0xpc3QpIHtcbiAgaWYgKHR5cGUobGV2ZWxQcm9wZXJ0aWVzTGlzdCkgIT09ICdhcnJheScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xldmVsIGxpc3QgbXVzdCBiZSBhbiBhcnJheScpO1xuICB9XG5cbiAgdGhpcy5sZXZlbExpc3QgPSBjb21tb24ubWFrZUxldmVsTGlzdChsZXZlbFByb3BlcnRpZXNMaXN0LCBFcXVpcmVjdExldmVsKTtcbiAgdGhpcy5zZWxlY3RhYmxlTGV2ZWxMaXN0ID0gY29tbW9uLm1ha2VTZWxlY3RhYmxlTGV2ZWxMaXN0KHRoaXMubGV2ZWxMaXN0KTtcbn1cblxuXG5FcXVpcmVjdEdlb21ldHJ5LnByb3RvdHlwZS5tYXhUaWxlU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWF4VGlsZVNpemUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbExpc3RbaV07XG4gICAgbWF4VGlsZVNpemUgPSBNYXRoLm1heChtYXhUaWxlU2l6ZSwgbGV2ZWwudGlsZVdpZHRoLCBsZXZlbC50aWxlSGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gbWF4VGlsZVNpemU7XG59O1xuXG5cbkVxdWlyZWN0R2VvbWV0cnkucHJvdG90eXBlLmxldmVsVGlsZXMgPSBmdW5jdGlvbihsZXZlbCwgcmVzdWx0KSB7XG4gIHZhciBsZXZlbEluZGV4ID0gdGhpcy5sZXZlbExpc3QuaW5kZXhPZihsZXZlbCk7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcbiAgcmVzdWx0LnB1c2gobmV3IEVxdWlyZWN0VGlsZShsZXZlbEluZGV4LCB0aGlzKSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbkVxdWlyZWN0R2VvbWV0cnkucHJvdG90eXBlLnZpc2libGVUaWxlcyA9IGZ1bmN0aW9uKHZpZXcsIGxldmVsLCByZXN1bHQpIHtcbiAgdmFyIHRpbGUgPSBuZXcgRXF1aXJlY3RUaWxlKHRoaXMubGV2ZWxMaXN0LmluZGV4T2YobGV2ZWwpLCB0aGlzKTtcbiAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuICByZXN1bHQubGVuZ3RoID0gMDtcbiAgcmVzdWx0LnB1c2godGlsZSk7XG59O1xuXG5cbkVxdWlyZWN0R2VvbWV0cnkuVGlsZSA9IEVxdWlyZWN0R2VvbWV0cnkucHJvdG90eXBlLlRpbGUgPSBFcXVpcmVjdFRpbGU7XG5FcXVpcmVjdEdlb21ldHJ5LnR5cGUgPSBFcXVpcmVjdEdlb21ldHJ5LnByb3RvdHlwZS50eXBlID0gJ2VxdWlyZWN0JztcbkVxdWlyZWN0VGlsZS50eXBlID0gRXF1aXJlY3RUaWxlLnByb3RvdHlwZS50eXBlID0gJ2VxdWlyZWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWlyZWN0R2VvbWV0cnk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWwvaW5oZXJpdHMnKTtcbnZhciBoYXNoID0gcmVxdWlyZSgnLi4vdXRpbC9oYXNoJyk7XG52YXIgVGlsZVNlYXJjaGVyID0gcmVxdWlyZSgnLi4vVGlsZVNlYXJjaGVyJyk7XG52YXIgTHJ1TWFwID0gcmVxdWlyZSgnLi4vY29sbGVjdGlvbnMvTHJ1TWFwJyk7XG52YXIgTGV2ZWwgPSByZXF1aXJlKCcuL0xldmVsJyk7XG52YXIgbWFrZUxldmVsTGlzdCA9IHJlcXVpcmUoJy4vY29tbW9uJykubWFrZUxldmVsTGlzdDtcbnZhciBtYWtlU2VsZWN0YWJsZUxldmVsTGlzdCA9IHJlcXVpcmUoJy4vY29tbW9uJykubWFrZVNlbGVjdGFibGVMZXZlbExpc3Q7XG52YXIgY2xhbXAgPSByZXF1aXJlKCcuLi91dGlsL2NsYW1wJyk7XG52YXIgbW9kID0gcmVxdWlyZSgnLi4vdXRpbC9tb2QnKTtcbnZhciBjbXAgPSByZXF1aXJlKCcuLi91dGlsL2NtcCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuLi91dGlsL3R5cGUnKTtcbnZhciB2ZWMyID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjMjtcbnZhciB2ZWM0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjNDtcblxudmFyIG5laWdoYm9yc0NhY2hlU2l6ZSA9IDY0O1xuXG4vLyBPZmZzZXRzIHRvIGFwcGx5IHRvIHRoZSAoeCx5KSBjb29yZGluYXRlcyBvZiBhIHRpbGUgdG8gZ2V0IGl0cyBuZWlnaGJvcnMuXG52YXIgbmVpZ2hib3JPZmZzZXRzID0gW1xuICBbICAwLCAgMSBdLCAvLyB0b3BcbiAgWyAgMSwgIDAgXSwgLy8gcmlnaHRcbiAgWyAgMCwgLTEgXSwgLy8gYm90dG9tXG4gIFsgLTEsICAwIF0gIC8vIGxlZnRcbl07XG5cblxuLyoqXG4gKiBAY2xhc3MgRmxhdFRpbGVcbiAqIEBpbXBsZW1lbnRzIFRpbGVcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHRpbGUgaW4gYSB7QGxpbmsgRmxhdEdlb21ldHJ5fS5cbiAqL1xuZnVuY3Rpb24gRmxhdFRpbGUoeCwgeSwgeiwgZ2VvbWV0cnkpIHtcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbiAgdGhpcy56ID0gejtcbiAgdGhpcy5fZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgdGhpcy5fbGV2ZWwgPSBnZW9tZXRyeS5sZXZlbExpc3Rbel07XG59XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLnJvdFggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5yb3RZID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwO1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUuY2VudGVyWCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGV2ZWxXaWR0aCA9IHRoaXMuX2xldmVsLndpZHRoKCk7XG4gIHZhciB0aWxlV2lkdGggPSB0aGlzLl9sZXZlbC50aWxlV2lkdGgoKTtcbiAgcmV0dXJuICh0aGlzLnggKiB0aWxlV2lkdGggKyAwLjUgKiB0aGlzLndpZHRoKCkpIC8gbGV2ZWxXaWR0aCAtIDAuNTtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmNlbnRlclkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxldmVsSGVpZ2h0ID0gdGhpcy5fbGV2ZWwuaGVpZ2h0KCk7XG4gIHZhciB0aWxlSGVpZ2h0ID0gdGhpcy5fbGV2ZWwudGlsZUhlaWdodCgpO1xuICByZXR1cm4gMC41IC0gKHRoaXMueSAqIHRpbGVIZWlnaHQgKyAwLjUgKiB0aGlzLmhlaWdodCgpKSAvIGxldmVsSGVpZ2h0O1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUuc2NhbGVYID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsZXZlbFdpZHRoID0gdGhpcy5fbGV2ZWwud2lkdGgoKTtcbiAgcmV0dXJuIHRoaXMud2lkdGgoKSAvIGxldmVsV2lkdGg7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5zY2FsZVkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxldmVsSGVpZ2h0ID0gdGhpcy5fbGV2ZWwuaGVpZ2h0KCk7XG4gIHJldHVybiB0aGlzLmhlaWdodCgpIC8gbGV2ZWxIZWlnaHQ7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGV2ZWxXaWR0aCA9IHRoaXMuX2xldmVsLndpZHRoKCk7XG4gIHZhciB0aWxlV2lkdGggPSB0aGlzLl9sZXZlbC50aWxlV2lkdGgoKTtcbiAgaWYgKHRoaXMueCA9PT0gdGhpcy5fbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCkgLSAxKSB7XG4gICAgdmFyIHdpZHRoUmVtYWluZGVyID0gbW9kKGxldmVsV2lkdGgsIHRpbGVXaWR0aCk7XG4gICAgcmV0dXJuIHdpZHRoUmVtYWluZGVyIHx8IHRpbGVXaWR0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGlsZVdpZHRoO1xuICB9XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxldmVsSGVpZ2h0ID0gdGhpcy5fbGV2ZWwuaGVpZ2h0KCk7XG4gIHZhciB0aWxlSGVpZ2h0ID0gdGhpcy5fbGV2ZWwudGlsZUhlaWdodCgpO1xuICBpZiAodGhpcy55ID09PSB0aGlzLl9sZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCkgLSAxKSB7XG4gICAgdmFyIGhlaWdodFJlbWFpbmRlciA9IG1vZChsZXZlbEhlaWdodCwgdGlsZUhlaWdodCk7XG4gICAgcmV0dXJuIGhlaWdodFJlbWFpbmRlciB8fCB0aWxlSGVpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aWxlSGVpZ2h0O1xuICB9XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5sZXZlbFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9sZXZlbC53aWR0aCgpO1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUubGV2ZWxIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xldmVsLmhlaWdodCgpO1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUudmVydGljZXMgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSBbdmVjMi5jcmVhdGUoKSwgdmVjMi5jcmVhdGUoKSwgdmVjMi5jcmVhdGUoKSwgdmVjMi5jcmVhdGUoKV07XG4gIH1cblxuICB2YXIgbGVmdCA9IHRoaXMuY2VudGVyWCgpIC0gdGhpcy5zY2FsZVgoKSAvIDI7XG4gIHZhciByaWdodCA9IHRoaXMuY2VudGVyWCgpICsgdGhpcy5zY2FsZVgoKSAvIDI7XG4gIHZhciBib3R0b20gPSB0aGlzLmNlbnRlclkoKSAtIHRoaXMuc2NhbGVZKCkgLyAyO1xuICB2YXIgdG9wID0gdGhpcy5jZW50ZXJZKCkgKyB0aGlzLnNjYWxlWSgpIC8gMjtcblxuICB2ZWMyLnNldChyZXN1bHRbMF0sIGxlZnQsIHRvcCk7XG4gIHZlYzIuc2V0KHJlc3VsdFsxXSwgcmlnaHQsIHRvcCk7XG4gIHZlYzIuc2V0KHJlc3VsdFsyXSwgcmlnaHQsIGJvdHRvbSk7XG4gIHZlYzIuc2V0KHJlc3VsdFszXSwgbGVmdCwgYm90dG9tKTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24oKSB7XG5cblxuICBpZiAodGhpcy56ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcblxuICB2YXIgeiA9IHRoaXMueiAtIDE7XG4gIC8vIFRPRE86IEN1cnJlbnRseSBhc3N1bWluZyBlYWNoIGxldmVsIGlzIGRvdWJsZSB0aGUgc2l6ZSBvZiBwcmV2aW91cyBvbmUuXG4gIC8vIEZpeCB0byBzdXBwb3J0IG90aGVyIG11bHRpcGxlcy5cbiAgdmFyIHggPSBNYXRoLmZsb29yKHRoaXMueCAvIDIpO1xuICB2YXIgeSA9IE1hdGguZmxvb3IodGhpcy55IC8gMik7XG5cbiAgcmV0dXJuIG5ldyBGbGF0VGlsZSh4LCB5LCB6LCBnZW9tZXRyeSk7XG5cbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gIGlmICh0aGlzLnogPT09IHRoaXMuX2dlb21ldHJ5LmxldmVsTGlzdC5sZW5ndGggLSAxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcbiAgdmFyIHogPSB0aGlzLnogKyAxO1xuXG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICAvLyBUT0RPOiBDdXJyZW50bHkgYXNzdW1pbmcgZWFjaCBsZXZlbCBpcyBkb3VibGUgdGhlIHNpemUgb2YgcHJldmlvdXMgb25lLlxuICAvLyBGaXggdG8gc3VwcG9ydCBvdGhlciBtdWx0aXBsZXMuXG4gIHJlc3VsdC5wdXNoKG5ldyBGbGF0VGlsZSgyKnRoaXMueCAgLCAyKnRoaXMueSAgLCB6LCBnZW9tZXRyeSkpO1xuICByZXN1bHQucHVzaChuZXcgRmxhdFRpbGUoMip0aGlzLnggICwgMip0aGlzLnkrMSwgeiwgZ2VvbWV0cnkpKTtcbiAgcmVzdWx0LnB1c2gobmV3IEZsYXRUaWxlKDIqdGhpcy54KzEsIDIqdGhpcy55ICAsIHosIGdlb21ldHJ5KSk7XG4gIHJlc3VsdC5wdXNoKG5ldyBGbGF0VGlsZSgyKnRoaXMueCsxLCAyKnRoaXMueSsxLCB6LCBnZW9tZXRyeSkpO1xuXG4gIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLm5laWdoYm9ycyA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IHRoaXMuX2dlb21ldHJ5O1xuICB2YXIgY2FjaGUgPSBnZW9tZXRyeS5fbmVpZ2hib3JzQ2FjaGU7XG5cbiAgLy8gU2F0aXNmeSBmcm9tIGNhY2hlIHdoZW4gYXZhaWxhYmxlLlxuICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGUuZ2V0KHRoaXMpO1xuICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgfVxuXG4gIHZhciB4ID0gdGhpcy54O1xuICB2YXIgeSA9IHRoaXMueTtcbiAgdmFyIHogPSB0aGlzLno7XG4gIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsO1xuXG4gIHZhciBudW1YID0gbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCkgLSAxO1xuICB2YXIgbnVtWSA9IGxldmVsLm51bVZlcnRpY2FsVGlsZXMoKSAtIDE7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JPZmZzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHhPZmZzZXQgPSBuZWlnaGJvck9mZnNldHNbaV1bMF07XG4gICAgdmFyIHlPZmZzZXQgPSBuZWlnaGJvck9mZnNldHNbaV1bMV07XG5cbiAgICB2YXIgbmV3WCA9IHggKyB4T2Zmc2V0O1xuICAgIHZhciBuZXdZID0geSArIHlPZmZzZXQ7XG4gICAgdmFyIG5ld1ogPSB6O1xuXG4gICAgaWYgKDAgPD0gbmV3WCAmJiBuZXdYIDw9IG51bVggJiYgMCA8PSBuZXdZICYmIG5ld1kgPD0gbnVtWSkge1xuICAgICAgcmVzdWx0LnB1c2gobmV3IEZsYXRUaWxlKG5ld1gsIG5ld1ksIG5ld1osIGdlb21ldHJ5KSk7XG4gICAgfVxuICB9XG5cbiAgLy8gU3RvcmUgaW50byBjYWNoZSB0byBzYXRpc2Z5IGZ1dHVyZSByZXF1ZXN0cy5cbiAgY2FjaGUuc2V0KHRoaXMsIHJlc3VsdCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcblxufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaGFzaCh0aGlzLnosIHRoaXMueSwgdGhpcy54KTtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHRoYXQpIHtcbiAgcmV0dXJuICh0aGlzLl9nZW9tZXRyeSA9PT0gdGhhdC5fZ2VvbWV0cnkgJiZcbiAgICAgIHRoaXMueiA9PT0gdGhhdC56ICYmIHRoaXMueSA9PT0gdGhhdC55ICYmIHRoaXMueCA9PT0gdGhhdC54KTtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uKHRoYXQpIHtcbiAgcmV0dXJuIChjbXAodGhpcy56LCB0aGF0LnopIHx8IGNtcCh0aGlzLnksIHRoYXQueSkgfHwgY21wKHRoaXMueCwgdGhhdC54KSk7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5zdHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdGbGF0VGlsZSgnICsgdGlsZS54ICsgJywgJyArIHRpbGUueSArICcsICcgKyB0aWxlLnogKyAnKSc7XG59O1xuXG5cbmZ1bmN0aW9uIEZsYXRMZXZlbChsZXZlbFByb3BlcnRpZXMpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uY2FsbCh0aGlzLCBsZXZlbFByb3BlcnRpZXMpO1xuXG4gIHRoaXMuX3dpZHRoID0gbGV2ZWxQcm9wZXJ0aWVzLndpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBsZXZlbFByb3BlcnRpZXMuaGVpZ2h0O1xuICB0aGlzLl90aWxlV2lkdGggPSBsZXZlbFByb3BlcnRpZXMudGlsZVdpZHRoO1xuICB0aGlzLl90aWxlSGVpZ2h0ID0gbGV2ZWxQcm9wZXJ0aWVzLnRpbGVIZWlnaHQ7XG59XG5cbmluaGVyaXRzKEZsYXRMZXZlbCwgTGV2ZWwpO1xuXG5cbkZsYXRMZXZlbC5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3dpZHRoO1xufTtcblxuXG5GbGF0TGV2ZWwucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faGVpZ2h0O1xufTtcblxuXG5GbGF0TGV2ZWwucHJvdG90eXBlLnRpbGVXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdGlsZVdpZHRoO1xufTtcblxuXG5GbGF0TGV2ZWwucHJvdG90eXBlLnRpbGVIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3RpbGVIZWlnaHQ7XG59O1xuXG5cbkZsYXRMZXZlbC5wcm90b3R5cGUuX3ZhbGlkYXRlV2l0aFBhcmVudExldmVsID0gZnVuY3Rpb24ocGFyZW50TGV2ZWwpIHtcblxuICB2YXIgd2lkdGggPSB0aGlzLndpZHRoKCk7XG4gIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCgpO1xuICB2YXIgdGlsZVdpZHRoID0gdGhpcy50aWxlV2lkdGgoKTtcbiAgdmFyIHRpbGVIZWlnaHQgPSB0aGlzLnRpbGVIZWlnaHQoKTtcblxuICB2YXIgcGFyZW50V2lkdGggPSBwYXJlbnRMZXZlbC53aWR0aCgpO1xuICB2YXIgcGFyZW50SGVpZ2h0ID0gcGFyZW50TGV2ZWwuaGVpZ2h0KCk7XG4gIHZhciBwYXJlbnRUaWxlV2lkdGggPSBwYXJlbnRMZXZlbC50aWxlV2lkdGgoKTtcbiAgdmFyIHBhcmVudFRpbGVIZWlnaHQgPSBwYXJlbnRMZXZlbC50aWxlSGVpZ2h0KCk7XG5cbiAgaWYgKHdpZHRoICUgcGFyZW50V2lkdGggIT09IDApIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdMZXZlbCB3aWR0aCBtdXN0IGJlIG11bHRpcGxlIG9mIHBhcmVudCBsZXZlbDogJyArXG4gICAgICAgICAgICAgICAgICAgICB3aWR0aCArICcgdnMuICcgKyBwYXJlbnRXaWR0aCk7XG4gIH1cblxuICBpZiAoaGVpZ2h0ICUgcGFyZW50SGVpZ2h0ICE9PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignTGV2ZWwgaGVpZ2h0IG11c3QgYmUgbXVsdGlwbGUgb2YgcGFyZW50IGxldmVsOiAnICtcbiAgICAgICAgICAgICAgICAgICAgIGhlaWdodCArICcgdnMuICcgKyBwYXJlbnRIZWlnaHQpO1xuICB9XG5cbiAgaWYgKHRpbGVXaWR0aCAlIHBhcmVudFRpbGVXaWR0aCAhPT0gMCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0xldmVsIHRpbGUgd2lkdGggbXVzdCBiZSBtdWx0aXBsZSBvZiBwYXJlbnQgbGV2ZWw6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgdGlsZVdpZHRoICsgJyB2cy4gJyArIHBhcmVudFRpbGVXaWR0aCk7XG4gIH1cblxuICBpZiAodGlsZUhlaWdodCAlIHBhcmVudFRpbGVIZWlnaHQgIT09IDApIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdMZXZlbCB0aWxlIGhlaWdodCBtdXN0IGJlIG11bHRpcGxlIG9mIHBhcmVudCBsZXZlbDogJyArXG4gICAgICAgICAgICAgICAgICAgICB0aWxlSGVpZ2h0ICsgJyB2cy4gJyArIHBhcmVudFRpbGVIZWlnaHQpO1xuICB9XG5cbn07XG5cblxuLyoqXG4gKiBAY2xhc3MgRmxhdEdlb21ldHJ5XG4gKiBAaW1wbGVtZW50cyBHZW9tZXRyeVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEge0BsaW5rIEdlb21ldHJ5fSBpbXBsZW1lbnRhdGlvbiBzdWl0YWJsZSBmb3IgdGlsZWQgZmxhdCBpbWFnZXMgd2l0aFxuICogbXVsdGlwbGUgcmVzb2x1dGlvbiBsZXZlbHMuXG4gKlxuICogVGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnMgYXBwbHk6XG4gKiAgIC0gQWxsIHRpbGVzIG11c3QgYmUgc3F1YXJlLCBleGNlcHQgd2hlbiBpbiB0aGUgbGFzdCByb3cgb3IgY29sdW1uIHBvc2l0aW9uLFxuICogICAgIGFuZCBtdXN0IGZvcm0gYSByZWN0YW5ndWxhciBncmlkO1xuICogICAtIFRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIGEgbGV2ZWwgbXVzdCBiZSBtdWx0aXBsZXMgb2YgdGhlIHBhcmVudCBsZXZlbFxuICogICAgIHdpZHRoIGFuZCBoZWlnaHQuXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gbGV2ZWxQcm9wZXJ0aWVzTGlzdCBMZXZlbCBkZXNjcmlwdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsUHJvcGVydGllc0xpc3RbXS53aWR0aCBMZXZlbCB3aWR0aCBpbiBwaXhlbHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFByb3BlcnRpZXNMaXN0W10udGlsZVdpZHRoIFRpbGUgd2lkdGggaW4gcGl4ZWxzIGZvclxuICogICAgICAgICAgICAgICAgIHNxdWFyZSB0aWxlc1xuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsUHJvcGVydGllc0xpc3RbXS5oZWlnaHQgTGV2ZWwgaGVpZ2h0IGluIHBpeGVsc1xuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsUHJvcGVydGllc0xpc3RbXS50aWxlSGVpZ2h0IFRpbGUgaGVpZ2h0IGluIHBpeGVscyBmb3JcbiAqICAgICAgICAgICAgICAgICBzcXVhcmUgdGlsZXNcbiAqL1xuZnVuY3Rpb24gRmxhdEdlb21ldHJ5KGxldmVsUHJvcGVydGllc0xpc3QpIHtcbiAgaWYgKHR5cGUobGV2ZWxQcm9wZXJ0aWVzTGlzdCkgIT09ICdhcnJheScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xldmVsIGxpc3QgbXVzdCBiZSBhbiBhcnJheScpO1xuICB9XG5cbiAgdGhpcy5sZXZlbExpc3QgPSBtYWtlTGV2ZWxMaXN0KGxldmVsUHJvcGVydGllc0xpc3QsIEZsYXRMZXZlbCk7XG4gIHRoaXMuc2VsZWN0YWJsZUxldmVsTGlzdCA9IG1ha2VTZWxlY3RhYmxlTGV2ZWxMaXN0KHRoaXMubGV2ZWxMaXN0KTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5sZXZlbExpc3RbaV0uX3ZhbGlkYXRlV2l0aFBhcmVudExldmVsKHRoaXMubGV2ZWxMaXN0W2ktMV0pO1xuICB9XG5cbiAgdGhpcy5fdGlsZVNlYXJjaGVyID0gbmV3IFRpbGVTZWFyY2hlcih0aGlzKTtcblxuICB0aGlzLl9uZWlnaGJvcnNDYWNoZSA9IG5ldyBMcnVNYXAobmVpZ2hib3JzQ2FjaGVTaXplKTtcblxuICB0aGlzLl92ZWMgPSB2ZWM0LmNyZWF0ZSgpO1xuXG4gIHRoaXMuX3ZpZXdTaXplID0ge307XG59XG5cblxuRmxhdEdlb21ldHJ5LnByb3RvdHlwZS5tYXhUaWxlU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWF4VGlsZVNpemUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbExpc3RbaV07XG4gICAgbWF4VGlsZVNpemUgPSBNYXRoLm1heChtYXhUaWxlU2l6ZSwgbGV2ZWwudGlsZVdpZHRoLCBsZXZlbC50aWxlSGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gbWF4VGlsZVNpemU7XG59O1xuXG5cbkZsYXRHZW9tZXRyeS5wcm90b3R5cGUubGV2ZWxUaWxlcyA9IGZ1bmN0aW9uKGxldmVsLCByZXN1bHQpIHtcblxuICB2YXIgbGV2ZWxJbmRleCA9IHRoaXMubGV2ZWxMaXN0LmluZGV4T2YobGV2ZWwpO1xuICB2YXIgbWF4WCA9IGxldmVsLm51bUhvcml6b250YWxUaWxlcygpIC0gMTtcbiAgdmFyIG1heFkgPSBsZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCkgLSAxO1xuXG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gW107XG4gIH1cblxuICBmb3IgKHZhciB4ID0gMDsgeCA8PSBtYXhYOyB4KyspIHtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8PSBtYXhZOyB5KyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5ldyBGbGF0VGlsZSh4LCB5LCBsZXZlbEluZGV4LCB0aGlzKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcblxufTtcblxuXG5GbGF0R2VvbWV0cnkucHJvdG90eXBlLl9jbG9zZXN0VGlsZSA9IGZ1bmN0aW9uKHZpZXcsIGxldmVsKSB7XG4gIHZhciByYXkgPSB0aGlzLl92ZWM7XG5cbiAgLy8gQ29tcHV0ZSBhIHZpZXcgcmF5IGludG8gdGhlIGNlbnRyYWwgc2NyZWVuIHBvaW50LlxuICB2ZWM0LnNldChyYXksIDAsIDAsIDEsIDEpO1xuICB2ZWM0LnRyYW5zZm9ybU1hdDQocmF5LCByYXksIHZpZXcuaW52ZXJzZVByb2plY3Rpb24oKSk7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgaW1hZ2UgY29vcmRpbmF0ZXMgdGhhdCB0aGUgdmlldyByYXkgcG9pbnRzIGludG8uXG4gIHZhciB4ID0gMC41ICsgcmF5WzBdO1xuICB2YXIgeSA9IDAuNSAtIHJheVsxXTtcblxuICAvLyBHZXQgdGhlIGRlc2lyZWQgem9vbSBsZXZlbC5cbiAgdmFyIHRpbGVaID0gdGhpcy5sZXZlbExpc3QuaW5kZXhPZihsZXZlbCk7XG4gIHZhciBsZXZlbFdpZHRoID0gbGV2ZWwud2lkdGgoKTtcbiAgdmFyIGxldmVsSGVpZ2h0ID0gbGV2ZWwuaGVpZ2h0KCk7XG4gIHZhciB0aWxlV2lkdGggPSBsZXZlbC50aWxlV2lkdGgoKTtcbiAgdmFyIHRpbGVIZWlnaHQgPSBsZXZlbC50aWxlSGVpZ2h0KCk7XG4gIHZhciBudW1YID0gbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCk7XG4gIHZhciBudW1ZID0gbGV2ZWwubnVtVmVydGljYWxUaWxlcygpO1xuXG4gIC8vIEZpbmQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSB0aWxlIHRoYXQgdGhlIHZpZXcgcmF5IHBvaW50cyBpbnRvLlxuICB2YXIgdGlsZVggPSBjbGFtcChNYXRoLmZsb29yKHggKiBsZXZlbFdpZHRoIC8gdGlsZVdpZHRoKSwgMCwgbnVtWCAtIDEpO1xuICB2YXIgdGlsZVkgPSBjbGFtcChNYXRoLmZsb29yKHkgKiBsZXZlbEhlaWdodCAvIHRpbGVIZWlnaHQpLCAwLCBudW1ZIC0gMSk7XG5cbiAgcmV0dXJuIG5ldyBGbGF0VGlsZSh0aWxlWCwgdGlsZVksIHRpbGVaLCB0aGlzKTtcbn07XG5cblxuRmxhdEdlb21ldHJ5LnByb3RvdHlwZS52aXNpYmxlVGlsZXMgPSBmdW5jdGlvbih2aWV3LCBsZXZlbCwgcmVzdWx0KSB7XG4gIHZhciB2aWV3U2l6ZSA9IHRoaXMuX3ZpZXdTaXplO1xuICB2YXIgdGlsZVNlYXJjaGVyID0gdGhpcy5fdGlsZVNlYXJjaGVyO1xuXG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICB2aWV3LnNpemUodmlld1NpemUpO1xuICBpZiAodmlld1NpemUud2lkdGggPT09IDAgfHwgdmlld1NpemUuaGVpZ2h0ID09PSAwKSB7XG4gICAgLy8gTm8gdGlsZXMgYXJlIHZpc2libGUgaWYgdGhlIHZpZXdwb3J0IGlzIGVtcHR5LlxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgc3RhcnRpbmdUaWxlID0gdGhpcy5fY2xvc2VzdFRpbGUodmlldywgbGV2ZWwpO1xuICB2YXIgY291bnQgPSB0aWxlU2VhcmNoZXIuc2VhcmNoKHZpZXcsIHN0YXJ0aW5nVGlsZSwgcmVzdWx0KTtcbiAgaWYgKCFjb3VudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3RhcnRpbmcgdGlsZSBpcyBub3QgdmlzaWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuRmxhdEdlb21ldHJ5LlRpbGUgPSBGbGF0R2VvbWV0cnkucHJvdG90eXBlLlRpbGUgPSBGbGF0VGlsZTtcbkZsYXRHZW9tZXRyeS50eXBlID0gRmxhdEdlb21ldHJ5LnByb3RvdHlwZS50eXBlID0gJ2ZsYXQnO1xuRmxhdFRpbGUudHlwZSA9IEZsYXRUaWxlLnByb3RvdHlwZS50eXBlID0gJ2ZsYXQnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRmxhdEdlb21ldHJ5O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBMZXZlbChsZXZlbFByb3BlcnRpZXMpIHtcbiAgdGhpcy5fZmFsbGJhY2tPbmx5ID0gISFsZXZlbFByb3BlcnRpZXMuZmFsbGJhY2tPbmx5O1xufVxuXG5MZXZlbC5wcm90b3R5cGUubnVtSG9yaXpvbnRhbFRpbGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBNYXRoLmNlaWwodGhpcy53aWR0aCgpIC8gdGhpcy50aWxlV2lkdGgoKSk7XG59O1xuXG5MZXZlbC5wcm90b3R5cGUubnVtVmVydGljYWxUaWxlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuaGVpZ2h0KCkgLyB0aGlzLnRpbGVIZWlnaHQoKSk7XG59O1xuXG5MZXZlbC5wcm90b3R5cGUuZmFsbGJhY2tPbmx5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9mYWxsYmFja09ubHk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExldmVsOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGNtcCA9IHJlcXVpcmUoJy4uL3V0aWwvY21wJyk7XG5cbmZ1bmN0aW9uIG1ha2VMZXZlbExpc3QobGV2ZWxQcm9wZXJ0aWVzTGlzdCwgTGV2ZWxDbGFzcykge1xuICB2YXIgbGlzdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxQcm9wZXJ0aWVzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGxpc3QucHVzaChuZXcgTGV2ZWxDbGFzcyhsZXZlbFByb3BlcnRpZXNMaXN0W2ldKSk7XG4gIH1cblxuICBsaXN0LnNvcnQoZnVuY3Rpb24obGV2ZWwxLCBsZXZlbDIpIHtcbiAgICByZXR1cm4gY21wKGxldmVsMS53aWR0aCgpLCBsZXZlbDIud2lkdGgoKSk7XG4gIH0pO1xuXG4gIHJldHVybiBsaXN0O1xufVxuXG5mdW5jdGlvbiBtYWtlU2VsZWN0YWJsZUxldmVsTGlzdChsZXZlbExpc3QpIHtcbiAgdmFyIGxpc3QgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghbGV2ZWxMaXN0W2ldLl9mYWxsYmFja09ubHkpIHtcbiAgICAgIGxpc3QucHVzaChsZXZlbExpc3RbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbGlzdC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNlbGVjdGFibGUgbGV2ZWxzIGluIGxpc3QnKTtcbiAgfVxuXG4gIHJldHVybiBsaXN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWFrZUxldmVsTGlzdDogbWFrZUxldmVsTGlzdCxcbiAgbWFrZVNlbGVjdGFibGVMZXZlbExpc3Q6IG1ha2VTZWxlY3RhYmxlTGV2ZWxMaXN0XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvLyBTdGFnZXMuXG4gIFdlYkdsU3RhZ2U6IHJlcXVpcmUoJy4vc3RhZ2VzL1dlYkdsJyksXG5cbiAgLy8gUmVuZGVyZXJzLlxuICBXZWJHbEN1YmVSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlcnMvV2ViR2xDdWJlJyksXG4gIFdlYkdsRmxhdFJlbmRlcmVyOiByZXF1aXJlKCcuL3JlbmRlcmVycy9XZWJHbEZsYXQnKSxcbiAgV2ViR2xFcXVpcmVjdFJlbmRlcmVyOiByZXF1aXJlKCcuL3JlbmRlcmVycy9XZWJHbEVxdWlyZWN0JyksXG4gIHJlZ2lzdGVyRGVmYXVsdFJlbmRlcmVyczogcmVxdWlyZSgnLi9yZW5kZXJlcnMvcmVnaXN0ZXJEZWZhdWx0UmVuZGVyZXJzJyksXG5cbiAgLy8gR2VvbWV0cmllcy5cbiAgQ3ViZUdlb21ldHJ5OiByZXF1aXJlKCcuL2dlb21ldHJpZXMvQ3ViZScpLFxuICBGbGF0R2VvbWV0cnk6IHJlcXVpcmUoJy4vZ2VvbWV0cmllcy9GbGF0JyksXG4gIEVxdWlyZWN0R2VvbWV0cnk6IHJlcXVpcmUoJy4vZ2VvbWV0cmllcy9FcXVpcmVjdCcpLFxuXG4gIC8vIFZpZXdzLlxuICBSZWN0aWxpbmVhclZpZXc6IHJlcXVpcmUoJy4vdmlld3MvUmVjdGlsaW5lYXInKSxcbiAgRmxhdFZpZXc6IHJlcXVpcmUoJy4vdmlld3MvRmxhdCcpLFxuXG4gIC8vIFNvdXJjZXMuXG4gIEltYWdlVXJsU291cmNlOiByZXF1aXJlKCcuL3NvdXJjZXMvSW1hZ2VVcmwnKSxcbiAgU2luZ2xlQXNzZXRTb3VyY2U6IHJlcXVpcmUoJy4vc291cmNlcy9TaW5nbGVBc3NldCcpLFxuXG4gIC8vIEFzc2V0cy5cbiAgU3RhdGljQXNzZXQ6IHJlcXVpcmUoJy4vYXNzZXRzL1N0YXRpYycpLFxuICBEeW5hbWljQXNzZXQ6IHJlcXVpcmUoJy4vYXNzZXRzL0R5bmFtaWMnKSxcblxuICAvLyBUZXh0dXJlIHN0b3JlLlxuICBUZXh0dXJlU3RvcmU6IHJlcXVpcmUoJy4vVGV4dHVyZVN0b3JlJyksXG5cbiAgLy8gTGF5ZXIuXG4gIExheWVyOiByZXF1aXJlKCcuL0xheWVyJyksXG5cbiAgLy8gUmVuZGVyIGxvb3AuXG4gIFJlbmRlckxvb3A6IHJlcXVpcmUoJy4vUmVuZGVyTG9vcCcpLFxuXG4gIC8vIENvbnRyb2xzLlxuICBLZXlDb250cm9sTWV0aG9kOiByZXF1aXJlKCcuL2NvbnRyb2xzL0tleScpLFxuICBEcmFnQ29udHJvbE1ldGhvZDogcmVxdWlyZSgnLi9jb250cm9scy9EcmFnJyksXG4gIFF0dnJDb250cm9sTWV0aG9kOiByZXF1aXJlKCcuL2NvbnRyb2xzL1F0dnInKSxcbiAgU2Nyb2xsWm9vbUNvbnRyb2xNZXRob2Q6IHJlcXVpcmUoJy4vY29udHJvbHMvU2Nyb2xsWm9vbScpLFxuICBQaW5jaFpvb21Db250cm9sTWV0aG9kOiByZXF1aXJlKCcuL2NvbnRyb2xzL1BpbmNoWm9vbScpLFxuICBWZWxvY2l0eUNvbnRyb2xNZXRob2Q6IHJlcXVpcmUoJy4vY29udHJvbHMvVmVsb2NpdHknKSxcbiAgRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZDogcmVxdWlyZSgnLi9jb250cm9scy9FbGVtZW50UHJlc3MnKSxcbiAgQ29udHJvbHM6IHJlcXVpcmUoJy4vY29udHJvbHMvQ29udHJvbHMnKSxcbiAgRHluYW1pY3M6IHJlcXVpcmUoJy4vY29udHJvbHMvRHluYW1pY3MnKSxcblxuICAvLyBIaWdoLWxldmVsIEFQSS5cbiAgVmlld2VyOiByZXF1aXJlKCcuL1ZpZXdlcicpLFxuICBTY2VuZTogcmVxdWlyZSgnLi9TY2VuZScpLFxuXG4gIC8vIEhvdHNwb3RzLlxuICBIb3RzcG90OiByZXF1aXJlKCcuL0hvdHNwb3QnKSxcbiAgSG90c3BvdENvbnRhaW5lcjogcmVxdWlyZSgnLi9Ib3RzcG90Q29udGFpbmVyJyksXG5cbiAgLy8gRWZmZWN0cy5cbiAgY29sb3JFZmZlY3RzOiByZXF1aXJlKCcuL2NvbG9yRWZmZWN0cycpLFxuXG4gIC8vIE1pc2NlbGxhbmVvdXMgZnVuY3Rpb25zLlxuICByZWdpc3RlckRlZmF1bHRDb250cm9sczogcmVxdWlyZSgnLi9jb250cm9scy9yZWdpc3RlckRlZmF1bHRDb250cm9scycpLFxuICBhdXRvcm90YXRlOiByZXF1aXJlKCcuL2F1dG9yb3RhdGUnKSxcblxuICAvLyBVdGlsaXR5IGZ1bmN0aW9ucy5cbiAgdXRpbDoge1xuICAgIGFzeW5jOiByZXF1aXJlKCcuL3V0aWwvYXN5bmMnKSxcbiAgICBjYW5jZWxpemU6IHJlcXVpcmUoJy4vdXRpbC9jYW5jZWxpemUnKSxcbiAgICBjaGFpbjogcmVxdWlyZSgnLi91dGlsL2NoYWluJyksXG4gICAgY2xhbXA6IHJlcXVpcmUoJy4vdXRpbC9jbGFtcCcpLFxuICAgIGNsZWFyT3duUHJvcGVydGllczogcmVxdWlyZSgnLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpLFxuICAgIGNtcDogcmVxdWlyZSgnLi91dGlsL2NtcCcpLFxuICAgIGNvbXBvc2U6IHJlcXVpcmUoJy4vdXRpbC9jb21wb3NlJyksXG4gICAgY29udmVydEZvdjogcmVxdWlyZSgnLi91dGlsL2NvbnZlcnRGb3YnKSxcbiAgICBkZWNpbWFsOiByZXF1aXJlKCcuL3V0aWwvZGVjaW1hbCcpLFxuICAgIGRlZmF1bHRzOiByZXF1aXJlKCcuL3V0aWwvZGVmYXVsdHMnKSxcbiAgICBkZWZlcjogcmVxdWlyZSgnLi91dGlsL2RlZmVyJyksXG4gICAgZGVnVG9SYWQ6IHJlcXVpcmUoJy4vdXRpbC9kZWdUb1JhZCcpLFxuICAgIGRlbGF5OiByZXF1aXJlKCcuL3V0aWwvZGVsYXknKSxcbiAgICBkb206IHJlcXVpcmUoJy4vdXRpbC9kb20nKSxcbiAgICBleHRlbmQ6IHJlcXVpcmUoJy4vdXRpbC9leHRlbmQnKSxcbiAgICBoYXNoOiByZXF1aXJlKCcuL3V0aWwvaGFzaCcpLFxuICAgIGluaGVyaXRzOiByZXF1aXJlKCcuL3V0aWwvaW5oZXJpdHMnKSxcbiAgICBtb2Q6IHJlcXVpcmUoJy4vdXRpbC9tb2QnKSxcbiAgICBub29wOiByZXF1aXJlKCcuL3V0aWwvbm9vcCcpLFxuICAgIG5vdzogcmVxdWlyZSgnLi91dGlsL25vdycpLFxuICAgIG9uY2U6IHJlcXVpcmUoJy4vdXRpbC9vbmNlJyksXG4gICAgcGl4ZWxSYXRpbzogcmVxdWlyZSgnLi91dGlsL3BpeGVsUmF0aW8nKSxcbiAgICByYWRUb0RlZzogcmVxdWlyZSgnLi91dGlsL3JhZFRvRGVnJyksXG4gICAgcmVhbDogcmVxdWlyZSgnLi91dGlsL3JlYWwnKSxcbiAgICByZXRyeTogcmVxdWlyZSgnLi91dGlsL3JldHJ5JyksXG4gICAgdHdlZW46IHJlcXVpcmUoJy4vdXRpbC90d2VlbicpLFxuICAgIHR5cGU6IHJlcXVpcmUoJy4vdXRpbC90eXBlJylcbiAgfSxcblxuICAvLyBFeHBvc2UgZGVwZW5kZW5jaWVzIGZvciBjbGllbnRzIHRvIHVzZS5cbiAgZGVwZW5kZW5jaWVzOiB7XG4gICAgYm93c2VyOiByZXF1aXJlKCdib3dzZXInKSxcbiAgICBnbE1hdHJpeDogcmVxdWlyZSgnZ2wtbWF0cml4JyksXG4gICAgZXZlbnRFbWl0dGVyOiByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKSxcbiAgICBoYW1tZXJqczogcmVxdWlyZSgnaGFtbWVyanMnKVxuICB9XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RhdGljQXNzZXQgPSByZXF1aXJlKCcuLi9hc3NldHMvU3RhdGljJyk7XG52YXIgTmV0d29ya0Vycm9yID0gcmVxdWlyZSgnLi4vTmV0d29ya0Vycm9yJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vdXRpbC9nbG9iYWwnKTtcbnZhciBvbmNlID0gcmVxdWlyZSgnLi4vdXRpbC9vbmNlJyk7XG5cbi8vIFRPRE86IE1vdmUgdGhlIGxvYWQgcXVldWUgaW50byB0aGUgbG9hZGVyLlxuXG4vLyBPcHRpb25zIGZvciBjcmVhdGVJbWFnZUJpdG1hcC5cbnZhciBjcmVhdGVJbWFnZUJpdG1hcE9wdHMgPSB7XG4gIGltYWdlT3JpZW50YXRpb246ICdmbGlwWScsXG4gIHByZW11bHRpcGx5QWxwaGE6ICdwcmVtdWx0aXBseScsXG4gIHJlc2l6ZVF1YWxpdHk6ICdoaWdoJ1xufTtcblxuLyoqXG4gKiBAY2xhc3MgSHRtbEltYWdlTG9hZGVyXG4gKiBAaW1wbGVtZW50cyBJbWFnZUxvYWRlclxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEge0BsaW5rIExvYWRlcn0gZm9yIEhUTUwgaW1hZ2VzLlxuICpcbiAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlIFRoZSBzdGFnZSB3aGljaCBpcyBnb2luZyB0byByZXF1ZXN0IGltYWdlcyB0byBiZSBsb2FkZWQuXG4gKi9cbmZ1bmN0aW9uIEh0bWxJbWFnZUxvYWRlcihzdGFnZSkge1xuICB0aGlzLl9zdGFnZSA9IHN0YWdlO1xufVxuXG4vKipcbiAqIExvYWRzIGFuIHtAbGluayBBc3NldH0gZnJvbSBhbiBpbWFnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGltYWdlIFVSTC5cbiAqIEBwYXJhbSB7P1JlY3R9IHJlY3QgQSB7QGxpbmsgUmVjdH0gZGVzY3JpYmluZyBhIHBvcnRpb24gb2YgdGhlIGltYWdlLCBvciBudWxsXG4gKiAgICAgdG8gdXNlIHRoZSBmdWxsIGltYWdlLlxuICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IsIEFzc2V0KX0gZG9uZSBUaGUgY2FsbGJhY2suXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpfSBBIGZ1bmN0aW9uIHRvIGNhbmNlbCBsb2FkaW5nLlxuICovXG5IdG1sSW1hZ2VMb2FkZXIucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uKHVybCwgcmVjdCwgZG9uZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuXG4gIC8vIEFsbG93IGNyb3NzLWRvbWFpbiBpbWFnZSBsb2FkaW5nLlxuICAvLyBUaGlzIGlzIHJlcXVpcmVkIHRvIGJlIGFibGUgdG8gY3JlYXRlIFdlYkdMIHRleHR1cmVzIGZyb20gaW1hZ2VzIGZldGNoZWRcbiAgLy8gZnJvbSBhIGRpZmZlcmVudCBkb21haW4uIE5vdGUgdGhhdCBzZXR0aW5nIHRoZSBjcm9zc29yaWdpbiBhdHRyaWJ1dGUgdG9cbiAgLy8gJ2Fub255bW91cycgd2lsbCB0cmlnZ2VyIGEgQ09SUyBwcmVmbGlnaHQgZm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgYnV0IG5vXG4gIC8vIGNyZWRlbnRpYWxzIChjb29raWVzIG9yIEhUVFAgYXV0aCkgd2lsbCBiZSBzZW50OyB0byBkbyBzbywgdGhlIGF0dHJpYnV0ZVxuICAvLyB3b3VsZCBoYXZlIHRvIGJlIHNldCB0byAndXNlLWNyZWRlbnRpYWxzJyBpbnN0ZWFkLiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGlzXG4gIC8vIG5vdCBhIHNhZmUgY2hvaWNlLCBhcyBpdCBjYXVzZXMgcmVxdWVzdHMgdG8gZmFpbCB3aGVuIHRoZSByZXNwb25zZSBjb250YWluc1xuICAvLyBhbiBBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4gaGVhZGVyIHdpdGggYSB3aWxkY2FyZC4gU2VlIHRoZSBzZWN0aW9uXG4gIC8vIFwiQ3JlZGVudGlhbGVkIHJlcXVlc3RzIGFuZCB3aWxkY2FyZHNcIiBvbjpcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9DT1JTXG4gIGltZy5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuXG4gIHZhciB4ID0gcmVjdCAmJiByZWN0LnggfHwgMDtcbiAgdmFyIHkgPSByZWN0ICYmIHJlY3QueSB8fCAwO1xuICB2YXIgd2lkdGggPSByZWN0ICYmIHJlY3Qud2lkdGggfHwgMTtcbiAgdmFyIGhlaWdodCA9IHJlY3QgJiYgcmVjdC5oZWlnaHQgfHwgMTtcblxuICBkb25lID0gb25jZShkb25lKTtcblxuICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5faGFuZGxlTG9hZChpbWcsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGRvbmUpO1xuICB9O1xuXG4gIGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5faGFuZGxlRXJyb3IodXJsLCBkb25lKTtcbiAgfTtcblxuICBpbWcuc3JjID0gdXJsO1xuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgIGltZy5zcmMgPSAnJztcbiAgICBkb25lLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gY2FuY2VsO1xufTtcblxuSHRtbEltYWdlTG9hZGVyLnByb3RvdHlwZS5faGFuZGxlTG9hZCA9IGZ1bmN0aW9uKGltZywgeCwgeSwgd2lkdGgsIGhlaWdodCwgZG9uZSkge1xuICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwICYmIHdpZHRoID09PSAxICYmIGhlaWdodCA9PT0gMSkge1xuICAgIC8vIEZhc3QgcGF0aCBmb3Igd2hlbiBjcm9wcGluZyBpcyBub3QgbmVlZGVkLlxuICAgIGRvbmUobnVsbCwgbmV3IFN0YXRpY0Fzc2V0KGltZykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHggKj0gaW1nLm5hdHVyYWxXaWR0aDtcbiAgeSAqPSBpbWcubmF0dXJhbEhlaWdodDtcbiAgd2lkdGggKj0gaW1nLm5hdHVyYWxXaWR0aDtcbiAgaGVpZ2h0ICo9IGltZy5uYXR1cmFsSGVpZ2h0O1xuXG4gIGlmIChnbG9iYWwuY3JlYXRlSW1hZ2VCaXRtYXApIHtcbiAgICAvLyBQcmVmZXIgdG8gY3JvcCB1c2luZyBjcmVhdGVJbWFnZUJpdG1hcCwgd2hpY2ggY2FuIHBvdGVudGlhbGx5IG9mZmxvYWRcbiAgICAvLyB3b3JrIHRvIGFub3RoZXIgdGhyZWFkIGFuZCBhdm9pZCBibG9ja2luZyB0aGUgdXNlciBpbnRlcmZhY2UuXG4gICAgLy8gQXNzdW1lIHRoYXQgdGhlIHByb21pc2UgaXMgbmV2ZXIgcmVqZWN0ZWQuXG4gICAgZ2xvYmFsLmNyZWF0ZUltYWdlQml0bWFwKGltZywgeCwgeSwgd2lkdGgsIGhlaWdodCwgY3JlYXRlSW1hZ2VCaXRtYXBPcHRzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24oYml0bWFwKSB7XG4gICAgICAgIGRvbmUobnVsbCwgbmV3IFN0YXRpY0Fzc2V0KGJpdG1hcCkpO1xuICAgICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbCBiYWNrIHRvIGNyb3BwaW5nIHVzaW5nIGEgY2FudmFzLCB3aGljaCBjYW4gcG90ZW50aWFsbHkgYmxvY2sgdGhlXG4gICAgLy8gdXNlciBpbnRlcmZhY2UsIGJ1dCBpcyB0aGUgYmVzdCB3ZSBjYW4gZG8uXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGRvbmUobnVsbCwgbmV3IFN0YXRpY0Fzc2V0KGNhbnZhcykpO1xuICB9XG59O1xuXG5IdG1sSW1hZ2VMb2FkZXIucHJvdG90eXBlLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uKHVybCwgZG9uZSkge1xuICAvLyBUT0RPOiBpcyB0aGVyZSBhbnkgd2F5IHRvIGRpc3Rpbmd1aXNoIGEgbmV0d29yayBlcnJvciBmcm9tIG90aGVyXG4gIC8vIGtpbmRzIG9mIGVycm9ycz8gRm9yIG5vdyB3ZSBhbHdheXMgcmV0dXJuIE5ldHdvcmtFcnJvciBzaW5jZSB0aGlzXG4gIC8vIHByZXZlbnRzIGltYWdlcyB0byBiZSByZXRyaWVkIGNvbnRpbnVvdXNseSB3aGlsZSB3ZSBhcmUgb2ZmbGluZS5cbiAgZG9uZShuZXcgTmV0d29ya0Vycm9yKCdOZXR3b3JrIGVycm9yOiAnICsgdXJsKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxJbWFnZUxvYWRlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xudmFyIHZlYzMgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS52ZWMzO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBXZWJHbENvbW1vbiA9IHJlcXVpcmUoJy4vV2ViR2xDb21tb24nKTtcbnZhciBjcmVhdGVDb25zdGFudEJ1ZmZlcnMgPSBXZWJHbENvbW1vbi5jcmVhdGVDb25zdGFudEJ1ZmZlcnM7XG52YXIgZGVzdHJveUNvbnN0YW50QnVmZmVycyA9IFdlYkdsQ29tbW9uLmRlc3Ryb3lDb25zdGFudEJ1ZmZlcnM7XG52YXIgY3JlYXRlU2hhZGVyUHJvZ3JhbSA9IFdlYkdsQ29tbW9uLmNyZWF0ZVNoYWRlclByb2dyYW07XG52YXIgZGVzdHJveVNoYWRlclByb2dyYW0gPSBXZWJHbENvbW1vbi5kZXN0cm95U2hhZGVyUHJvZ3JhbTtcbnZhciBlbmFibGVBdHRyaWJ1dGVzID0gV2ViR2xDb21tb24uZW5hYmxlQXR0cmlidXRlcztcbnZhciBkaXNhYmxlQXR0cmlidXRlcyA9IFdlYkdsQ29tbW9uLmRpc2FibGVBdHRyaWJ1dGVzO1xudmFyIHNldFZpZXdwb3J0ID0gV2ViR2xDb21tb24uc2V0Vmlld3BvcnQ7XG52YXIgc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zID0gV2ViR2xDb21tb24uc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zO1xuXG52YXIgc2V0RGVwdGggPSBXZWJHbENvbW1vbi5zZXREZXB0aDtcbnZhciBzZXRUZXh0dXJlID0gV2ViR2xDb21tb24uc2V0VGV4dHVyZTtcblxudmFyIHZlcnRleFNyYyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvdmVydGV4Tm9ybWFsJyk7XG52YXIgZnJhZ21lbnRTcmMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL2ZyYWdtZW50Tm9ybWFsJyk7XG5cbnZhciB2ZXJ0ZXhJbmRpY2VzID0gWzAsIDEsIDIsIDAsIDIsIDNdO1xudmFyIHZlcnRleFBvc2l0aW9ucyA9IFstMC41LCAtMC41LCAwLjAsIDAuNSwgLTAuNSwgMC4wLCAwLjUsIDAuNSwgMC4wLCAtMC41LCAwLjUsIDAuMF07XG52YXIgdGV4dHVyZUNvb3JkcyA9IFswLjAsIDAuMCwgMS4wLCAwLjAsIDEuMCwgMS4wLCAwLjAsIDEuMF07XG5cbnZhciBhdHRyaWJMaXN0ID0gWydhVmVydGV4UG9zaXRpb24nLCAnYVRleHR1cmVDb29yZCddO1xudmFyIHVuaWZvcm1MaXN0ID0gW1xuICAndURlcHRoJywgJ3VPcGFjaXR5JywgJ3VTYW1wbGVyJywgJ3VQcm9qTWF0cml4JywgJ3VWaWV3cG9ydE1hdHJpeCcsXG4gICd1Q29sb3JPZmZzZXQnLCAndUNvbG9yTWF0cml4J1xuXTtcblxuXG5mdW5jdGlvbiBXZWJHbEJhc2VSZW5kZXJlcihnbCkge1xuICB0aGlzLmdsID0gZ2w7XG5cbiAgLy8gVGhlIHByb2plY3Rpb24gbWF0cml4IHBvc2l0aW9ucyB0aGUgdGlsZXMgaW4gd29ybGQgc3BhY2UuXG4gIC8vIFdlIGNvbXB1dGUgaXQgaW4gSmF2YXNjcmlwdCBiZWNhdXNlIGxhY2sgb2YgcHJlY2lzaW9uIGluIHRoZSB2ZXJ0ZXggc2hhZGVyXG4gIC8vIGNhdXNlcyBzZWFtcyB0byBhcHBlYXIgYmV0d2VlbiBhZGphY2VudCB0aWxlcyBhdCBsYXJnZSB6b29tIGxldmVscy5cbiAgdGhpcy5wcm9qTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuICAvLyBUaGUgdmlld3BvcnQgbWF0cml4IHJlc3BvbnNpYmxlIGZvciB2aWV3cG9ydCBjbGFtcGluZy5cbiAgLy8gU2VlIHNldFZpZXdwb3J0KCkgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIGhvdyBpdCB3b3Jrcy5cbiAgdGhpcy52aWV3cG9ydE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgLy8gVHJhbnNsYXRpb24gYW5kIHNjYWxlIHZlY3RvcnMgZm9yIHRpbGVzLlxuICB0aGlzLnRyYW5zbGF0ZVZlY3RvciA9IHZlYzMuY3JlYXRlKCk7XG4gIHRoaXMuc2NhbGVWZWN0b3IgPSB2ZWMzLmNyZWF0ZSgpO1xuXG4gIHRoaXMuY29uc3RhbnRCdWZmZXJzID0gY3JlYXRlQ29uc3RhbnRCdWZmZXJzKGdsLCB2ZXJ0ZXhJbmRpY2VzLCB2ZXJ0ZXhQb3NpdGlvbnMsIHRleHR1cmVDb29yZHMpO1xuXG4gIHRoaXMuc2hhZGVyUHJvZ3JhbSA9IGNyZWF0ZVNoYWRlclByb2dyYW0oZ2wsIHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIGF0dHJpYkxpc3QsIHVuaWZvcm1MaXN0KTtcbn1cblxuV2ViR2xCYXNlUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgZGVzdHJveUNvbnN0YW50QnVmZmVycyh0aGlzLmdsLCB0aGlzLmNvbnN0YW50QnVmZmVycyk7XG4gIGRlc3Ryb3lTaGFkZXJQcm9ncmFtKHRoaXMuZ2wsIHRoaXMuc2hhZGVyUHJvZ3JhbSk7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cbldlYkdsQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5zdGFydExheWVyID0gZnVuY3Rpb24obGF5ZXIsIHJlY3QpIHtcbiAgdmFyIGdsID0gdGhpcy5nbDtcbiAgdmFyIHNoYWRlclByb2dyYW0gPSB0aGlzLnNoYWRlclByb2dyYW07XG4gIHZhciBjb25zdGFudEJ1ZmZlcnMgPSB0aGlzLmNvbnN0YW50QnVmZmVycztcbiAgdmFyIHZpZXdwb3J0TWF0cml4ID0gdGhpcy52aWV3cG9ydE1hdHJpeDtcblxuICBnbC51c2VQcm9ncmFtKHNoYWRlclByb2dyYW0pO1xuXG4gIGVuYWJsZUF0dHJpYnV0ZXMoZ2wsIHNoYWRlclByb2dyYW0pO1xuXG4gIHNldFZpZXdwb3J0KGdsLCBsYXllciwgcmVjdCwgdmlld3BvcnRNYXRyaXgpO1xuICBnbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclByb2dyYW0udVZpZXdwb3J0TWF0cml4LCBmYWxzZSwgdmlld3BvcnRNYXRyaXgpO1xuXG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBjb25zdGFudEJ1ZmZlcnMudmVydGV4UG9zaXRpb25zKTtcbiAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXJQcm9ncmFtLmFWZXJ0ZXhQb3NpdGlvbiwgMywgZ2wuRkxPQVQsIGdsLkZBTFNFLCAwLCAwKTtcbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGNvbnN0YW50QnVmZmVycy50ZXh0dXJlQ29vcmRzKTtcbiAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXJQcm9ncmFtLmFUZXh0dXJlQ29vcmQsIDIsIGdsLkZMT0FULCBnbC5GQUxTRSwgMCwgMCk7XG5cbiAgc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zKGdsLCBsYXllci5lZmZlY3RzKCksIHtcbiAgICBvcGFjaXR5OiBzaGFkZXJQcm9ncmFtLnVPcGFjaXR5LFxuICAgIGNvbG9yT2Zmc2V0OiBzaGFkZXJQcm9ncmFtLnVDb2xvck9mZnNldCxcbiAgICBjb2xvck1hdHJpeDogc2hhZGVyUHJvZ3JhbS51Q29sb3JNYXRyaXhcbiAgfSk7XG59O1xuXG5cbldlYkdsQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5lbmRMYXllciA9IGZ1bmN0aW9uKGxheWVyLCByZWN0KSB7XG4gIHZhciBnbCA9IHRoaXMuZ2w7XG4gIHZhciBzaGFkZXJQcm9ncmFtID0gdGhpcy5zaGFkZXJQcm9ncmFtO1xuICBkaXNhYmxlQXR0cmlidXRlcyhnbCwgc2hhZGVyUHJvZ3JhbSk7XG59O1xuXG5cbldlYkdsQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUaWxlID0gZnVuY3Rpb24odGlsZSwgdGV4dHVyZSwgbGF5ZXIsIGxheWVyWikge1xuICB2YXIgZ2wgPSB0aGlzLmdsO1xuICB2YXIgc2hhZGVyUHJvZ3JhbSA9IHRoaXMuc2hhZGVyUHJvZ3JhbTtcbiAgdmFyIGNvbnN0YW50QnVmZmVycyA9IHRoaXMuY29uc3RhbnRCdWZmZXJzO1xuICB2YXIgcHJvak1hdHJpeCA9IHRoaXMucHJvak1hdHJpeDtcbiAgdmFyIHRyYW5zbGF0ZVZlY3RvciA9IHRoaXMudHJhbnNsYXRlVmVjdG9yO1xuICB2YXIgc2NhbGVWZWN0b3IgPSB0aGlzLnNjYWxlVmVjdG9yO1xuXG4gIHRyYW5zbGF0ZVZlY3RvclswXSA9IHRpbGUuY2VudGVyWCgpO1xuICB0cmFuc2xhdGVWZWN0b3JbMV0gPSB0aWxlLmNlbnRlclkoKTtcbiAgdHJhbnNsYXRlVmVjdG9yWzJdID0gLTAuNTtcblxuICBzY2FsZVZlY3RvclswXSA9IHRpbGUuc2NhbGVYKCk7XG4gIHNjYWxlVmVjdG9yWzFdID0gdGlsZS5zY2FsZVkoKTtcbiAgc2NhbGVWZWN0b3JbMl0gPSAxLjA7XG5cbiAgbWF0NC5jb3B5KHByb2pNYXRyaXgsIGxheWVyLnZpZXcoKS5wcm9qZWN0aW9uKCkpO1xuICBtYXQ0LnJvdGF0ZVgocHJvak1hdHJpeCwgcHJvak1hdHJpeCwgdGlsZS5yb3RYKCkpO1xuICBtYXQ0LnJvdGF0ZVkocHJvak1hdHJpeCwgcHJvak1hdHJpeCwgdGlsZS5yb3RZKCkpO1xuICBtYXQ0LnRyYW5zbGF0ZShwcm9qTWF0cml4LCBwcm9qTWF0cml4LCB0cmFuc2xhdGVWZWN0b3IpO1xuICBtYXQ0LnNjYWxlKHByb2pNYXRyaXgsIHByb2pNYXRyaXgsIHNjYWxlVmVjdG9yKTtcblxuICBnbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclByb2dyYW0udVByb2pNYXRyaXgsIGZhbHNlLCBwcm9qTWF0cml4KTtcblxuICBzZXREZXB0aChnbCwgc2hhZGVyUHJvZ3JhbSwgbGF5ZXJaLCB0aWxlLnopO1xuXG4gIHNldFRleHR1cmUoZ2wsIHNoYWRlclByb2dyYW0sIHRleHR1cmUpO1xuXG4gIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGNvbnN0YW50QnVmZmVycy52ZXJ0ZXhJbmRpY2VzKTtcbiAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdmVydGV4SW5kaWNlcy5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJHbEJhc2VSZW5kZXJlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlc2UgYXJlIHVzZWQgdG8gc2V0IHRoZSBXZWJHbCBkZXB0aCBmb3IgYSB0aWxlLlxudmFyIE1BWF9MQVlFUlMgPSAyNTY7IC8vIE1heCBudW1iZXIgb2YgbGF5ZXJzIHBlciBzdGFnZS5cbnZhciBNQVhfTEVWRUxTID0gMjU2OyAvLyBNYXggbnVtYmVyIG9mIGxldmVscyBwZXIgbGF5ZXIuXG5cbnZhciBjbGFtcCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhbXAnKTtcbnZhciB2ZWM0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjNDtcbnZhciB2ZWMzID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjMztcbnZhciBtYXQ0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0NDtcblxuXG5mdW5jdGlvbiBjcmVhdGVTaGFkZXIoZ2wsIHR5cGUsIHNyYykge1xuICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzcmMpO1xuICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgdGhyb3cgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICB9XG4gIHJldHVybiBzaGFkZXI7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlU2hhZGVyUHJvZ3JhbShnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgYXR0cmliTGlzdCwgdW5pZm9ybUxpc3QpIHtcblxuICB2YXIgdmVydGV4U2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTcmMpO1xuICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBjcmVhdGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTcmMpO1xuXG4gIHZhciBzaGFkZXJQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gIGdsLmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5hdHRhY2hTaGFkZXIoc2hhZGVyUHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5saW5rUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTtcblxuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyUHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgdGhyb3cgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coc2hhZGVyUHJvZ3JhbSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYkxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0cmliID0gYXR0cmliTGlzdFtpXTtcbiAgICBzaGFkZXJQcm9ncmFtW2F0dHJpYl0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihzaGFkZXJQcm9ncmFtLCBhdHRyaWIpO1xuICAgIGlmIChzaGFkZXJQcm9ncmFtW2F0dHJpYl0gPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWRlciBwcm9ncmFtIGhhcyBubyAnICsgYXR0cmliICsgJyBhdHRyaWJ1dGUnKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IHVuaWZvcm1MaXN0Lmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIHVuaWZvcm0gPSB1bmlmb3JtTGlzdFtqXTtcbiAgICBzaGFkZXJQcm9ncmFtW3VuaWZvcm1dID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sIHVuaWZvcm0pO1xuICAgIGlmIChzaGFkZXJQcm9ncmFtW3VuaWZvcm1dID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFkZXIgcHJvZ3JhbSBoYXMgbm8gJyArIHVuaWZvcm0gKyAnIHVuaWZvcm0nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2hhZGVyUHJvZ3JhbTtcbn1cblxuXG5mdW5jdGlvbiBkZXN0cm95U2hhZGVyUHJvZ3JhbShnbCwgc2hhZGVyUHJvZ3JhbSkge1xuICB2YXIgc2hhZGVyTGlzdCA9IGdsLmdldEF0dGFjaGVkU2hhZGVycyhzaGFkZXJQcm9ncmFtKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFkZXJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNoYWRlciA9IHNoYWRlckxpc3RbaV07XG4gICAgZ2wuZGV0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIHNoYWRlcik7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gIH1cbiAgZ2wuZGVsZXRlUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTtcbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVDb25zdGFudEJ1ZmZlcihnbCwgdGFyZ2V0LCB1c2FnZSwgdmFsdWUpIHtcbiAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICBnbC5iaW5kQnVmZmVyKHRhcmdldCwgYnVmZmVyKTtcbiAgZ2wuYnVmZmVyRGF0YSh0YXJnZXQsIHZhbHVlLCB1c2FnZSk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlQ29uc3RhbnRCdWZmZXJzKGdsLCB2ZXJ0ZXhJbmRpY2VzLCB2ZXJ0ZXhQb3NpdGlvbnMsIHRleHR1cmVDb29yZHMpIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJ0ZXhJbmRpY2VzOiBjcmVhdGVDb25zdGFudEJ1ZmZlcihnbCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdsLlNUQVRJQ19EUkFXLCBuZXcgVWludDE2QXJyYXkodmVydGV4SW5kaWNlcykpLFxuICAgIHZlcnRleFBvc2l0aW9uczogY3JlYXRlQ29uc3RhbnRCdWZmZXIoZ2wsIGdsLkFSUkFZX0JVRkZFUiwgZ2wuU1RBVElDX0RSQVcsIG5ldyBGbG9hdDMyQXJyYXkodmVydGV4UG9zaXRpb25zKSksXG4gICAgdGV4dHVyZUNvb3JkczogY3JlYXRlQ29uc3RhbnRCdWZmZXIoZ2wsIGdsLkFSUkFZX0JVRkZFUiwgZ2wuU1RBVElDX0RSQVcsIG5ldyBGbG9hdDMyQXJyYXkodGV4dHVyZUNvb3JkcykpXG4gIH07XG59XG5cblxuZnVuY3Rpb24gZGVzdHJveUNvbnN0YW50QnVmZmVycyhnbCwgY29uc3RhbnRCdWZmZXJzKSB7XG4gIGdsLmRlbGV0ZUJ1ZmZlcihjb25zdGFudEJ1ZmZlcnMudmVydGV4SW5kaWNlcyk7XG4gIGdsLmRlbGV0ZUJ1ZmZlcihjb25zdGFudEJ1ZmZlcnMudmVydGV4UG9zaXRpb25zKTtcbiAgZ2wuZGVsZXRlQnVmZmVyKGNvbnN0YW50QnVmZmVycy50ZXh0dXJlQ29vcmRzKTtcbn1cblxuXG5mdW5jdGlvbiBlbmFibGVBdHRyaWJ1dGVzKGdsLCBzaGFkZXJQcm9ncmFtKSB7XG4gIHZhciBudW1BdHRycyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyUHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUF0dHJzOyBpKyspIHtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGRpc2FibGVBdHRyaWJ1dGVzKGdsLCBzaGFkZXJQcm9ncmFtKSB7XG4gIHZhciBudW1BdHRycyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyUHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUF0dHJzOyBpKyspIHtcbiAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZXRUZXh0dXJlKGdsLCBzaGFkZXJQcm9ncmFtLCB0ZXh0dXJlKSB7XG4gIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlLl90ZXh0dXJlKTtcbiAgZ2wudW5pZm9ybTFpKHNoYWRlclByb2dyYW0udVNhbXBsZXIsIDApO1xufVxuXG5cbmZ1bmN0aW9uIHNldERlcHRoKGdsLCBzaGFkZXJQcm9ncmFtLCBsYXllclosIHRpbGVaKSB7XG4gIHZhciBkZXB0aCA9ICgoKGxheWVyWiArIDEpICogTUFYX0xFVkVMUykgLSB0aWxlWikgLyAoTUFYX0xFVkVMUyAqIE1BWF9MQVlFUlMpO1xuICBnbC51bmlmb3JtMWYoc2hhZGVyUHJvZ3JhbS51RGVwdGgsIGRlcHRoKTtcbn1cblxuXG52YXIgZGVmYXVsdE9wYWNpdHkgPSAxLjA7XG52YXIgZGVmYXVsdENvbG9yT2Zmc2V0ID0gdmVjNC5jcmVhdGUoKTtcbnZhciBkZWZhdWx0Q29sb3JNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xubWF0NC5pZGVudGl0eShkZWZhdWx0Q29sb3JNYXRyaXgpO1xuXG5mdW5jdGlvbiBzZXR1cFBpeGVsRWZmZWN0VW5pZm9ybXMoZ2wsIGVmZmVjdHMsIHVuaWZvcm1zKSB7XG4gIHZhciBvcGFjaXR5ID0gZGVmYXVsdE9wYWNpdHk7XG4gIGlmIChlZmZlY3RzICYmIGVmZmVjdHMub3BhY2l0eSAhPSBudWxsKSB7XG4gICAgb3BhY2l0eSA9IGVmZmVjdHMub3BhY2l0eTtcbiAgfVxuICBnbC51bmlmb3JtMWYodW5pZm9ybXMub3BhY2l0eSwgb3BhY2l0eSk7XG5cbiAgdmFyIGNvbG9yT2Zmc2V0ID0gZGVmYXVsdENvbG9yT2Zmc2V0O1xuICBpZiAoZWZmZWN0cyAmJiBlZmZlY3RzLmNvbG9yT2Zmc2V0KSB7XG4gICAgY29sb3JPZmZzZXQgPSBlZmZlY3RzLmNvbG9yT2Zmc2V0O1xuICB9XG4gIGdsLnVuaWZvcm00ZnYodW5pZm9ybXMuY29sb3JPZmZzZXQsIGNvbG9yT2Zmc2V0KTtcblxuICB2YXIgY29sb3JNYXRyaXggPSBkZWZhdWx0Q29sb3JNYXRyaXg7XG4gIGlmIChlZmZlY3RzICYmIGVmZmVjdHMuY29sb3JNYXRyaXgpIHtcbiAgICBjb2xvck1hdHJpeCA9IGVmZmVjdHMuY29sb3JNYXRyaXg7XG4gIH1cbiAgZ2wudW5pZm9ybU1hdHJpeDRmdih1bmlmb3Jtcy5jb2xvck1hdHJpeCwgZmFsc2UsIGNvbG9yTWF0cml4KTtcbn1cblxuXG4vLyBUZW1wb3JhcnkgdmVjdG9ycyBmb3Igc2V0Vmlld3BvcnQuXG52YXIgdHJhbnNsYXRlVmVjdG9yID0gdmVjMy5jcmVhdGUoKTtcbnZhciBzY2FsZVZlY3RvciA9IHZlYzMuY3JlYXRlKCk7XG5cblxuLy8gU2V0cyB0aGUgV2ViR0wgdmlld3BvcnQgYW5kIHJldHVybnMgYSB2aWV3cG9ydCBjbGFtcGluZyBjb21wZW5zYXRpb24gbWF0cml4LlxuLy9cbi8vIE5lZ2F0aXZlIHZpZXdwb3J0IG9yaWdpbiBjb29yZGluYXRlcyBjYXVzZSByZW5kZXJpbmcgaXNzdWVzLiBMZXR0aW5nIHRoZVxuLy8gdmlld3BvcnQgZGltZW5zaW9ucyBleHRlbmQgYmV5b25kIHRoZSB2aXNpYmxlIGFyZWEgZG8gbm90IHNlZW0gdG8gY2F1c2Vcbi8vIHJlbmRlcmluZyBpc3N1ZXMsIGJ1dCB0aGV5IG1heSBzdGlsbCBoYXZlIGFuIGltcGFjdCBvbiBwZXJmb3JtYW5jZS5cbi8vIFRoZXJlZm9yZSwgd2hlbiB0aGUgc2NlbmUncyByZWN0IGlzIG5vdCBmdWxseSBjb250YWluZWQgaW4gdGhlIHJlbmRlcmluZ1xuLy8gYXJlYSwgd2UgY2xhbXAgdGhlIHZpZXdwb3J0IHRvIHRoZSByZW5kZXJpbmcgYXJlYSwgYW5kIHJldHVybiBhIGNvbXBlbnNhdGlvblxuLy8gbWF0cml4IHRvIHNjYWxlIGFuZCB0cmFuc2xhdGUgdmVydGljZXMgYWNjb3JkaW5nbHkuXG5mdW5jdGlvbiBzZXRWaWV3cG9ydChnbCwgbGF5ZXIsIHJlY3QsIHZpZXdwb3J0TWF0cml4KSB7XG4gIGlmIChyZWN0LnggPT09IDAgJiYgcmVjdC53aWR0aCA9PT0gMSAmJiByZWN0LnkgPT09IDAgJiYgcmVjdC5oZWlnaHQgPT09IDEpIHtcbiAgICAvLyBGYXN0IHBhdGggZm9yIGZ1bGwgcmVjdC5cbiAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgIG1hdDQuaWRlbnRpdHkodmlld3BvcnRNYXRyaXgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBvZmZzZXRYID0gcmVjdC54O1xuICB2YXIgY2xhbXBlZE9mZnNldFggPSBjbGFtcChvZmZzZXRYLCAwLCAxKTtcbiAgdmFyIGxlZnRFeGNlc3MgPSBjbGFtcGVkT2Zmc2V0WCAtIG9mZnNldFg7XG4gIHZhciBtYXhDbGFtcGVkV2lkdGggPSAxIC0gY2xhbXBlZE9mZnNldFg7XG4gIHZhciBjbGFtcGVkV2lkdGggPSBjbGFtcChyZWN0LndpZHRoIC0gbGVmdEV4Y2VzcywgMCwgbWF4Q2xhbXBlZFdpZHRoKTtcbiAgdmFyIHJpZ2h0RXhjZXNzID0gcmVjdC53aWR0aCAtIGNsYW1wZWRXaWR0aDtcblxuICB2YXIgb2Zmc2V0WSA9IDEgLSByZWN0LmhlaWdodCAtIHJlY3QueTtcbiAgdmFyIGNsYW1wZWRPZmZzZXRZID0gY2xhbXAob2Zmc2V0WSwgMCwgMSk7XG4gIHZhciBib3R0b21FeGNlc3MgPSBjbGFtcGVkT2Zmc2V0WSAtIG9mZnNldFk7XG4gIHZhciBtYXhDbGFtcGVkSGVpZ2h0ID0gMSAtIGNsYW1wZWRPZmZzZXRZO1xuICB2YXIgY2xhbXBlZEhlaWdodCA9IGNsYW1wKHJlY3QuaGVpZ2h0IC0gYm90dG9tRXhjZXNzLCAwLCBtYXhDbGFtcGVkSGVpZ2h0KTtcbiAgdmFyIHRvcEV4Y2VzcyA9IHJlY3QuaGVpZ2h0IC0gY2xhbXBlZEhlaWdodDtcblxuICB2ZWMzLnNldChcbiAgICBzY2FsZVZlY3RvcixcbiAgICByZWN0LndpZHRoIC8gY2xhbXBlZFdpZHRoLFxuICAgIHJlY3QuaGVpZ2h0IC8gY2xhbXBlZEhlaWdodCxcbiAgICAxKTtcblxuICB2ZWMzLnNldChcbiAgICB0cmFuc2xhdGVWZWN0b3IsXG4gICAgKHJpZ2h0RXhjZXNzIC0gbGVmdEV4Y2VzcykgLyBjbGFtcGVkV2lkdGgsXG4gICAgKHRvcEV4Y2VzcyAtIGJvdHRvbUV4Y2VzcykgLyBjbGFtcGVkSGVpZ2h0LFxuICAgIDApO1xuXG4gIG1hdDQuaWRlbnRpdHkodmlld3BvcnRNYXRyaXgpO1xuICBtYXQ0LnRyYW5zbGF0ZSh2aWV3cG9ydE1hdHJpeCwgdmlld3BvcnRNYXRyaXgsIHRyYW5zbGF0ZVZlY3Rvcik7XG4gIG1hdDQuc2NhbGUodmlld3BvcnRNYXRyaXgsIHZpZXdwb3J0TWF0cml4LCBzY2FsZVZlY3Rvcik7XG5cbiAgZ2wudmlld3BvcnQoZ2wuZHJhd2luZ0J1ZmZlcldpZHRoICogY2xhbXBlZE9mZnNldFgsXG4gICAgICAgICAgICAgIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQgKiBjbGFtcGVkT2Zmc2V0WSxcbiAgICAgICAgICAgICAgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoICogY2xhbXBlZFdpZHRoLFxuICAgICAgICAgICAgICBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0ICogY2xhbXBlZEhlaWdodCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVTaGFkZXJQcm9ncmFtOiBjcmVhdGVTaGFkZXJQcm9ncmFtLFxuICBkZXN0cm95U2hhZGVyUHJvZ3JhbTogZGVzdHJveVNoYWRlclByb2dyYW0sXG4gIGNyZWF0ZUNvbnN0YW50QnVmZmVyczogY3JlYXRlQ29uc3RhbnRCdWZmZXJzLFxuICBkZXN0cm95Q29uc3RhbnRCdWZmZXJzOiBkZXN0cm95Q29uc3RhbnRCdWZmZXJzLFxuICBlbmFibGVBdHRyaWJ1dGVzOiBlbmFibGVBdHRyaWJ1dGVzLFxuICBkaXNhYmxlQXR0cmlidXRlczogZGlzYWJsZUF0dHJpYnV0ZXMsXG4gIHNldFRleHR1cmU6IHNldFRleHR1cmUsXG4gIHNldERlcHRoOiBzZXREZXB0aCxcbiAgc2V0Vmlld3BvcnQ6IHNldFZpZXdwb3J0LFxuICBzZXR1cFBpeGVsRWZmZWN0VW5pZm9ybXM6IHNldHVwUGl4ZWxFZmZlY3RVbmlmb3Jtc1xufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFdlYkdsQmFzZVJlbmRlcmVyID0gcmVxdWlyZSgnLi9XZWJHbEJhc2UnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWwvaW5oZXJpdHMnKTtcblxuLyoqXG4gKiBAY2xhc3MgV2ViR2xDdWJlUmVuZGVyZXJcbiAqIEBpbXBsZW1lbnRzIFJlbmRlcmVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSByZW5kZXJlciBmb3Ige0BsaW5rIEN1YmVHZW9tZXRyeX0gYW5kIHtAbGluayBSZWN0aWxpbmVhclZpZXd9LCBhcHByb3ByaWF0ZVxuICogZm9yIGEge0BsaW5rIFdlYkdsU3RhZ2V9LlxuICpcbiAqIE1vc3QgdXNlcnMgZG8gbm90IG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcyBjbGFzcy4gUmVuZGVyZXJzIGFyZSBjcmVhdGVkIGFuZFxuICogZGVzdHJveWVkIGJ5IHtAbGluayBTdGFnZX0gYXMgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBXZWJHbEN1YmVSZW5kZXJlcigpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdHMoV2ViR2xDdWJlUmVuZGVyZXIsIFdlYkdsQmFzZVJlbmRlcmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJHbEN1YmVSZW5kZXJlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBXZWJHbENvbW1vbiA9IHJlcXVpcmUoJy4vV2ViR2xDb21tb24nKTtcbnZhciBjcmVhdGVDb25zdGFudEJ1ZmZlcnMgPSBXZWJHbENvbW1vbi5jcmVhdGVDb25zdGFudEJ1ZmZlcnM7XG52YXIgZGVzdHJveUNvbnN0YW50QnVmZmVycyA9IFdlYkdsQ29tbW9uLmRlc3Ryb3lDb25zdGFudEJ1ZmZlcnM7XG52YXIgY3JlYXRlU2hhZGVyUHJvZ3JhbSA9IFdlYkdsQ29tbW9uLmNyZWF0ZVNoYWRlclByb2dyYW07XG52YXIgZGVzdHJveVNoYWRlclByb2dyYW0gPSBXZWJHbENvbW1vbi5kZXN0cm95U2hhZGVyUHJvZ3JhbTtcbnZhciBlbmFibGVBdHRyaWJ1dGVzID0gV2ViR2xDb21tb24uZW5hYmxlQXR0cmlidXRlcztcbnZhciBkaXNhYmxlQXR0cmlidXRlcyA9IFdlYkdsQ29tbW9uLmRpc2FibGVBdHRyaWJ1dGVzO1xudmFyIHNldFZpZXdwb3J0ID0gV2ViR2xDb21tb24uc2V0Vmlld3BvcnQ7XG52YXIgc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zID0gV2ViR2xDb21tb24uc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zO1xuXG52YXIgc2V0RGVwdGggPSBXZWJHbENvbW1vbi5zZXREZXB0aDtcbnZhciBzZXRUZXh0dXJlID0gV2ViR2xDb21tb24uc2V0VGV4dHVyZTtcblxudmFyIHZlcnRleFNyYyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvdmVydGV4RXF1aXJlY3QnKTtcbnZhciBmcmFnbWVudFNyYyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvZnJhZ21lbnRFcXVpcmVjdCcpO1xuXG52YXIgdmVydGV4SW5kaWNlcyA9IFswLCAxLCAyLCAwLCAyLCAzXTtcbnZhciB2ZXJ0ZXhQb3NpdGlvbnMgPSBbLTEuMCwgLTEuMCwgMC4wLCAxLjAsIC0xLjAsIDAuMCwgMS4wLCAxLjAsIDAuMCwgLTEuMCwgMS4wLCAwLjBdO1xudmFyIHRleHR1cmVDb29yZHMgPSBbMC4wLCAwLjAsIDEuMCwgMC4wLCAxLjAsIDEuMCwgMC4wLCAxLjBdO1xuXG52YXIgYXR0cmliTGlzdCA9IFsnYVZlcnRleFBvc2l0aW9uJ107XG52YXIgdW5pZm9ybUxpc3QgPSBbXG4gICd1RGVwdGgnLCAndU9wYWNpdHknLCAndVNhbXBsZXInLCAndUludlByb2pNYXRyaXgnLCAndVZpZXdwb3J0TWF0cml4JyxcbiAgJ3VDb2xvck9mZnNldCcsICd1Q29sb3JNYXRyaXgnLCAndVRleHR1cmVYJywgJ3VUZXh0dXJlWScsICd1VGV4dHVyZVdpZHRoJyxcbiAgJ3VUZXh0dXJlSGVpZ2h0J1xuXTtcblxuXG4vKipcbiAqIEBjbGFzcyBXZWJHbEVxdWlyZWN0UmVuZGVyZXJcbiAqIEBpbXBsZW1lbnRzIFJlbmRlcmVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSByZW5kZXJlciBmb3Ige0BsaW5rIEVxdWlyZWN0R2VvbWV0cnl9IGFuZCB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3fSxcbiAqIGFwcHJvcHJpYXRlIGZvciB7QGxpbmsgV2ViR2xTdGFnZX0uXG4gKlxuICogTW9zdCB1c2VycyBkbyBub3QgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzIGNsYXNzLiBSZW5kZXJlcnMgYXJlIGNyZWF0ZWQgYW5kXG4gKiBkZXN0cm95ZWQgYnkge0BsaW5rIFN0YWdlfSBhcyBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIFdlYkdsRXF1aXJlY3RSZW5kZXJlcihnbCkge1xuICB0aGlzLmdsID0gZ2w7XG5cbiAgLy8gVGhlIGludmVyc2UgcHJvamVjdGlvbiBtYXRyaXguXG4gIHRoaXMuaW52UHJvak1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgLy8gVGhlIHZpZXdwb3J0IG1hdHJpeCByZXNwb25zaWJsZSBmb3Igdmlld3BvcnQgY2xhbXBpbmcuXG4gIC8vIFNlZSBzZXRWaWV3cG9ydCgpIGZvciBhbiBleHBsYW5hdGlvbiBvZiBob3cgaXQgd29ya3MuXG4gIHRoaXMudmlld3BvcnRNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gIHRoaXMuY29uc3RhbnRCdWZmZXJzID0gY3JlYXRlQ29uc3RhbnRCdWZmZXJzKGdsLCB2ZXJ0ZXhJbmRpY2VzLCB2ZXJ0ZXhQb3NpdGlvbnMsIHRleHR1cmVDb29yZHMpO1xuXG4gIHRoaXMuc2hhZGVyUHJvZ3JhbSA9IGNyZWF0ZVNoYWRlclByb2dyYW0oZ2wsIHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIGF0dHJpYkxpc3QsIHVuaWZvcm1MaXN0KTtcbn1cblxuV2ViR2xFcXVpcmVjdFJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGRlc3Ryb3lDb25zdGFudEJ1ZmZlcnModGhpcy5nbCwgdGhpcy5jb25zdGFudEJ1ZmZlcnMpO1xuICBkZXN0cm95U2hhZGVyUHJvZ3JhbSh0aGlzLmdsLCB0aGlzLnNoYWRlclByb2dyYW0pO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbldlYkdsRXF1aXJlY3RSZW5kZXJlci5wcm90b3R5cGUuc3RhcnRMYXllciA9IGZ1bmN0aW9uKGxheWVyLCByZWN0KSB7XG4gIHZhciBnbCA9IHRoaXMuZ2w7XG4gIHZhciBzaGFkZXJQcm9ncmFtID0gdGhpcy5zaGFkZXJQcm9ncmFtO1xuICB2YXIgY29uc3RhbnRCdWZmZXJzID0gdGhpcy5jb25zdGFudEJ1ZmZlcnM7XG4gIHZhciBpbnZQcm9qTWF0cml4ID0gdGhpcy5pbnZQcm9qTWF0cml4O1xuICB2YXIgdmlld3BvcnRNYXRyaXggPSB0aGlzLnZpZXdwb3J0TWF0cml4O1xuXG4gIGdsLnVzZVByb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG5cbiAgZW5hYmxlQXR0cmlidXRlcyhnbCwgc2hhZGVyUHJvZ3JhbSk7XG5cbiAgc2V0Vmlld3BvcnQoZ2wsIGxheWVyLCByZWN0LCB2aWV3cG9ydE1hdHJpeCk7XG4gIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyUHJvZ3JhbS51Vmlld3BvcnRNYXRyaXgsIGZhbHNlLCB2aWV3cG9ydE1hdHJpeCk7XG5cbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGNvbnN0YW50QnVmZmVycy52ZXJ0ZXhQb3NpdGlvbnMpO1xuICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlclByb2dyYW0uYVZlcnRleFBvc2l0aW9uLCAzLCBnbC5GTE9BVCwgZ2wuRkFMU0UsIDAsIDApO1xuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgY29uc3RhbnRCdWZmZXJzLnRleHR1cmVDb29yZHMpO1xuXG4gIC8vIENvbXB1dGUgYW5kIHNldCB0aGUgaW52ZXJzZSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAgbWF0NC5jb3B5KGludlByb2pNYXRyaXgsIGxheWVyLnZpZXcoKS5wcm9qZWN0aW9uKCkpO1xuICBtYXQ0LmludmVydChpbnZQcm9qTWF0cml4LCBpbnZQcm9qTWF0cml4KTtcblxuICBnbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclByb2dyYW0udUludlByb2pNYXRyaXgsIGZhbHNlLCBpbnZQcm9qTWF0cml4KTtcblxuICAvLyBDb21wdXRlIGFuZCBzZXQgdGhlIHRleHR1cmUgc2NhbGUgYW5kIGNyb3Agb2Zmc2V0cy5cbiAgdmFyIHRleHR1cmVDcm9wID0gbGF5ZXIuZWZmZWN0cygpLnRleHR1cmVDcm9wIHx8IHt9O1xuICB2YXIgdGV4dHVyZVggPSB0ZXh0dXJlQ3JvcC54ICE9IG51bGwgPyB0ZXh0dXJlQ3JvcC54IDogMDtcbiAgdmFyIHRleHR1cmVZID0gdGV4dHVyZUNyb3AueSAhPSBudWxsID8gdGV4dHVyZUNyb3AueSA6IDA7XG4gIHZhciB0ZXh0dXJlV2lkdGggPSB0ZXh0dXJlQ3JvcC53aWR0aCAhPSBudWxsID8gdGV4dHVyZUNyb3Aud2lkdGggOiAxO1xuICB2YXIgdGV4dHVyZUhlaWdodCA9IHRleHR1cmVDcm9wLmhlaWdodCAhPSBudWxsID8gdGV4dHVyZUNyb3AuaGVpZ2h0IDogMTtcblxuICBnbC51bmlmb3JtMWYoc2hhZGVyUHJvZ3JhbS51VGV4dHVyZVgsIHRleHR1cmVYKTtcbiAgZ2wudW5pZm9ybTFmKHNoYWRlclByb2dyYW0udVRleHR1cmVZLCB0ZXh0dXJlWSk7XG4gIGdsLnVuaWZvcm0xZihzaGFkZXJQcm9ncmFtLnVUZXh0dXJlV2lkdGgsIHRleHR1cmVXaWR0aCk7XG4gIGdsLnVuaWZvcm0xZihzaGFkZXJQcm9ncmFtLnVUZXh0dXJlSGVpZ2h0LCB0ZXh0dXJlSGVpZ2h0KTtcblxuICBzZXR1cFBpeGVsRWZmZWN0VW5pZm9ybXMoZ2wsIGxheWVyLmVmZmVjdHMoKSwge1xuICAgIG9wYWNpdHk6IHNoYWRlclByb2dyYW0udU9wYWNpdHksXG4gICAgY29sb3JPZmZzZXQ6IHNoYWRlclByb2dyYW0udUNvbG9yT2Zmc2V0LFxuICAgIGNvbG9yTWF0cml4OiBzaGFkZXJQcm9ncmFtLnVDb2xvck1hdHJpeFxuICB9KTtcbn07XG5cblxuV2ViR2xFcXVpcmVjdFJlbmRlcmVyLnByb3RvdHlwZS5lbmRMYXllciA9IGZ1bmN0aW9uKGxheWVyLCByZWN0KSB7XG4gIHZhciBnbCA9IHRoaXMuZ2w7XG4gIHZhciBzaGFkZXJQcm9ncmFtID0gdGhpcy5zaGFkZXJQcm9ncmFtO1xuICBkaXNhYmxlQXR0cmlidXRlcyhnbCwgc2hhZGVyUHJvZ3JhbSk7XG59O1xuXG5cbldlYkdsRXF1aXJlY3RSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVGlsZSA9IGZ1bmN0aW9uKHRpbGUsIHRleHR1cmUsIGxheWVyLCBsYXllclopIHtcbiAgdmFyIGdsID0gdGhpcy5nbDtcbiAgdmFyIHNoYWRlclByb2dyYW0gPSB0aGlzLnNoYWRlclByb2dyYW07XG4gIHZhciBjb25zdGFudEJ1ZmZlcnMgPSB0aGlzLmNvbnN0YW50QnVmZmVycztcblxuICBzZXREZXB0aChnbCwgc2hhZGVyUHJvZ3JhbSwgbGF5ZXJaLCB0aWxlLnopO1xuXG4gIHNldFRleHR1cmUoZ2wsIHNoYWRlclByb2dyYW0sIHRleHR1cmUpO1xuXG4gIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGNvbnN0YW50QnVmZmVycy52ZXJ0ZXhJbmRpY2VzKTtcbiAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdmVydGV4SW5kaWNlcy5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJHbEVxdWlyZWN0UmVuZGVyZXI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBXZWJHbEJhc2VSZW5kZXJlciA9IHJlcXVpcmUoJy4vV2ViR2xCYXNlJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlsL2luaGVyaXRzJyk7XG5cbi8qKlxuICogQGNsYXNzIFdlYkdsRmxhdFJlbmRlcmVyXG4gKiBAaW1wbGVtZW50cyBSZW5kZXJlclxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgcmVuZGVyZXIgZm9yIHtAbGluayBGbGF0R2VvbWV0cnl9IGFuZCB7QGxpbmsgRmxhdFZpZXd9LCBhcHByb3ByaWF0ZSBmb3IgYVxuICoge0BsaW5rIFdlYkdsU3RhZ2V9LlxuICpcbiAqIE1vc3QgdXNlcnMgZG8gbm90IG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcyBjbGFzcy4gUmVuZGVyZXJzIGFyZSBjcmVhdGVkIGFuZFxuICogZGVzdHJveWVkIGJ5IHtAbGluayBTdGFnZX0gYXMgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBXZWJHbEZsYXRSZW5kZXJlcigpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdHMoV2ViR2xGbGF0UmVuZGVyZXIsIFdlYkdsQmFzZVJlbmRlcmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJHbEZsYXRSZW5kZXJlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFdlYkdsQ3ViZSA9IHJlcXVpcmUoJy4vV2ViR2xDdWJlJyk7XG52YXIgV2ViR2xGbGF0ID0gcmVxdWlyZSgnLi9XZWJHbEZsYXQnKTtcbnZhciBXZWJHbEVxdWlyZWN0ID0gcmVxdWlyZSgnLi9XZWJHbEVxdWlyZWN0Jyk7XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFsbCBrbm93biByZW5kZXJlcnMgZm9yIHRoZSBnaXZlbiBzdGFnZSB0eXBlIGludG8gdGhhdCBzdGFnZS5cbiAqIE1vc3QgdXNlcnMgd2lsbCBub3QgbmVlZCB0byByZWdpc3RlciByZW5kZXJlcnMsIGFzIHtAbGluayBWaWV3ZXJ9IGRvZXMgaXQgZm9yXG4gKiB0aGVtLlxuICpcbiAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlIFRoZSBzdGFnZSB3aGVyZSB0aGUgcmVuZGVyZXJzIGFyZSB0byBiZSByZWdpc3RlcmVkLlxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgc3RhZ2UgdHlwZSBpcyB1bmtub3duLlxuICovXG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRSZW5kZXJlcnMoc3RhZ2UpIHtcbiAgc3dpdGNoIChzdGFnZS50eXBlKSB7XG4gICAgY2FzZSAnd2ViZ2wnOlxuICAgICAgc3RhZ2UucmVnaXN0ZXJSZW5kZXJlcignZmxhdCcsICdmbGF0JywgV2ViR2xGbGF0KTtcbiAgICAgIHN0YWdlLnJlZ2lzdGVyUmVuZGVyZXIoJ2N1YmUnLCAncmVjdGlsaW5lYXInLCBXZWJHbEN1YmUpO1xuICAgICAgc3RhZ2UucmVnaXN0ZXJSZW5kZXJlcignZXF1aXJlY3QnLCAncmVjdGlsaW5lYXInLCBXZWJHbEVxdWlyZWN0KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gc3RhZ2UgdHlwZTogJyArIHN0YWdlLnR5cGUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXJEZWZhdWx0UmVuZGVyZXJzO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbicjaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0gnLFxuJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDsnLFxuJyNlbHNlJyxcbidwcmVjaXNpb24gbWVkaXVtcCBmbG9hdCcsXG4nI2VuZGlmJyxcblxuJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG4ndW5pZm9ybSBmbG9hdCB1T3BhY2l0eTsnLFxuJ3VuaWZvcm0gZmxvYXQgdVRleHR1cmVYOycsXG4ndW5pZm9ybSBmbG9hdCB1VGV4dHVyZVk7Jyxcbid1bmlmb3JtIGZsb2F0IHVUZXh0dXJlV2lkdGg7Jyxcbid1bmlmb3JtIGZsb2F0IHVUZXh0dXJlSGVpZ2h0OycsXG4ndW5pZm9ybSB2ZWM0IHVDb2xvck9mZnNldDsnLFxuJ3VuaWZvcm0gbWF0NCB1Q29sb3JNYXRyaXg7JyxcblxuJ3ZhcnlpbmcgdmVjNCB2UmF5OycsXG5cbidjb25zdCBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQ7JyxcblxuJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbicgIGZsb2F0IHIgPSBpbnZlcnNlc3FydCh2UmF5LnggKiB2UmF5LnggKyB2UmF5LnkgKiB2UmF5LnkgKyB2UmF5LnogKiB2UmF5LnopOycsXG4nICBmbG9hdCBwaGkgID0gYWNvcyh2UmF5LnkgKiByKTsnLFxuJyAgZmxvYXQgdGhldGEgPSBhdGFuKHZSYXkueCwgLTEuMCp2UmF5LnopOycsXG4nICBmbG9hdCBzID0gMC41ICsgMC41ICogdGhldGEgLyBQSTsnLFxuJyAgZmxvYXQgdCA9IDEuMCAtIHBoaSAvIFBJOycsXG5cbicgIHMgPSBzICogdVRleHR1cmVXaWR0aCArIHVUZXh0dXJlWDsnLFxuJyAgdCA9IHQgKiB1VGV4dHVyZUhlaWdodCArIHVUZXh0dXJlWTsnLFxuXG4nICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHMsIHQpKSAqIHVDb2xvck1hdHJpeCArIHVDb2xvck9mZnNldDsnLFxuJyAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvci5yZ2JhICogdU9wYWNpdHkpOycsXG4nfSdcbl0uam9pbignXFxuJyk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuJyNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSCcsXG4ncHJlY2lzaW9uIGhpZ2hwIGZsb2F0OycsXG4nI2Vsc2UnLFxuJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4nI2VuZGlmJyxcblxuJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG4ndW5pZm9ybSBmbG9hdCB1T3BhY2l0eTsnLFxuJ3VuaWZvcm0gdmVjNCB1Q29sb3JPZmZzZXQ7Jyxcbid1bmlmb3JtIG1hdDQgdUNvbG9yTWF0cml4OycsXG5cbid2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuXG4ndm9pZCBtYWluKHZvaWQpIHsnLFxuJyAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB1Q29sb3JNYXRyaXggKyB1Q29sb3JPZmZzZXQ7JyxcbicgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IucmdiYSAqIHVPcGFjaXR5KTsnLFxuJ30nXG5dLmpvaW4oJ1xcbicpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbidhdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247JyxcblxuJ3VuaWZvcm0gZmxvYXQgdURlcHRoOycsXG4ndW5pZm9ybSBtYXQ0IHVWaWV3cG9ydE1hdHJpeDsnLFxuJ3VuaWZvcm0gbWF0NCB1SW52UHJvak1hdHJpeDsnLFxuXG4ndmFyeWluZyB2ZWM0IHZSYXk7JyxcblxuJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbicgIHZSYXkgPSB1SW52UHJvak1hdHJpeCAqIHZlYzQoYVZlcnRleFBvc2l0aW9uLnh5LCAxLjAsIDEuMCk7JyxcbicgIGdsX1Bvc2l0aW9uID0gdVZpZXdwb3J0TWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24ueHksIHVEZXB0aCwgMS4wKTsnLFxuJ30nXG5dLmpvaW4oJ1xcbicpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbidhdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247JyxcbidhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkOycsXG5cbid1bmlmb3JtIGZsb2F0IHVEZXB0aDsnLFxuJ3VuaWZvcm0gbWF0NCB1Vmlld3BvcnRNYXRyaXg7Jyxcbid1bmlmb3JtIG1hdDQgdVByb2pNYXRyaXg7JyxcblxuJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG5cbid2b2lkIG1haW4odm9pZCkgeycsXG4nICBnbF9Qb3NpdGlvbiA9IHVWaWV3cG9ydE1hdHJpeCAqIHVQcm9qTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24ueHksIDAuMCwgMS4wKTsnLFxuJyAgZ2xfUG9zaXRpb24ueiA9IHVEZXB0aCAqIGdsX1Bvc2l0aW9uLnc7JyxcbicgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkOycsXG4nfSdcbl0uam9pbignXFxuJyk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBOZXR3b3JrRXJyb3IgPSByZXF1aXJlKCcuLi9OZXR3b3JrRXJyb3InKTtcbnZhciBXb3JrUG9vbCA9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb25zL1dvcmtQb29sJyk7XG52YXIgY2hhaW4gPSByZXF1aXJlKCcuLi91dGlsL2NoYWluJyk7XG52YXIgZGVsYXkgPSByZXF1aXJlKCcuLi91dGlsL2RlbGF5Jyk7XG52YXIgbm93ID0gcmVxdWlyZSgnLi4vdXRpbC9ub3cnKTtcblxuXG4vLyBNYXAgdGVtcGxhdGUgcHJvcGVydGllcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIHRpbGUgcHJvcGVydGllcy5cbnZhciB0ZW1wbGF0ZVByb3BlcnRpZXMgPSB7XG4gIHg6ICd4JyxcbiAgeTogJ3knLFxuICB6OiAneicsXG4gIGY6ICdmYWNlJ1xufTtcblxuLy8gRGVmYXVsdCBmYWNlIG9yZGVyIGZvciBjdWJlIG1hcHMuXG52YXIgZGVmYXVsdEN1YmVNYXBGYWNlT3JkZXIgPSAnYmRmbHJ1JztcblxuLy8gRGVmYXVsdCBtYXhpbXVtIG51bWJlciBvZiBjb25jdXJyZW50IHJlcXVlc3RzLlxudmFyIGRlZmF1bHRDb25jdXJyZW5jeSA9IDQ7XG5cbi8vIERlZmF1bHQgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJldHJ5aW5nIGZhaWxlZCByZXF1ZXN0cy5cbnZhciBkZWZhdWx0UmV0cnlEZWxheSA9IDEwMDAwO1xuXG5cbi8qKlxuICogQGNsYXNzIEltYWdlVXJsU291cmNlXG4gKiBAaW1wbGVtZW50cyBTb3VyY2VcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHtAbGluayBTb3VyY2V9IHRoYXQgbG9hZHMge0BsaW5rIEFzc2V0IGFzc2V0c30gZnJvbSBpbWFnZXMgZ2l2ZW4gYSBVUkwgYW5kXG4gKiBhIGNyb3AgcmVjdGFuZ2xlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNvdXJjZUZyb21UaWxlIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSB0aWxlIGFuZCByZXR1cm5zXG4gKiBhIGB7IHVybCwgcmVjdCB9YCBvYmplY3QsIHdoZXJlIGB1cmxgIGlzIGFuIGltYWdlIFVSTCBhbmQgYHJlY3RgLCB3aGVuXG4gKiBwcmVzZW50LCBpcyBhbiBgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH1gIG9iamVjdCBpbiBub3JtYWxpemVkIGNvb3JkaW5hdGVzXG4gKiBkZW5vdGluZyB0aGUgcG9ydGlvbiBvZiB0aGUgaW1hZ2UgdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5jb25jdXJyZW5jeT00XSBNYXhpbXVtIG51bWJlciBvZiB0aWxlcyB0byByZXF1ZXN0IGF0XG4gKiAgICAgdGhlIHNhbWUgdGltZS4gVGhlIGxpbWl0IGlzIHBlciB7QGxpbmsgSW1hZ2VTb3VyY2VVcmx9IGluc3RhbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnJldHJ5RGVsYXk9MTAwMDBdIFRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlXG4gKiAgICAgcmV0cnlpbmcgYSBmYWlsZWQgcmVxdWVzdC5cbiAqL1xuZnVuY3Rpb24gSW1hZ2VVcmxTb3VyY2Uoc291cmNlRnJvbVRpbGUsIG9wdHMpIHtcblxuICBvcHRzID0gb3B0cyA/IG9wdHMgOiB7fTtcblxuICB0aGlzLl9sb2FkUG9vbCA9IG5ldyBXb3JrUG9vbCh7XG4gICAgY29uY3VycmVuY3k6IG9wdHMuY29uY3VycmVuY3kgfHwgZGVmYXVsdENvbmN1cnJlbmN5XG4gIH0pO1xuXG4gIHRoaXMuX3JldHJ5RGVsYXkgPSBvcHRzLnJldHJ5RGVsYXkgfHwgZGVmYXVsdFJldHJ5RGVsYXk7XG4gIHRoaXMuX3JldHJ5TWFwID0ge307XG5cbiAgdGhpcy5fc291cmNlRnJvbVRpbGUgPSBzb3VyY2VGcm9tVGlsZTtcbn1cblxuZXZlbnRFbWl0dGVyKEltYWdlVXJsU291cmNlKTtcblxuXG5JbWFnZVVybFNvdXJjZS5wcm90b3R5cGUubG9hZEFzc2V0ID0gZnVuY3Rpb24oc3RhZ2UsIHRpbGUsIGRvbmUpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHJldHJ5RGVsYXkgPSB0aGlzLl9yZXRyeURlbGF5O1xuICB2YXIgcmV0cnlNYXAgPSB0aGlzLl9yZXRyeU1hcDtcblxuICB2YXIgdGlsZVNvdXJjZSA9IHRoaXMuX3NvdXJjZUZyb21UaWxlKHRpbGUpO1xuICB2YXIgdXJsID0gdGlsZVNvdXJjZS51cmw7XG4gIHZhciByZWN0ID0gdGlsZVNvdXJjZS5yZWN0O1xuXG4gIHZhciBsb2FkSW1hZ2UgPSBzdGFnZS5sb2FkSW1hZ2UuYmluZChzdGFnZSwgdXJsLCByZWN0KTtcblxuICB2YXIgbG9hZEZuID0gZnVuY3Rpb24oZG9uZSkge1xuICAgIC8vIFRPRE86IERlZHVwbGljYXRlIGxvYWQgcmVxdWVzdHMgZm9yIHRoZSBzYW1lIFVSTC4gQWx0aG91Z2ggdGhlIGJyb3dzZXJcbiAgICAvLyBtaWdodCBiZSBzbWFydCBlbm91Z2ggdG8gYXZvaWQgZHVwbGljYXRlIHJlcXVlc3RzLCB0aGV5IGFyZSBzdGlsbCB1bmR1bHlcbiAgICAvLyBpbXBhY3RlZCBieSB0aGUgY29uY3VycmVuY3kgcGFyYW1ldGVyLlxuICAgIHJldHVybiBzZWxmLl9sb2FkUG9vbC5wdXNoKGxvYWRJbWFnZSwgZnVuY3Rpb24oZXJyLCBhc3NldCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgTmV0d29ya0Vycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSBuZXR3b3JrIGVycm9yIG9jY3VycmVkLCB3YWl0IGJlZm9yZSByZXRyeWluZy5cbiAgICAgICAgICByZXRyeU1hcFt1cmxdID0gbm93KCk7XG4gICAgICAgICAgc2VsZi5lbWl0KCduZXR3b3JrRXJyb3InLCBlcnIsIHRpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUoZXJyLCB0aWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE9uIGEgc3VjY2Vzc2Z1bCBmZXRjaCwgZm9yZ2V0IHRoZSBwcmV2aW91cyB0aW1lb3V0LlxuICAgICAgICBkZWxldGUgcmV0cnlNYXBbdXJsXTtcbiAgICAgICAgZG9uZShudWxsLCB0aWxlLCBhc3NldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ2hlY2sgd2hldGhlciB3ZSBhcmUgcmV0cnlpbmcgYSBmYWlsZWQgcmVxdWVzdC5cbiAgdmFyIGRlbGF5QW1vdW50O1xuICB2YXIgbGFzdFRpbWUgPSByZXRyeU1hcFt1cmxdO1xuICBpZiAobGFzdFRpbWUgIT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50VGltZSA9IG5vdygpO1xuICAgIHZhciBlbGFwc2VkID0gY3VycmVudFRpbWUgLSBsYXN0VGltZTtcbiAgICBpZiAoZWxhcHNlZCA8IHJldHJ5RGVsYXkpIHtcbiAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5aW5nLlxuICAgICAgZGVsYXlBbW91bnQgPSByZXRyeURlbGF5IC0gZWxhcHNlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV0cnkgdGltZW91dCBleHBpcmVkOyBwZXJmb3JtIHRoZSByZXF1ZXN0IGF0IG9uY2UuXG4gICAgICBkZWxheUFtb3VudCA9IDA7XG4gICAgICBkZWxldGUgcmV0cnlNYXBbdXJsXTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsYXlGbiA9IGRlbGF5LmJpbmQobnVsbCwgZGVsYXlBbW91bnQpO1xuXG4gIHJldHVybiBjaGFpbihkZWxheUZuLCBsb2FkRm4pKGRvbmUpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYW4gSW1hZ2VVcmxTb3VyY2UgZnJvbSBhIHN0cmluZyB0ZW1wbGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRpbGUgVVJMIHRlbXBsYXRlLCB3aGljaCBtYXkgY29udGFpbiB0aGUgZm9sbG93aW5nXG4gKiAgICBwbGFjZWhvbGRlcnM6XG4gKiAgICAtIGB7Zn1gIDogdGlsZSBmYWNlIChvbmUgb2YgYGJgLCBgZGAsIGBmYCwgYGxgLCBgcmAsIGB1YClcbiAqICAgIC0gYHt6fWAgOiB0aWxlIGxldmVsIGluZGV4ICgwIGlzIHRoZSBzbWFsbGVzdCBsZXZlbClcbiAqICAgIC0gYHt4fWAgOiB0aWxlIGhvcml6b250YWwgaW5kZXhcbiAqICAgIC0gYHt5fWAgOiB0aWxlIHZlcnRpY2FsIGluZGV4XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBJbiBhZGRpdGlvbiB0byB0aGUgb3B0aW9ucyBhbHJlYWR5IHN1cHBvcnRlZCBieSB0aGVcbiAqICAgICB7QGxpbmsgSW1hZ2VVcmxTb3VyY2V9IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuY3ViZU1hcFByZXZpZXdVcmwgVVJMIHRvIHVzZSBhcyB0aGUgcHJldmlldyBsZXZlbC5cbiAqICAgICBUaGlzIG11c3QgYmUgYSBzaW5nbGUgaW1hZ2UgY29udGFpbmluZyBzaXggY3ViZSBmYWNlcyBsYWlkIG91dFxuICogICAgIHZlcnRpY2FsbHkgYWNjb3JkaW5nIHRvIHRoZSBmYWNlIG9yZGVyIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5jdWJlTWFwUHJldmlld0ZhY2VPcmRlcj0nYmRmbHJ1J10gRmFjZSBvcmRlciB3aXRoaW5cbiAqICAgICB0aGUgcHJldmlldyBpbWFnZS5cbiAqL1xuSW1hZ2VVcmxTb3VyY2UuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHVybCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgZmFjZU9yZGVyID0gb3B0cyAmJiBvcHRzLmN1YmVNYXBQcmV2aWV3RmFjZU9yZGVyIHx8IGRlZmF1bHRDdWJlTWFwRmFjZU9yZGVyO1xuXG4gIHZhciB1cmxGbiA9IG9wdHMuY3ViZU1hcFByZXZpZXdVcmwgPyB3aXRoUHJldmlldyA6IHdpdGhvdXRQcmV2aWV3O1xuXG4gIHJldHVybiBuZXcgSW1hZ2VVcmxTb3VyY2UodXJsRm4sIG9wdHMpO1xuXG4gIGZ1bmN0aW9uIHdpdGhvdXRQcmV2aWV3KHRpbGUpIHtcbiAgICB2YXIgdGlsZVVybCA9IHVybDtcblxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRlbXBsYXRlUHJvcGVydGllcykge1xuICAgICAgdmFyIHRlbXBsYXRlUHJvcGVydHkgPSB0ZW1wbGF0ZVByb3BlcnRpZXNbcHJvcGVydHldO1xuICAgICAgdmFyIHJlZ0V4cCA9IHByb3BlcnR5UmVnRXhwKHByb3BlcnR5KTtcbiAgICAgIHZhciB2YWx1ZUZyb21UaWxlID0gdGlsZS5oYXNPd25Qcm9wZXJ0eSh0ZW1wbGF0ZVByb3BlcnR5KSA/IHRpbGVbdGVtcGxhdGVQcm9wZXJ0eV0gOiAnJztcbiAgICAgIHRpbGVVcmwgPSB0aWxlVXJsLnJlcGxhY2UocmVnRXhwLCB2YWx1ZUZyb21UaWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB1cmw6IHRpbGVVcmwgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhQcmV2aWV3KHRpbGUpIHtcbiAgICBpZiAodGlsZS56ID09PSAwKSB7XG4gICAgICByZXR1cm4gY3ViZU1hcFVybCh0aWxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gd2l0aG91dFByZXZpZXcodGlsZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3ViZU1hcFVybCh0aWxlKSB7XG4gICAgdmFyIHkgPSBmYWNlT3JkZXIuaW5kZXhPZih0aWxlLmZhY2UpIC8gNjtcbiAgICByZXR1cm4ge1xuICAgICAgdXJsOiBvcHRzLmN1YmVNYXBQcmV2aWV3VXJsLFxuICAgICAgcmVjdDogeyB4OiAwLCB5OiB5LCB3aWR0aDogMSwgaGVpZ2h0OiAxLzYgfVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHByb3BlcnR5UmVnRXhwKHByb3BlcnR5KSB7XG4gIHZhciByZWdFeHBTdHIgPSAnXFxcXHsoJyArIHByb3BlcnR5ICsgJylcXFxcfSc7XG4gIHJldHVybiBuZXcgUmVnRXhwKHJlZ0V4cFN0ciwgJ2cnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZVVybFNvdXJjZTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAY2xhc3MgU2luZ2xlQXNzZXRTb3VyY2VcbiAqIEBpbXBsZW1lbnRzIFNvdXJjZVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEge0BsaW5rIFNvdXJjZX0gdGhhdCBhbHdheXMgcHJvdmlkZXMgdGhlIHNhbWUge0BsaW5rIEFzc2V0fS5cbiAqXG4gKiBAcGFyYW0ge0Fzc2V0fSBhc3NldCBUaGUgYXNzZXQuXG4qL1xuZnVuY3Rpb24gU2luZ2xlQXNzZXRTb3VyY2UoYXNzZXQpIHtcbiAgdGhpcy5fYXNzZXQgPSBhc3NldDtcbn1cblxuU2luZ2xlQXNzZXRTb3VyY2UucHJvdG90eXBlLmFzc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9hc3NldDtcbn07XG5cblNpbmdsZUFzc2V0U291cmNlLnByb3RvdHlwZS5sb2FkQXNzZXQgPSBmdW5jdGlvbihzdGFnZSwgdGlsZSwgZG9uZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRvbmUobnVsbCwgdGlsZSwgc2VsZi5fYXNzZXQpO1xuICB9LCAwKTtcblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBjYW5jZWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbmdsZUFzc2V0U291cmNlO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjbGFzcyBSZW5kZXJlclJlZ2lzdHJ5XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSBSZW5kZXJlclJlZ2lzdHJ5IG1hcHMgcGFpcnMgb2Yge0BsaW5rIEdlb21ldHJ5fSBhbmQge0BsaW5rIFZpZXd9IHR5cGUgaW50b1xuICogdGhlIGFwcHJvcHJpYXRlIHtAbGluayBSZW5kZXJlcn0gY2xhc3MuIEl0IGlzIHVzZWQgYnkgYSB7QGxpbmsgU3RhZ2V9IHRvXG4gKiBkZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIHJlbmRlcmVyIGZvciBhIHtAbGluayBMYXllcn0uXG4gKlxuICogU2VlIGFsc28ge0BsaW5rIFN0YWdlI3JlZ2lzdGVyUmVuZGVyZXJ9LlxuICovXG5mdW5jdGlvbiBSZW5kZXJlclJlZ2lzdHJ5KCkge1xuICB0aGlzLl9yZW5kZXJlcnMgPSB7fTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSByZW5kZXJlciBmb3IgdGhlIGdpdmVuIGdlb21ldHJ5IGFuZCB2aWV3IHR5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2VvbWV0cnlUeXBlIFRoZSBnZW9tZXRyeSB0eXBlLCBhcyBnaXZlbiBieVxuICogICAgIHtAbGluayBHZW9tZXRyeSN0eXBlfS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3VHlwZSBUaGUgdmlldyB0eXBlLCBhcyBnaXZlbiBieSB7QGxpbmsgVmlldyN0eXBlfS5cbiAqIEBwYXJhbSB7Kn0gUmVuZGVyZXIgVGhlIHJlbmRlcmVyIGNsYXNzLlxuICovXG5SZW5kZXJlclJlZ2lzdHJ5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihnZW9tZXRyeVR5cGUsIHZpZXdUeXBlLCBSZW5kZXJlcikge1xuICBpZiAoIXRoaXMuX3JlbmRlcmVyc1tnZW9tZXRyeVR5cGVdKSB7XG4gICAgdGhpcy5fcmVuZGVyZXJzW2dlb21ldHJ5VHlwZV0gPSB7fTtcbiAgfVxuICB0aGlzLl9yZW5kZXJlcnNbZ2VvbWV0cnlUeXBlXVt2aWV3VHlwZV0gPSBSZW5kZXJlcjtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSByZW5kZXJlciBmb3IgdGhlIGdpdmVuIGdlb21ldHJ5IGFuZCB2aWV3IHR5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2VvbWV0cnlUeXBlIFRoZSBnZW9tZXRyeSB0eXBlLCBhcyBnaXZlbiBieVxuICogICAgIHtAbGluayBHZW9tZXRyeSN0eXBlfS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3VHlwZSBUaGUgdmlldyB0eXBlLCBhcyBnaXZlbiBieSB7QGxpbmsgVmlldyN0eXBlfS5cbiAqIEBwYXJhbSB7Kn0gUmVuZGVyZXIgVGhlIHJlbmRlcmVyIGNsYXNzLCBvciBudWxsIGlmIG5vIHN1Y2ggcmVuZGVyZXIgaGFzIGJlZW5cbiAqIHJlZ2lzdGVyZWQuXG4gKi9cblJlbmRlcmVyUmVnaXN0cnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGdlb21ldHJ5VHlwZSwgdmlld1R5cGUpIHtcbiAgdmFyIFJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJzW2dlb21ldHJ5VHlwZV0gJiZcbiAgICAgIHRoaXMuX3JlbmRlcmVyc1tnZW9tZXRyeVR5cGVdW3ZpZXdUeXBlXTtcbiAgcmV0dXJuIFJlbmRlcmVyIHx8IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyUmVnaXN0cnk7XG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XHJcbnZhciBXb3JrUXVldWUgPSByZXF1aXJlKCcuLi9jb2xsZWN0aW9ucy9Xb3JrUXVldWUnKTtcclxudmFyIGNhbGNSZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9jYWxjUmVjdCcpO1xyXG52YXIgYXN5bmMgPSByZXF1aXJlKCcuLi91dGlsL2FzeW5jJyk7XHJcbnZhciBjYW5jZWxpemUgPSByZXF1aXJlKCcuLi91dGlsL2NhbmNlbGl6ZScpO1xyXG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcclxuXHJcbnZhciBSZW5kZXJlclJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9SZW5kZXJlclJlZ2lzdHJ5Jyk7XHJcblxyXG5mdW5jdGlvbiBmb3J3YXJkVGlsZUNtcCh0MSwgdDIpIHtcclxuICAgIHJldHVybiB0MS5jbXAodDIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXZlcnNlVGlsZUNtcCh0MSwgdDIpIHtcclxuICAgIHJldHVybiAtdDEuY21wKHQyKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNpZ25hbHMgdGhhdCB0aGUgc3RhZ2UgaGFzIGJlZW4gcmVuZGVyZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhYmxlIFdoZXRoZXIgYWxsIHRpbGVzIHdlcmUgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHdpdGhvdXRcclxuICogICAgIG1pc3NpbmcgdGV4dHVyZXMgb3IgcmVzb3J0aW5nIHRvIGZhbGxiYWNrcy5cclxuICogQGV2ZW50IFN0YWdlI3JlbmRlckNvbXBsZXRlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFNpZ25hbHMgdGhhdCB0aGUgY29udGVudHMgb2YgdGhlIHN0YWdlIGhhdmUgYmVlbiBpbnZhbGlkYXRlZCBhbmQgbXVzdCBiZVxyXG4gKiByZW5kZXJlZCBhZ2Fpbi5cclxuICpcclxuICogVGhpcyBpcyB1c2VkIGJ5IHRoZSB7QGxpbmsgUmVuZGVyTG9vcH0gaW1wbGVtZW50YXRpb24uXHJcbiAqXHJcbiAqIEBldmVudCBTdGFnZSNyZW5kZXJJbnZhbGlkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2UgU3RhZ2VcclxuICogQGNsYXNzZGVzY1xyXG4gKlxyXG4gKiBBIFN0YWdlIGlzIGEgY29udGFpbmVyIHdpdGggdGhlIGFiaWxpdHkgdG8gcmVuZGVyIGEgc3RhY2sgb2ZcclxuICoge0BsaW5rIExheWVyIGxheWVyc30uXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS4gVXNlIHtAbGluayBXZWJHbFN0YWdlfVxyXG4gKiBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnByb2dyZXNzaXZlPWZhbHNlXVxyXG4gKlxyXG4gKiBPcHRpb25zIGxpc3RlZCBoZXJlIG1heSBiZSBwYXNzZWQgaW50byB0aGUgYG9wdHNgIGNvbnN0cnVjdG9yIGFyZ3VtZW50IG9mXHJcbiAqIHN1YmNsYXNzZXMuXHJcbiAqXHJcbiAqIFRoZSBgcHJvZ3Jlc3NpdmVgIG9wdGlvbiBjb250cm9scyB3aGV0aGVyIHJlc29sdXRpb24gbGV2ZWxzIGFyZSBsb2FkZWQgaW5cclxuICogb3JkZXIsIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3QuIFRoaXMgcmVzdWx0cyBpbiBhIG1vcmUgcGxlYXNpbmcgZWZmZWN0IHdoZW5cclxuICogem9vbWluZyBwYXN0IHNldmVyYWwgbGV2ZWxzIGluIGEgbGFyZ2UgcGFub3JhbWFzLCBidXQgY29uc3VtZXMgYWRkaXRpb25hbFxyXG4gKiBiYW5kd2lkdGguXHJcbiAqL1xyXG5mdW5jdGlvbiBTdGFnZShvcHRzKSB7XHJcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZSA9ICEhKG9wdHMgJiYgb3B0cy5wcm9ncmVzc2l2ZSk7XHJcblxyXG4gICAgLy8gVGhlIGxpc3Qgb2YgbGF5ZXJzIGluIGRpc3BsYXkgb3JkZXIgKGJhY2tncm91bmQgdG8gZm9yZWdyb3VuZCkuXHJcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcclxuXHJcbiAgICAvLyBUaGUgbGlzdCBvZiByZW5kZXJlcnM7IHRoZSBpLXRoIHJlbmRlcmVyIGlzIGZvciB0aGUgaS10aCBsYXllci5cclxuICAgIHRoaXMuX3JlbmRlcmVycyA9IFtdO1xyXG5cclxuICAgIC8vIFRoZSBsaXN0cyBvZiB0aWxlcyB0byBsb2FkIGFuZCByZW5kZXIsIHBvcHVsYXRlZCBkdXJpbmcgcmVuZGVyKCkuXHJcbiAgICB0aGlzLl90aWxlc1RvTG9hZCA9IFtdO1xyXG4gICAgdGhpcy5fdGlsZXNUb1JlbmRlciA9IFtdO1xyXG5cclxuICAgIC8vIFRlbXBvcmFyeSB0aWxlIGxpc3RzLlxyXG4gICAgdGhpcy5fdG1wVmlzaWJsZSA9IFtdO1xyXG4gICAgdGhpcy5fdG1wQ2hpbGRyZW4gPSBbXTtcclxuXHJcbiAgICAvLyBDYWNoZWQgc3RhZ2UgZGltZW5zaW9ucy5cclxuICAgIC8vIFN0YXJ0IHdpdGggemVybywgd2hpY2ggaW5oaWJpdHMgcmVuZGVyaW5nIHVudGlsIHNldFNpemUoKSBpcyBjYWxsZWQuXHJcbiAgICB0aGlzLl93aWR0aCA9IDA7XHJcbiAgICB0aGlzLl9oZWlnaHQgPSAwO1xyXG5cclxuICAgIC8vIFRlbXBvcmFyeSB2YXJpYWJsZSBmb3IgcmVjdC5cclxuICAgIHRoaXMuX3RtcFJlY3QgPSB7fTtcclxuXHJcbiAgICAvLyBUZW1wb3JhcnkgdmFyaWFibGUgZm9yIHNpemUuXHJcbiAgICB0aGlzLl90bXBTaXplID0ge307XHJcblxyXG4gICAgLy8gV29yayBxdWV1ZSBmb3IgY3JlYXRlVGV4dHVyZS5cclxuICAgIHRoaXMuX2NyZWF0ZVRleHR1cmVXb3JrUXVldWUgPSBuZXcgV29ya1F1ZXVlKCk7XHJcblxyXG4gICAgLy8gRnVuY3Rpb24gdG8gZW1pdCBldmVudCB3aGVuIHJlbmRlciBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZC5cclxuICAgIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkID0gdGhpcy5fZW1pdFJlbmRlckludmFsaWQuYmluZCh0aGlzKTtcclxuXHJcbiAgICAvLyBUaGUgcmVuZGVyZXIgcmVnaXN0cnkgbWFwcyBlYWNoIGdlb21ldHJ5L3ZpZXcgcGFpciBpbnRvIHRoZSByZXNwZWN0aXZlXHJcbiAgICAvLyBSZW5kZXJlciBjbGFzcy5cclxuICAgIHRoaXMuX3JlbmRlcmVyUmVnaXN0cnkgPSBuZXcgUmVuZGVyZXJSZWdpc3RyeSgpO1xyXG59XHJcblxyXG5ldmVudEVtaXR0ZXIoU3RhZ2UpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBEZXN0cnVjdG9yLlxyXG4gKi9cclxuU3RhZ2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJlbW92ZUFsbExheWVycygpO1xyXG4gICAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYSB7QGxpbmsgUmVuZGVyZXJ9IGZvciB0aGUgZ2l2ZW4ge0BsaW5rIEdlb21ldHJ5fSBhbmQge0BsaW5rIFZpZXd9XHJcbiAqIHR5cGUuXHJcbiAqXHJcbiAqIFRoZSB7QGxpbmsgcmVnaXN0ZXJEZWZhdWx0UmVuZGVyZXJzfSB1dGlsaXR5IGZ1bmN0aW9uIG1heSBiZSB1c2VkIHRvXHJcbiAqIHJlZ2lzdGVyIGFsbCBrbm93biByZW5kZXJlcnMgZm9yIGEgc3RhZ2UgdHlwZSBpbnRvIHRoYXQgc3RhZ2UuIE1vc3QgdXNlcnNcclxuICogd2lsbCBub3QgbmVlZCB0byByZWdpc3RlciByZW5kZXJlcnMsIGFzIHtAbGluayBWaWV3ZXJ9IGRvZXMgaXQgZm9yIHRoZW0uXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBnZW9tZXRyeVR5cGUgVGhlIGdlb21ldHJ5IHR5cGUsIGFzIGdpdmVuIGJ5XHJcbiAqICAgICB7QGxpbmsgR2VvbWV0cnkjdHlwZX0uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3VHlwZSBUaGUgdmlldyB0eXBlLCBhcyBnaXZlbiBieSB7QGxpbmsgVmlldyN0eXBlfS5cclxuICogQHBhcmFtIHsqfSBSZW5kZXJlciBUaGUgcmVuZGVyZXIgY2xhc3MuXHJcbiAqL1xyXG5TdGFnZS5wcm90b3R5cGUucmVnaXN0ZXJSZW5kZXJlciA9IGZ1bmN0aW9uIChnZW9tZXRyeVR5cGUsIHZpZXdUeXBlLCBSZW5kZXJlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyUmVnaXN0cnkuc2V0KGdlb21ldHJ5VHlwZSwgdmlld1R5cGUsIFJlbmRlcmVyKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBET00gZWxlbWVudC5cclxuICpcclxuICogTXVzdCBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAqL1xyXG5TdGFnZS5wcm90b3R5cGUuZG9tRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignU3RhZ2UgaW1wbGVtZW50YXRpb24gbXVzdCBvdmVycmlkZSBkb21FbGVtZW50Jyk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgc3RhZ2Ugd2lkdGguXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICovXHJcblN0YWdlLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLl93aWR0aDtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogR2V0IHRoZSBzdGFnZSBoZWlnaHQuXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICovXHJcblN0YWdlLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHN0YWdlIGRpbWVuc2lvbnMuIElmIGFuIGFyZ3VtZW50IGlzIHN1cHBsaWVkLCBpdCBpcyBmaWxsZWQgaW4gd2l0aFxyXG4gKiB0aGUgcmVzdWx0IGFuZCByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIGZyZXNoIG9iamVjdCBpcyBmaWxsZWQgaW4gYW5kIHJldHVybmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NpemU9fSBzaXplXHJcbiAqL1xyXG5TdGFnZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICBzaXplID0gc2l6ZSB8fCB7fTtcclxuICAgIHNpemUud2lkdGggPSB0aGlzLl93aWR0aDtcclxuICAgIHNpemUuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xyXG4gICAgcmV0dXJuIHNpemU7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgc3RhZ2UgZGltZW5zaW9ucy5cclxuICpcclxuICogVGhpcyBjb250YWlucyB0aGUgc2l6ZSB1cGRhdGUgbG9naWMgY29tbW9uIHRvIGFsbCBzdGFnZSB0eXBlcy4gU3ViY2xhc3Nlc1xyXG4gKiBtdXN0IGRlZmluZSB0aGUge0BsaW5rIFN0YWdlI3NldFNpemVGb3JUeXBlfSBtZXRob2QgdG8gcGVyZm9ybSB0aGVpciBvd25cclxuICogbG9naWMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZVxyXG4gKi9cclxuU3RhZ2UucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgdGhpcy5fd2lkdGggPSBzaXplLndpZHRoO1xyXG4gICAgdGhpcy5faGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcblxyXG4gICAgdGhpcy5zZXRTaXplRm9yVHlwZSgpOyAvLyBtdXN0IGJlIGRlZmluZWQgYnkgc3ViY2xhc3Nlcy5cclxuXHJcbiAgICB0aGlzLmVtaXQoJ3Jlc2l6ZScpO1xyXG4gICAgdGhpcy5fZW1pdFJlbmRlckludmFsaWQoKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ2FsbCB7QGxpbmsgU3RhZ2Ujc2V0U2l6ZX0gaW5zdGVhZC5cclxuICpcclxuICogVGhpcyBjb250YWlucyB0aGUgc2l6ZSB1cGRhdGUgbG9naWMgc3BlY2lmaWMgdG8gYSBzdGFnZSB0eXBlLiBJdCBpcyBjYWxsZWQgYnlcclxuICoge0BsaW5rIFN0YWdlI3NldFNpemV9IGFmdGVyIHRoZSBiYXNlIGNsYXNzIGhhcyBiZWVuIHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGVcclxuICogbmV3IHNpemUsIGJ1dCBiZWZvcmUgYW55IGV2ZW50cyBhcmUgZW1pdHRlZC5cclxuICpcclxuICogQHBhcmFtIHtTaXplfSBzaXplXHJcbiAqL1xyXG5TdGFnZS5wcm90b3R5cGUuc2V0U2l6ZUZvclR5cGUgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdGFnZSBpbXBsZW1lbnRhdGlvbiBtdXN0IG92ZXJyaWRlIHNldFNpemVGb3JUeXBlJyk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIExvYWRzIGFuIHtAbGluayBBc3NldH0gZnJvbSBhbiBpbWFnZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgaW1hZ2UgVVJMLlxyXG4gKiBAcGFyYW0gez9SZWN0fSByZWN0IEEge0BsaW5rIFJlY3R9IGRlc2NyaWJpbmcgYSBwb3J0aW9uIG9mIHRoZSBpbWFnZSwgb3IgbnVsbFxyXG4gKiAgICAgdG8gdXNlIHRoZSBmdWxsIGltYWdlLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvciwgQXNzZXQpfSBkb25lIFRoZSBjYWxsYmFjay5cclxuICogQHJldHVybiB7ZnVuY3Rpb24oKX0gQSBmdW5jdGlvbiB0byBjYW5jZWwgbG9hZGluZy5cclxuICovXHJcblN0YWdlLnByb3RvdHlwZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgbG9hZEltYWdlJyk7XHJcbn07XHJcblxyXG5cclxuU3RhZ2UucHJvdG90eXBlLl9lbWl0UmVuZGVySW52YWxpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZW1pdCgncmVuZGVySW52YWxpZCcpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBWZXJpZmllcyB0aGF0IHRoZSBsYXllciBpcyB2YWxpZCBmb3IgdGhpcyBzdGFnZSwgdGhyb3dpbmcgYW4gZXhjZXB0aW9uXHJcbiAqIG90aGVyd2lzZS5cclxuICpcclxuICogQHBhcmFtIHtMYXllcn0gbGF5ZXJcclxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBsYXllciBpcyBub3QgdmFsaWQgZm9yIHRoaXMgc3RhZ2UuXHJcbiAqL1xyXG5TdGFnZS5wcm90b3R5cGUudmFsaWRhdGVMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdGFnZSBpbXBsZW1lbnRhdGlvbiBtdXN0IG92ZXJyaWRlIHZhbGlkYXRlTGF5ZXInKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHtAbGluayBMYXllciBsYXllcnN9IGJlbG9uZ2luZyB0byB0aGUgc3RhZ2UuIFRoZVxyXG4gKiByZXR1cm5lZCBsaXN0IGlzIGluIGRpc3BsYXkgb3JkZXIsIGJhY2tncm91bmQgdG8gZm9yZWdyb3VuZC5cclxuICogQHJldHVybiB7TGF5ZXJbXX1cclxuICovXHJcblN0YWdlLnByb3RvdHlwZS5saXN0TGF5ZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gUmV0dXJuIGEgY29weSB0byBwcmV2ZW50IHVuaW50ZW5kZWQgbXV0YXRpb24gYnkgdGhlIGNhbGxlci5cclxuICAgIHJldHVybiBbXS5jb25jYXQodGhpcy5fbGF5ZXJzKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmV0dXJuIHdoZXRoZXIgYSB7QGxpbmsgTGF5ZXIgbGF5ZXJ9IGJlbG9uZ3MgdG8gdGhlIHN0YWdlLlxyXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllclxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKi9cclxuU3RhZ2UucHJvdG90eXBlLmhhc0xheWVyID0gZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpID49IDA7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEFkZHMgYSB7QGxpbmsgTGF5ZXIgbGF5ZXJ9IGludG8gdGhlIHN0YWdlLlxyXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gYWRkLlxyXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IGkgVGhlIG9wdGlvbmFsIHBvc2l0aW9uLCB3aGVyZSAwIOKJpCBpIOKJpCBuIGFuZCBuIGlzXHJcbiAqICAgICB0aGUgY3VycmVudCBudW1iZXIgb2YgbGF5ZXJzLiBUaGUgZGVmYXVsdCBpcyBuLCB3aGljaCBpbnNlcnRzIGF0IHRoZVxyXG4gKiAgICAgdG9wIG9mIHRoZSBkaXNwbGF5IHN0YWNrLlxyXG4gKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBsYXllciBhbHJlYWR5IGJlbG9uZ3MgdG8gdGhlIHN0YWdlIG9yIGlmIHRoZSBwb3NpdGlvblxyXG4gKiAgICAgaXMgaW52YWxpZC5cclxuICovXHJcblN0YWdlLnByb3RvdHlwZS5hZGRMYXllciA9IGZ1bmN0aW9uIChsYXllciwgaSkge1xyXG4gICAgaWYgKHRoaXMuX2xheWVycy5pbmRleE9mKGxheWVyKSA+PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMYXllciBhbHJlYWR5IGluIHN0YWdlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGkgPT0gbnVsbCkge1xyXG4gICAgICAgIGkgPSB0aGlzLl9sYXllcnMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgaWYgKGkgPCAwIHx8IGkgPiB0aGlzLl9sYXllcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxheWVyIHBvc2l0aW9uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy52YWxpZGF0ZUxheWVyKGxheWVyKTsgLy8gbXVzdCBiZSBkZWZpbmVkIGJ5IHN1YmNsYXNzZXMuXHJcblxyXG4gICAgdmFyIGdlb21ldHJ5VHlwZSA9IGxheWVyLmdlb21ldHJ5KCkudHlwZTtcclxuICAgIHZhciB2aWV3VHlwZSA9IGxheWVyLnZpZXcoKS50eXBlO1xyXG4gICAgdmFyIHJlbmRlcmVyQ2xhc3MgPSB0aGlzLl9yZW5kZXJlclJlZ2lzdHJ5LmdldChnZW9tZXRyeVR5cGUsIHZpZXdUeXBlKTtcclxuICAgIGlmICghcmVuZGVyZXJDbGFzcykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gJyArIHRoaXMudHlwZSArICcgcmVuZGVyZXIgYXZhaWFibGUgZm9yICcgK1xyXG4gICAgICAgICAgICBnZW9tZXRyeVR5cGUgKyAnIGdlb21ldHJ5IGFuZCAnICsgdmlld1R5cGUgKyAnIHZpZXcnKTtcclxuICAgIH1cclxuICAgIHZhciByZW5kZXJlciA9IHRoaXMuY3JlYXRlUmVuZGVyZXIocmVuZGVyZXJDbGFzcyk7XHJcblxyXG4gICAgdGhpcy5fbGF5ZXJzLnNwbGljZShpLCAwLCBsYXllcik7XHJcbiAgICB0aGlzLl9yZW5kZXJlcnMuc3BsaWNlKGksIDAsIHJlbmRlcmVyKTtcclxuXHJcbiAgICAvLyBMaXN0ZW5lcnMgZm9yIHJlbmRlciBpbnZhbGlkLlxyXG4gICAgbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndmlld0NoYW5nZScsIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKTtcclxuICAgIGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2VmZmVjdHNDaGFuZ2UnLCB0aGlzLl9lbWl0UmVuZGVySW52YWxpZCk7XHJcbiAgICBsYXllci5hZGRFdmVudExpc3RlbmVyKCdmaXhlZExldmVsQ2hhbmdlJywgdGhpcy5fZW1pdFJlbmRlckludmFsaWQpO1xyXG4gICAgbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndGV4dHVyZVN0b3JlQ2hhbmdlJywgdGhpcy5fZW1pdFJlbmRlckludmFsaWQpO1xyXG5cclxuICAgIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKCk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIE1vdmVzIGEge0BsaW5rIExheWVyIGxheWVyfSBpbnRvIGEgZGlmZmVyZW50IHBvc2l0aW9uIGluIHRoZSBkaXNwbGF5IHN0YWNrLlxyXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gbW92ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHBvc2l0aW9uLCB3aGVyZSAwIOKJpCBpIOKJpCBuLTEgYW5kIG4gaXMgdGhlIGN1cnJlbnQgbnVtYmVyXHJcbiAqICAgICBvZiBsYXllcnMuXHJcbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGxheWVyIGRvZXMgbm90IGJlbG9uZyB0byB0aGUgc3RhZ2Ugb3IgaWYgdGhlIHBvc2l0aW9uXHJcbiAqICAgICBpcyBpbnZhbGlkLlxyXG4gKi9cclxuU3RhZ2UucHJvdG90eXBlLm1vdmVMYXllciA9IGZ1bmN0aW9uIChsYXllciwgaSkge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xyXG4gICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBsYXllciBpbiBzdGFnZScpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpIDwgMCB8fCBpID49IHRoaXMuX2xheWVycy5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGF5ZXIgcG9zaXRpb24nKTtcclxuICAgIH1cclxuXHJcbiAgICBsYXllciA9IHRoaXMuX2xheWVycy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xyXG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJzLnNwbGljZShpbmRleCwgMSlbMF07XHJcblxyXG4gICAgdGhpcy5fbGF5ZXJzLnNwbGljZShpLCAwLCBsYXllcik7XHJcbiAgICB0aGlzLl9yZW5kZXJlcnMuc3BsaWNlKGksIDAsIHJlbmRlcmVyKTtcclxuXHJcbiAgICB0aGlzLl9lbWl0UmVuZGVySW52YWxpZCgpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGEge0BsaW5rIExheWVyfSBmcm9tIHRoZSBzdGFnZS5cclxuICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIHJlbW92ZS5cclxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgbGF5ZXIgZG9lcyBub3QgYmVsb25nIHRvIHRoZSBzdGFnZS5cclxuICovXHJcblN0YWdlLnByb3RvdHlwZS5yZW1vdmVMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xyXG4gICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBsYXllciBpbiBzdGFnZScpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZW1vdmVkTGF5ZXIgPSB0aGlzLl9sYXllcnMuc3BsaWNlKGluZGV4LCAxKVswXTtcclxuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVycy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xyXG5cclxuICAgIHRoaXMuZGVzdHJveVJlbmRlcmVyKHJlbmRlcmVyKTtcclxuXHJcbiAgICByZW1vdmVkTGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlld0NoYW5nZScsIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKTtcclxuICAgIHJlbW92ZWRMYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdlZmZlY3RzQ2hhbmdlJywgdGhpcy5fZW1pdFJlbmRlckludmFsaWQpO1xyXG4gICAgcmVtb3ZlZExheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZpeGVkTGV2ZWxDaGFuZ2UnLCB0aGlzLl9lbWl0UmVuZGVySW52YWxpZCk7XHJcbiAgICByZW1vdmVkTGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGV4dHVyZVN0b3JlQ2hhbmdlJywgdGhpcy5fZW1pdFJlbmRlckludmFsaWQpO1xyXG5cclxuICAgIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKCk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYWxsIHtAbGluayBMYXllciBsYXllcnN9IGZyb20gdGhlIHN0YWdlLlxyXG4gKi9cclxuU3RhZ2UucHJvdG90eXBlLnJlbW92ZUFsbExheWVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHdoaWxlICh0aGlzLl9sYXllcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzWzBdKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ2FsbGVkIGJlZm9yZSBhIGZyYW1lIGlzIHJlbmRlcmVkLlxyXG4gKlxyXG4gKiBNdXN0IGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlcy5cclxuICovXHJcblN0YWdlLnByb3RvdHlwZS5zdGFydEZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdGFnZSBpbXBsZW1lbnRhdGlvbiBtdXN0IG92ZXJyaWRlIHN0YXJ0RnJhbWUnKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ2FsbGVkIGFmdGVyIGEgZnJhbWUgaXMgcmVuZGVyZWQuXHJcbiAqXHJcbiAqIE11c3QgYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxyXG4gKi9cclxuU3RhZ2UucHJvdG90eXBlLmVuZEZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdGFnZSBpbXBsZW1lbnRhdGlvbiBtdXN0IG92ZXJyaWRlIGVuZEZyYW1lJyk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlbmRlciB0aGUgY3VycmVudCBmcmFtZS4gVXN1YWxseSBjYWxsZWQgZnJvbSBhIHtAbGluayBSZW5kZXJMb29wfS5cclxuICpcclxuICogVGhpcyBjb250YWlucyB0aGUgcmVuZGVyaW5nIGxvZ2ljIGNvbW1vbiB0byBhbGwgc3RhZ2UgdHlwZXMuIFN1YmNsYXNzZXNcclxuICogZGVmaW5lIHRoZSBzdGFydEZyYW1lKCkgYW5kIGVuZEZyYW1lKCkgbWV0aG9kcyB0byBwZXJmb3JtIHRoZWlyIG93biBsb2dpYy5cclxuICovXHJcblN0YWdlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaSwgajtcclxuXHJcbiAgICB2YXIgdGlsZXNUb0xvYWQgPSB0aGlzLl90aWxlc1RvTG9hZDtcclxuICAgIHZhciB0aWxlc1RvUmVuZGVyID0gdGhpcy5fdGlsZXNUb1JlbmRlcjtcclxuXHJcbiAgICB2YXIgc3RhYmxlU3RhZ2UgPSB0cnVlO1xyXG4gICAgdmFyIHN0YWJsZUxheWVyO1xyXG5cclxuICAgIC8vIEdldCB0aGUgc3RhZ2UgZGltZW5zaW9ucy5cclxuICAgIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xyXG4gICAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcclxuXHJcbiAgICB2YXIgcmVjdCA9IHRoaXMuX3RtcFJlY3Q7XHJcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3RtcFNpemU7XHJcblxyXG4gICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdGFydEZyYW1lKCk7IC8vIGRlZmluZWQgYnkgc3ViY2xhc3Nlc1xyXG5cclxuICAgIC8vIFNpZ25hbCBzdGFydCBvZiBmcmFtZSB0byB0aGUgdGV4dHVyZSBzdG9yZXMuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJzW2ldLnRleHR1cmVTdG9yZSgpLnN0YXJ0RnJhbWUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW5kZXIgbGF5ZXJzLlxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tpXTtcclxuICAgICAgICB2YXIgZWZmZWN0cyA9IGxheWVyLmVmZmVjdHMoKTtcclxuICAgICAgICB2YXIgdmlldyA9IGxheWVyLnZpZXcoKTtcclxuICAgICAgICB2YXIgdGV4dHVyZVN0b3JlID0gbGF5ZXIudGV4dHVyZVN0b3JlKCk7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJzW2ldO1xyXG4gICAgICAgIHZhciBkZXB0aCA9IHRoaXMuX2xheWVycy5sZW5ndGggLSBpO1xyXG4gICAgICAgIHZhciB0aWxlLCB0ZXh0dXJlO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSByZWN0IGVmZmVjdCBpbnRvIGEgbm9ybWFsaXplZCByZWN0LlxyXG4gICAgICAgIC8vIFRPRE86IGF2b2lkIGRvaW5nIHRoaXMgb24gZXZlcnkgZnJhbWUuXHJcbiAgICAgICAgY2FsY1JlY3Qod2lkdGgsIGhlaWdodCwgZWZmZWN0cyAmJiBlZmZlY3RzLnJlY3QsIHJlY3QpO1xyXG5cclxuICAgICAgICBpZiAocmVjdC53aWR0aCA8PSAwIHx8IHJlY3QuaGVpZ2h0IDw9IDApIHtcclxuICAgICAgICAgICAgLy8gU2tpcCByZW5kZXJpbmcgb24gYSBudWxsIHZpZXdwb3J0LlxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdmlldyBzaXplLlxyXG4gICAgICAgIHNpemUud2lkdGggPSByZWN0LndpZHRoICogdGhpcy5fd2lkdGg7XHJcbiAgICAgICAgc2l6ZS5oZWlnaHQgPSByZWN0LmhlaWdodCAqIHRoaXMuX2hlaWdodDtcclxuICAgICAgICB2aWV3LnNldFNpemUoc2l6ZSk7XHJcblxyXG4gICAgICAgIC8vIFNpZ25hbCBzdGFydCBvZiBsYXllciB0byB0aGUgcmVuZGVyZXIuXHJcbiAgICAgICAgcmVuZGVyZXIuc3RhcnRMYXllcihsYXllciwgcmVjdCk7XHJcblxyXG4gICAgICAgIC8vIFdlIHJlbmRlciB3aXRoIGJvdGggYWxwaGEgYmxlbmRpbmcgYW5kIGRlcHRoIHRlc3RpbmcgZW5hYmxlZC4gVGh1cywgd2hlblxyXG4gICAgICAgIC8vIHJlbmRlcmluZyBhIHN1YnNlcXVlbnQgcGl4ZWwgYXQgdGhlIHNhbWUgbG9jYXRpb24gdGhhbiBhbiBleGlzdGluZyBvbmUsXHJcbiAgICAgICAgLy8gdGhlIHN1YnNlcXVlbnQgcGl4ZWwgZ2V0cyBkaXNjYXJkZWQgdW5sZXNzIGl0IGhhcyBzbWFsbGVyIGRlcHRoLCBhbmQgaXNcclxuICAgICAgICAvLyBvdGhlcndpc2UgY29tcG9zaXRlZCB3aXRoIHRoZSBleGlzdGluZyBwaXhlbC5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFdoZW4gdXNpbmcgZmFsbGJhY2sgdGlsZXMgdG8gZmlsbCBhIGdhcCBpbiB0aGUgcHJlZmVycmVkIHJlc29sdXRpb25cclxuICAgICAgICAvLyBsZXZlbCwgd2UgcHJlZmVyIGhpZ2hlciByZXNvbHV0aW9uIGZhbGxiYWNrcyB0byBsb3dlciByZXNvbHV0aW9uIG9uZXMuXHJcbiAgICAgICAgLy8gSG93ZXZlciwgd2hlcmUgZmFsbGJhY2tzIG92ZXJsYXAsIHdlIHdhbnQgaGlnaGVyIHJlc29sdXRpb24gb25lcyB0b1xyXG4gICAgICAgIC8vIHByZXZhaWwsIGFuZCB3ZSBkb24ndCB3YW50IG11bHRpcGxlIGZhbGxiYWNrcyB0byBiZSBjb21wb3NpdGVkIHdpdGggZWFjaFxyXG4gICAgICAgIC8vIG90aGVyLCBhcyB0aGF0IHdvdWxkIHByb2R1Y2UgYSBiYWQgcmVzdWx0IHdoZW4gc2VtaXRyYW5zcGFyZW50IHRleHR1cmVzXHJcbiAgICAgICAgLy8gYXJlIGludm9sdmVkLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gSW4gb3JkZXIgdG8gYWNoaWV2ZSB0aGlzIHdpdGhpbiB0aGUgY29uc3RyYWludHMgb2YgYWxwaGEgYmxlbmRpbmcgYW5kXHJcbiAgICAgICAgLy8gZGVwdGggdGVzdGluZywgdGhlIGRlcHRoIG9mIGEgdGlsZSBtdXN0IGJlIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gaXRzXHJcbiAgICAgICAgLy8gcmVzb2x1dGlvbiwgYW5kIGhpZ2hlci1yZXNvbHV0aW9uIHRpbGVzIG11c3QgYmUgcmVuZGVyZWQgYmVmb3JlIGxvd2VyLVxyXG4gICAgICAgIC8vIHJlc29sdXRpb24gb25lcy5cclxuXHJcbiAgICAgICAgLy8gQ29sbGVjdCB0aGUgbGlzdHMgb2YgdGlsZXMgdG8gbG9hZCBhbmQgcmVuZGVyLlxyXG4gICAgICAgIHN0YWJsZUxheWVyID0gdGhpcy5fY29sbGVjdFRpbGVzKGxheWVyLCB0ZXh0dXJlU3RvcmUpO1xyXG5cclxuICAgICAgICAvLyBNYXJrIGFsbCB0aGUgdGlsZXMgd2hvc2UgdGV4dHVyZXMgbXVzdCBiZSBsb2FkZWQuXHJcbiAgICAgICAgLy8gVGhpcyB3aWxsIGVpdGhlciB0cmlnZ2VyIGxvYWRpbmcgKGZvciB0ZXh0dXJlcyBub3QgeWV0IGxvYWRlZCkgb3JcclxuICAgICAgICAvLyBwcmV2ZW50IHVubG9hZGluZyAoZm9yIHRleHR1cmVzIGFscmVhZHkgbG9hZGVkKS5cclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGlsZXNUb0xvYWQubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgdGlsZSA9IHRpbGVzVG9Mb2FkW2pdO1xyXG4gICAgICAgICAgICB0ZXh0dXJlU3RvcmUubWFya1RpbGUodGlsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW5kZXIgdGlsZXMuXHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHRpbGVzVG9SZW5kZXIubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgdGlsZSA9IHRpbGVzVG9SZW5kZXJbal07XHJcbiAgICAgICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlU3RvcmUudGV4dHVyZSh0aWxlKTtcclxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyVGlsZSh0aWxlLCB0ZXh0dXJlLCBsYXllciwgZGVwdGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGF5ZXIuZW1pdCgncmVuZGVyQ29tcGxldGUnLCBzdGFibGVMYXllcik7XHJcbiAgICAgICAgaWYgKCFzdGFibGVMYXllcikge1xyXG4gICAgICAgICAgICBzdGFibGVTdGFnZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2lnbmFsIGVuZCBvZiBsYXllciB0byB0aGUgcmVuZGVyZXIuXHJcbiAgICAgICAgcmVuZGVyZXIuZW5kTGF5ZXIobGF5ZXIsIHJlY3QpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNpZ25hbCBlbmQgb2YgZnJhbWUgdG8gdGhlIHRleHR1cmUgc3RvcmVzLlxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuX2xheWVyc1tpXS50ZXh0dXJlU3RvcmUoKS5lbmRGcmFtZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZW5kRnJhbWUoKTsgLy8gZGVmaW5lZCBieSBzdWJjbGFzc2VzXHJcblxyXG4gICAgdGhpcy5lbWl0KCdyZW5kZXJDb21wbGV0ZScsIHN0YWJsZVN0YWdlKTtcclxufTtcclxuXHJcblN0YWdlLnByb3RvdHlwZS5fY29sbGVjdFRpbGVzID0gZnVuY3Rpb24gKGxheWVyLCB0ZXh0dXJlU3RvcmUpIHtcclxuICAgIHZhciB0aWxlc1RvTG9hZCA9IHRoaXMuX3RpbGVzVG9Mb2FkO1xyXG4gICAgdmFyIHRpbGVzVG9SZW5kZXIgPSB0aGlzLl90aWxlc1RvUmVuZGVyO1xyXG4gICAgdmFyIHRtcFZpc2libGUgPSB0aGlzLl90bXBWaXNpYmxlO1xyXG5cclxuICAgIHRpbGVzVG9Mb2FkLmxlbmd0aCA9IDA7XHJcbiAgICB0aWxlc1RvUmVuZGVyLmxlbmd0aCA9IDA7XHJcbiAgICB0bXBWaXNpYmxlLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgbGF5ZXIudmlzaWJsZVRpbGVzKHRtcFZpc2libGUpO1xyXG5cclxuICAgIHZhciBpc1N0YWJsZSA9IHRydWU7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bXBWaXNpYmxlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHRpbGUgPSB0bXBWaXNpYmxlW2ldO1xyXG4gICAgICAgIHZhciBuZWVkc0ZhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuX2NvbGxlY3RUaWxlVG9Mb2FkKHRpbGUpO1xyXG4gICAgICAgIGlmICh0ZXh0dXJlU3RvcmUudGV4dHVyZSh0aWxlKSkge1xyXG4gICAgICAgICAgICAvLyBUaGUgcHJlZmVycmVkIHRleHR1cmUgaXMgYXZhaWxhYmxlLlxyXG4gICAgICAgICAgICAvLyBObyBmYWxsYmFjayBpcyByZXF1aXJlZC5cclxuICAgICAgICAgICAgbmVlZHNGYWxsYmFjayA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0VGlsZVRvUmVuZGVyKHRpbGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBwcmVmZXJyZWQgdGV4dHVyZSBpcyB1bmF2YWlsYWJsZS5cclxuICAgICAgICAgICAgLy8gQ29sbGVjdCBjaGlsZHJlbiBmb3IgcmVuZGVyaW5nIGFzIGEgZmFsbGJhY2suXHJcbiAgICAgICAgICAgIG5lZWRzRmFsbGJhY2sgPSB0aGlzLl9jb2xsZWN0Q2hpbGRyZW4odGlsZSwgdGV4dHVyZVN0b3JlKTtcclxuICAgICAgICAgICAgaXNTdGFibGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29sbGVjdCBhbGwgcGFyZW50cyBmb3IgbG9hZGluZywgYW5kIHRoZSBjbG9zZXN0IHBhcmVudCBmb3IgcmVuZGVyaW5nIGlmXHJcbiAgICAgICAgLy8gYSBmYWxsYmFjayBpcyByZXF1aXJlZC5cclxuICAgICAgICB0aGlzLl9jb2xsZWN0UGFyZW50cyh0aWxlLCB0ZXh0dXJlU3RvcmUsIG5lZWRzRmFsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNvcnQgdGlsZXMgdG8gbG9hZCBpbiBhc2NlbmRpbmcgcmVzb2x1dGlvbiBvcmRlci5cclxuICAgIHRpbGVzVG9Mb2FkLnNvcnQoZm9yd2FyZFRpbGVDbXApO1xyXG5cclxuICAgIC8vIFNvcnQgdGlsZXMgdG8gcmVuZGVyIGluIGRlc2NlbmRpbmcgcmVzb2x1dGlvbiBvcmRlci5cclxuICAgIHRpbGVzVG9SZW5kZXIuc29ydChyZXZlcnNlVGlsZUNtcCk7XHJcblxyXG4gICAgcmV0dXJuIGlzU3RhYmxlO1xyXG59O1xyXG5cclxuU3RhZ2UucHJvdG90eXBlLl9jb2xsZWN0Q2hpbGRyZW4gPSBmdW5jdGlvbiAodGlsZSwgdGV4dHVyZVN0b3JlKSB7XHJcbiAgICB2YXIgdG1wQ2hpbGRyZW4gPSB0aGlzLl90bXBDaGlsZHJlbjtcclxuXHJcbiAgICB2YXIgbmVlZHNGYWxsYmFjayA9IHRydWU7XHJcblxyXG4gICAgLy8gRmFsbCBiYWNrIGFzIG1hbnkgbGV2ZWxzIGFzIG5lY2Vzc2FyeSBvbiBzaW5nbGUtY2hpbGQgZ2VvbWV0cmllcywgYnV0IGRvXHJcbiAgICAvLyBub3QgZ28gYmV5b25kIGltbWVkaWF0ZSBjaGlsZHJlbiBvbiBtdWx0aXBsZS1jaGlsZCBnZW9tZXRyaWVzLCB0byBhdm9pZFxyXG4gICAgLy8gZXhwbG9yaW5nIGFuIGV4cG9uZW50aWFsIG51bWJlciBvZiB0aWxlcy5cclxuICAgIGRvIHtcclxuICAgICAgICB0bXBDaGlsZHJlbi5sZW5ndGggPSAwO1xyXG4gICAgICAgIGlmICghdGlsZS5jaGlsZHJlbih0bXBDaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5lZWRzRmFsbGJhY2sgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRpbGUgPSB0bXBDaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgaWYgKHRleHR1cmVTdG9yZS50ZXh0dXJlKHRpbGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsZWN0VGlsZVRvTG9hZCh0aWxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3RUaWxlVG9SZW5kZXIodGlsZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZWVkc0ZhbGxiYWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gd2hpbGUgKG5lZWRzRmFsbGJhY2sgJiYgdG1wQ2hpbGRyZW4ubGVuZ3RoID09PSAxKVxyXG5cclxuICAgIHJldHVybiBuZWVkc0ZhbGxiYWNrO1xyXG59O1xyXG5cclxuU3RhZ2UucHJvdG90eXBlLl9jb2xsZWN0UGFyZW50cyA9IGZ1bmN0aW9uICh0aWxlLCB0ZXh0dXJlU3RvcmUsIG5lZWRzRmFsbGJhY2spIHtcclxuICAgIC8vIFJlY3Vyc2l2ZWx5IHZpc2l0IHBhcmVudCB0aWxlcyB1bnRpbDpcclxuICAgIC8vICAgLSBhbGwgcGFyZW50cyBoYXZlIGJlZW4gbWFya2VkIGZvciBsb2FkaW5nLCBpZiBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgaXNcclxuICAgIC8vICAgICBlbmFibGVkOyBhbmRcclxuICAgIC8vICAgLSBhdCBsZWFzdCBvbmUgcGFyZW50IGhhcyBiZWVuIG1hcmtlZCBmb3IgYm90aCBsb2FkaW5nIGFuZCByZW5kZXJpbmcsIGlmXHJcbiAgICAvLyAgICAgYSBmYWxsYmFjayBpcyByZXF1aXJlZC5cclxuICAgIHZhciBuZWVkc0xvYWRpbmcgPSB0aGlzLl9wcm9ncmVzc2l2ZTtcclxuICAgIHdoaWxlICgobmVlZHNMb2FkaW5nIHx8IG5lZWRzRmFsbGJhY2spICYmICh0aWxlID0gdGlsZS5wYXJlbnQoKSkgIT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChuZWVkc0ZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlU3RvcmUudGV4dHVyZSh0aWxlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGVjdFRpbGVUb1JlbmRlcih0aWxlKTtcclxuICAgICAgICAgICAgICAgIG5lZWRzRmFsbGJhY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fcHJvZ3Jlc3NpdmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fY29sbGVjdFRpbGVUb0xvYWQodGlsZSkpIHtcclxuICAgICAgICAgICAgbmVlZHNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5lZWRzRmFsbGJhY2s7XHJcbn07XHJcblxyXG5TdGFnZS5wcm90b3R5cGUuX2NvbGxlY3RUaWxlVG9Mb2FkID0gZnVuY3Rpb24gKHRpbGUpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb2xsZWN0VGlsZUludG9MaXN0KHRpbGUsIHRoaXMuX3RpbGVzVG9Mb2FkKTtcclxufTtcclxuXHJcblN0YWdlLnByb3RvdHlwZS5fY29sbGVjdFRpbGVUb1JlbmRlciA9IGZ1bmN0aW9uICh0aWxlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29sbGVjdFRpbGVJbnRvTGlzdCh0aWxlLCB0aGlzLl90aWxlc1RvUmVuZGVyKTtcclxufTtcclxuXHJcblN0YWdlLnByb3RvdHlwZS5fY29sbGVjdFRpbGVJbnRvTGlzdCA9IGZ1bmN0aW9uICh0aWxlLCB0aWxlTGlzdCkge1xyXG4gICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgd2hldGhlciBpdCdzIHdvcnRoIGl0IHRvIG1ha2UgdGhpcyBiZXR0ZXIgdGhhbiBPKG7CsikuXHJcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlsZUxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAodGlsZS5lcXVhbHModGlsZUxpc3RbaV0pKSB7XHJcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFmb3VuZCkge1xyXG4gICAgICAgIHRpbGVMaXN0LnB1c2godGlsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gIWZvdW5kO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIHRleHR1cmUgZm9yIHRoZSBnaXZlbiB0aWxlIGFuZCBhc3NldC4gQ2FsbGVkIGJ5IHtAbGluayBUZXh0dXJlU3RvcmV9LlxyXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGVcclxuICogQHBhcmFtIHtBc3NldH0gYXNzZXRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxyXG4gKi9cclxuU3RhZ2UucHJvdG90eXBlLmNyZWF0ZVRleHR1cmUgPSBmdW5jdGlvbiAodGlsZSwgYXNzZXQsIGRvbmUpIHtcclxuXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZVRleHR1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBzZWxmLlRleHR1cmVDbGFzcyhzZWxmLCB0aWxlLCBhc3NldCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZuID0gY2FuY2VsaXplKGFzeW5jKG1ha2VUZXh0dXJlKSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVRleHR1cmVXb3JrUXVldWUucHVzaChmbiwgZnVuY3Rpb24gKGVyciwgdGV4dHVyZSkge1xyXG4gICAgICAgIGRvbmUoZXJyLCB0aWxlLCBhc3NldCwgdGV4dHVyZSk7XHJcbiAgICB9KTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIHN0YWdlIHR5cGUsIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSByZW5kZXJlciBmb3IgYSBnaXZlblxyXG4gKiBnZW9tZXRyeSBhbmQgdmlldy5cclxuICpcclxuICogVGhlIHNvbGUga25vd24gdmFsdWUgaXMgYFwid2ViZ2xcIi5cclxuICpcclxuICogU2VlIGFsc28ge0BsaW5rIFN0YWdlI3JlZ2lzdGVyUmVuZGVyZXJ9LlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ31cclxuICogQG5hbWUgU3RhZ2UjdHlwZVxyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RhZ2U7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBTdGFnZSA9IHJlcXVpcmUoJy4vU3RhZ2UnKTtcclxudmFyIEh0bWxJbWFnZUxvYWRlciA9IHJlcXVpcmUoJy4uL2xvYWRlcnMvSHRtbEltYWdlJyk7XHJcbnZhciBicm93c2VyID0gcmVxdWlyZSgnYm93c2VyJyk7XHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWwvaW5oZXJpdHMnKTtcclxudmFyIHBpeGVsUmF0aW8gPSByZXF1aXJlKCcuLi91dGlsL3BpeGVsUmF0aW8nKTtcclxudmFyIGlzcG90ID0gcmVxdWlyZSgnLi4vdXRpbC9pc3BvdCcpO1xyXG52YXIgc2V0QWJzb2x1dGUgPSByZXF1aXJlKCcuLi91dGlsL2RvbScpLnNldEFic29sdXRlO1xyXG52YXIgc2V0RnVsbFNpemUgPSByZXF1aXJlKCcuLi91dGlsL2RvbScpLnNldEZ1bGxTaXplO1xyXG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcclxuXHJcbi8vIFRPRE8odGpncSk6IFVuaWZ5IFN0YWdlIGFuZCBXZWJHbFN0YWdlLlxyXG5cclxuLy8gQnJvd3Nlci1zcGVjaWZpYyB3b3JrYXJvdW5kcy5cclxudmFyIGJyb3dzZXJRdWlya3MgPSB7XHJcbiAgICAvLyBXaGV0aGVyIHRvIHVzZSB0ZXhJbWFnZTJEIGluc3RlYWQgb2YgdGV4U3ViSW1hZ2UyRCB3aGVuIHJlcGFpbnRpbmcgYW5cclxuICAgIC8vIGV4aXN0aW5nIHRleHR1cmUgZnJvbSBhIHZpZGVvIGVsZW1lbnQuIE9uIG1vc3QgYnJvd3NlcnMgdGV4U3ViSW1hZ2UyRCBpc1xyXG4gICAgLy8gZmFzdGVyLCBidXQgb24gQ2hyb21lIHRoZSBwZXJmb3JtYW5jZSBkZWdyYWRlcyBzaWduaWZpY2FudGx5LiBTZWU6XHJcbiAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MTI1NDJcclxuICAgIHZpZGVvVXNlVGV4SW1hZ2UyRDogYnJvd3Nlci5jaHJvbWVcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBpbml0V2ViR2xDb250ZXh0KGNhbnZhcywgb3B0cykge1xyXG4gICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgYWxwaGE6IHRydWUsXHJcbiAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxyXG4gICAgICAgIGFudGlhbGlhczogISEob3B0cyAmJiBvcHRzLmFudGlhbGlhcyksXHJcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiAhIShvcHRzICYmIG9wdHMucHJlc2VydmVEcmF3aW5nQnVmZmVyKSxcclxuICAgICAgICB4ckNvbXBhdGlibGU6ICEhKG9wdHMgJiYgb3B0cy54ckNvbXBhdGlibGUpXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBnbCA9IChjYW52YXMuZ2V0Q29udGV4dCkgJiYgKGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG9wdGlvbnMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBvcHRpb25zKSk7XHJcblxyXG4gICAgaWYgKCFnbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBXZWJHTCBjb250ZXh0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdHMud3JhcENvbnRleHQpIHtcclxuICAgICAgICBnbCA9IG9wdHMud3JhcENvbnRleHQoZ2wpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBnbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBXZWJHbFN0YWdlXHJcbiAqIEBleHRlbmRzIFN0YWdlXHJcbiAqIEBjbGFzc2Rlc2NcclxuICpcclxuICogQSB7QGxpbmsgU3RhZ2V9IGltcGxlbWVudGF0aW9uIHVzaW5nIFdlYkdsLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmFudGlhbGlhcz1mYWxzZV1cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI9ZmFsc2VdXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZ2VuZXJhdGVNaXBtYXBzPWZhbHNlXVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0cy53cmFwQ29udGV4dF1cclxuICpcclxuICogVGhlIGBhbnRpYWxpYXNgIGFuZCBgcHJlc2VydmVEcmF3aW5nQnVmZmVyYCBvcHRpb25zIGNvbnRyb2wgdGhlIFdlYkdMXHJcbiAqIGNvbnRleHQgYXR0cmlidXRlcyBvZiB0aGUgc2FtZSBuYW1lLiBUaGUgYGFscGhhYCBhbmQgYHByZW11bHRpcGxpZWRBbHBoYWBcclxuICogV2ViR0wgY29udGV4dCBhdHRyaWJ1dGVzIGFyZSBzZXQgdG8gdGhlaXIgZGVmYXVsdCB0cnVlIHZhbHVlIGFuZCBjYW5ub3RcclxuICogYmUgb3ZlcnJpZGVuOyB0aGlzIGFsbG93cyBzZW1pdHJhbnNwYXJlbnQgdGV4dHVyZXMgdG8gYmUgY29tcG9zaXRlZCB3aXRoXHJcbiAqIHRoZSBwYWdlLiBTZWU6XHJcbiAqIGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL3NwZWNzLzEuMC8jV0VCR0xDT05URVhUQVRUUklCVVRFU1xyXG4gKlxyXG4gKiBUaGUgYGdlbmVyYXRlTWlwbWFwc2Agb3B0aW9uIGNvbnRyb2xzIHRleHR1cmUgbWlwbWFwIGdlbmVyYXRpb24uIE1pcG1hcHNcclxuICogbWF5IGltcHJvdmUgcmVuZGVyaW5nIHF1YWxpdHksIGF0IHRoZSBjb3N0IG9mIGluY3JlYXNlZCBtZW1vcnkgdXNhZ2UuXHJcbiAqIER1ZSB0byB0ZWNobmljYWwgbGltaXRhdGlvbnMsIHRoZXkgYXJlIG9ubHkgZ2VuZXJhdGVkIGZvciB0ZXh0dXJlcyB3aG9zZVxyXG4gKiBkaW1lbnNpb25zIGFyZSBhIHBvd2VyIG9mIHR3by4gU2VlOlxyXG4gKiBodHRwczovL3d3dy5raHJvbm9zLm9yZy93ZWJnbC93aWtpL1dlYkdMX2FuZF9PcGVuR0xfRGlmZmVyZW5jZXMjTm9uLVBvd2VyX29mX1R3b19UZXh0dXJlX1N1cHBvcnRcclxuICpcclxuICogVGhlIGB3cmFwQ29udGV4dGAgb3B0aW9uIGlzIGEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhbmQgcmV0dXJucyBhXHJcbiAqIFdlYkdMUmVuZGVyaW5nQ29udGV4dC4gVGhlIHN0YWdlIHdpbGwgdXNlIGl0cyByZXR1cm4gdmFsdWUgYXMgdGhlIGNvbnRleHQuXHJcbiAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNlZCB0b2dldGhlciB3aXRoIFdlYkdMRGVidWdVdGlscyB0byBkZWJ1ZyBXZWJHTCBpc3N1ZXMuXHJcbiAqIFNlZSBodHRwczovL3d3dy5raHJvbm9zLm9yZy93ZWJnbC93aWtpL0RlYnVnZ2luZy5cclxuICpcclxuICogQWxzbyBzZWUgdGhlIGF2YWlsYWJsZSB7QGxpbmsgU3RhZ2V9IG9wdGlvbnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBXZWJHbFN0YWdlKG9wdHMpIHtcclxuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG5cclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyXy5jYWxsKHRoaXMsIG9wdHMpO1xyXG5cclxuICAgIHRoaXMuX2dlbmVyYXRlTWlwbWFwcyA9IG9wdHMuZ2VuZXJhdGVNaXBtYXBzICE9IG51bGwgP1xyXG4gICAgICAgIG9wdHMuZ2VuZXJhdGVNaXBtYXBzIDogZmFsc2U7XHJcblxyXG4gICAgdGhpcy5fbG9hZGVyID0gbmV3IEh0bWxJbWFnZUxvYWRlcih0aGlzKTtcclxuXHJcbiAgICB0aGlzLl9kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcblxyXG4gICAgc2V0QWJzb2x1dGUodGhpcy5fZG9tRWxlbWVudCk7XHJcbiAgICBzZXRGdWxsU2l6ZSh0aGlzLl9kb21FbGVtZW50KTtcclxuXHJcbiAgICB0aGlzLl9nbCA9IGluaXRXZWJHbENvbnRleHQodGhpcy5fZG9tRWxlbWVudCwgb3B0cyk7XHJcblxyXG4gICAgdGhpcy5faGFuZGxlQ29udGV4dExvc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5lbWl0KCd3ZWJnbGNvbnRleHRsb3N0Jyk7XHJcbiAgICAgICAgc2VsZi5fZ2wgPSBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBIYW5kbGUgV2ViR2wgY29udGV4dCBsb3NzLlxyXG4gICAgdGhpcy5fZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgdGhpcy5faGFuZGxlQ29udGV4dExvc3MpO1xyXG5cclxuICAgIC8vIFdlYkdsIHJlbmRlcmVycyBhcmUgc2luZ2xldG9ucyBmb3IgYSBnaXZlbiBzdGFnZS4gVGhpcyBsaXN0IHN0b3JlcyB0aGVcclxuICAgIC8vIGV4aXN0aW5nIHJlbmRlcmVycyBzbyB0aGV5IGNhbiBiZSByZXVzZWQgYWNyb3NzIGxheWVycyB3aXRoIHRoZSBzYW1lXHJcbiAgICAvLyBnZW9tZXRyeSBhbmQgdmlldyB0eXBlLlxyXG4gICAgdGhpcy5fcmVuZGVyZXJJbnN0YW5jZXMgPSBbXTtcclxufVxyXG5cclxuaW5oZXJpdHMoV2ViR2xTdGFnZSwgU3RhZ2UpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBEZXN0cnVjdG9yLlxyXG4gKi9cclxuV2ViR2xTdGFnZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuX2RvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuX2hhbmRsZUNvbnRleHRMb3NzKTtcclxuICAgIC8vIERlbGVnYXRlIGNsZWFyaW5nIG93biBwcm9wZXJ0aWVzIHRvIHRoZSBTdGFnZSBkZXN0cnVjdG9yLlxyXG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8ucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBET00gZWxlbWVudC5cclxuICpcclxuICogQHJldHVybiB7RWxlbWVudH1cclxuICovXHJcbldlYkdsU3RhZ2UucHJvdG90eXBlLmRvbUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZG9tRWxlbWVudDtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBXZWJHTCByZW5kZXJpbmcgY29udGV4dC5cclxuICpcclxuICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0IH1cclxuICovXHJcbldlYkdsU3RhZ2UucHJvdG90eXBlLndlYkdsQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9nbDtcclxufTtcclxuXHJcblxyXG5XZWJHbFN0YWdlLnByb3RvdHlwZS5zZXRTaXplRm9yVHlwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFVwZGF0ZSB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzIGNvb3JkaW5hdGUgc3BhY2UuXHJcbiAgICAvL1xyXG4gICAgLy8gVGhlIHNpemUgaXMgb2J0YWluZWQgYnkgdGFraW5nIHRoZSBzdGFnZSBkaW1lbnNpb25zLCB3aGljaCBhcmUgc2V0IGluIENTU1xyXG4gICAgLy8gcGl4ZWxzLCBhbmQgbXVsdGlwbHlpbmcgdGhlbSBieSB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvLiBDcnVjaWFsbHksIHRoaXNcclxuICAgIC8vIG11c3QgYmUgdGhlIG9ubHkgcGxhY2Ugd2hlcmUgdGhlIFdlYkdMIHJlbmRlcmluZyBwaXBlbGluZSBhY2Nlc3NlcyB0aGVcclxuICAgIC8vIHBpeGVsIHJhdGlvOyBzdWJzZXF1ZW50IHVzZXMgc2hvdWxkIHJlZmVyZW5jZSB0aGUgYGRyYXdpbmdCdWZmZXJXaWR0aGAgYW5kXHJcbiAgICAvLyBgZHJhd2luZ0J1ZmZlckhlaWdodGAgcHJvcGVydGllcyBvbiB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LiBGYWlsaW5nIHRvXHJcbiAgICAvLyBkbyBzbyB3aWxsIGJyZWFrIHRoZSByZW5kZXJpbmcgaWYgdGhlIHBpeGVsIHJhdGlvIGNoYW5nZXMgYnV0IHRoZSBzdGFnZVxyXG4gICAgLy8gc2l6ZSBkb2VzIG5vdCwgZS5nLiB3aGVuIG1vdmluZyB0aGUgd2luZG93IGFjcm9zcyBzY3JlZW5zLlxyXG4gICAgdmFyIHJhdGlvID0gcGl4ZWxSYXRpbygpO1xyXG4gICAgdGhpcy5fZG9tRWxlbWVudC53aWR0aCA9IHJhdGlvICogdGhpcy5fd2lkdGg7XHJcbiAgICB0aGlzLl9kb21FbGVtZW50LmhlaWdodCA9IHJhdGlvICogdGhpcy5faGVpZ2h0O1xyXG59O1xyXG5cclxuXHJcbldlYkdsU3RhZ2UucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uICh1cmwsIHJlY3QsIGRvbmUpIHtcclxuICAgIHJldHVybiB0aGlzLl9sb2FkZXIubG9hZEltYWdlKHVybCwgcmVjdCwgZG9uZSk7XHJcbn07XHJcblxyXG5cclxuV2ViR2xTdGFnZS5wcm90b3R5cGUubWF4VGV4dHVyZVNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuX2dsLk1BWF9URVhUVVJFX1NJWkUpO1xyXG59O1xyXG5cclxuXHJcbldlYkdsU3RhZ2UucHJvdG90eXBlLnZhbGlkYXRlTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICAgIHZhciB0aWxlU2l6ZSA9IGxheWVyLmdlb21ldHJ5KCkubWF4VGlsZVNpemUoKTtcclxuICAgIHZhciBtYXhUZXh0dXJlU2l6ZSA9IHRoaXMubWF4VGV4dHVyZVNpemUoKTtcclxuICAgIGlmICh0aWxlU2l6ZSA+IG1heFRleHR1cmVTaXplKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMYXllciBoYXMgbGV2ZWwgd2l0aCB0aWxlIHNpemUgbGFyZ2VyIHRoYW4gbWF4aW11bSB0ZXh0dXJlIHNpemUgKCcgKyB0aWxlU2l6ZSArICcgdnMuICcgKyBtYXhUZXh0dXJlU2l6ZSArICcpJyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuV2ViR2xTdGFnZS5wcm90b3R5cGUuY3JlYXRlUmVuZGVyZXIgPSBmdW5jdGlvbiAoUmVuZGVyZXIpIHtcclxuICAgIHZhciByZW5kZXJlckluc3RhbmNlcyA9IHRoaXMuX3JlbmRlcmVySW5zdGFuY2VzO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW5kZXJlckluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChyZW5kZXJlckluc3RhbmNlc1tpXSBpbnN0YW5jZW9mIFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlckluc3RhbmNlc1tpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIodGhpcy5fZ2wpO1xyXG4gICAgcmVuZGVyZXJJbnN0YW5jZXMucHVzaChyZW5kZXJlcik7XHJcbiAgICByZXR1cm4gcmVuZGVyZXI7XHJcbn07XHJcblxyXG5cclxuV2ViR2xTdGFnZS5wcm90b3R5cGUuZGVzdHJveVJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyKSB7XHJcbiAgICB2YXIgcmVuZGVyZXJJbnN0YW5jZXMgPSB0aGlzLl9yZW5kZXJlckluc3RhbmNlcztcclxuICAgIGlmICh0aGlzLl9yZW5kZXJlcnMuaW5kZXhPZihyZW5kZXJlcikgPCAwKSB7XHJcbiAgICAgICAgcmVuZGVyZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHZhciBpbmRleCA9IHJlbmRlcmVySW5zdGFuY2VzLmluZGV4T2YocmVuZGVyZXIpO1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVySW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbldlYkdsU3RhZ2UucHJvdG90eXBlLnN0YXJ0RnJhbWUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGdsID0gdGhpcy5fZ2w7XHJcblxyXG4gICAgaWYgKCFnbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIFdlYkdMIGNvbnRleHQgLSBtYXliZSBjb250ZXh0IHdhcyBsb3N0PycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCB0aGUgV2ViR0wgdmlld3BvcnQuXHJcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xyXG5cclxuICAgIC8vIENsZWFyIGZyYW1lYnVmZmVyLlxyXG4gICAgZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAwLjApO1xyXG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xyXG5cclxuICAgIC8vIEVuYWJsZSBkZXB0aCB0ZXN0aW5nLlxyXG4gICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgIC8vIEVuYWJsZSBibGVuZGluZy4gT05FIGFuZCBPTkVfTUlOVVNfU1JDX0FMUEhBIGFyZSB0aGUgcmlnaHQgY2hvaWNlcyBmb3JcclxuICAgIC8vIHByZW11bHRpcGxpZWQgdGV4dHVyZXMuXHJcbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcblxyXG59O1xyXG5cclxuXHJcbldlYkdsU3RhZ2UucHJvdG90eXBlLmVuZEZyYW1lID0gZnVuY3Rpb24gKCkgeyB9O1xyXG5cclxuXHJcbldlYkdsU3RhZ2UucHJvdG90eXBlLnRha2VTbmFwc2hvdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgcGFzc2VkIGFyZ3VtZW50XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IG9wdGlvbnMgPT0gbnVsbCkge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcXVhbGl0eSA9IG9wdGlvbnMucXVhbGl0eTtcclxuXHJcbiAgICAvLyBTZXQgZGVmYXVsdCBxdWFsaXR5IGlmIGl0IGlzIG5vdCBwYXNzZWRcclxuICAgIGlmICh0eXBlb2YgcXVhbGl0eSA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHF1YWxpdHkgPSA3NTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaHJvdyBpZiBxdWFsaXR5IGlzIG9mIGludmxpZCB0eXBlIG9yIG91dCBvZiBib3VuZHNcclxuICAgIGlmICh0eXBlb2YgcXVhbGl0eSAhPT0gJ251bWJlcicgfHwgcXVhbGl0eSA8IDAgfHwgcXVhbGl0eSA+IDEwMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0xTdGFnZTogU25hcHNob3QgcXVhbGl0eSBuZWVkcyB0byBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEwMCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbnZhcyBtZXRob2QgXCJ0b0RhdGFVUkxcIiBuZWVkcyB0byBiZSBjYWxsZWQgaW4gdGhlIHNhbWVcclxuICAgIC8vIGNvbnRleHQgYXMgd2hlcmUgdGhlIGFjdHVhbCByZW5kZXJpbmcgaXMgZG9uZS4gSGVuY2UgdGhpcy5cclxuICAgIHRoaXMucmVuZGVyKCk7XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSBzbmFwc2hvdFxyXG4gICAgcmV0dXJuIHRoaXMuX2RvbUVsZW1lbnQudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgcXVhbGl0eSAvIDEwMCk7XHJcbn1cclxuXHJcblxyXG5XZWJHbFN0YWdlLnR5cGUgPSBXZWJHbFN0YWdlLnByb3RvdHlwZS50eXBlID0gJ3dlYmdsJztcclxuXHJcblxyXG5mdW5jdGlvbiBXZWJHbFRleHR1cmUoc3RhZ2UsIHRpbGUsIGFzc2V0KSB7XHJcbiAgICB0aGlzLl9zdGFnZSA9IHN0YWdlO1xyXG4gICAgdGhpcy5fZ2wgPSBzdGFnZS5fZ2w7XHJcbiAgICB0aGlzLl90ZXh0dXJlID0gbnVsbDtcclxuICAgIHRoaXMuX3RpbWVzdGFtcCA9IG51bGw7XHJcbiAgICB0aGlzLl93aWR0aCA9IHRoaXMuX2hlaWdodCA9IG51bGw7XHJcbiAgICB0aGlzLnJlZnJlc2godGlsZSwgYXNzZXQpO1xyXG59XHJcblxyXG5cclxuV2ViR2xUZXh0dXJlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKHRpbGUsIGFzc2V0KSB7XHJcblxyXG4gICAgdmFyIGdsID0gdGhpcy5fZ2w7XHJcbiAgICB2YXIgc3RhZ2UgPSB0aGlzLl9zdGFnZTtcclxuICAgIHZhciB0ZXh0dXJlO1xyXG5cclxuICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIHRleHR1cmUgbmVlZHMgdG8gYmUgdXBkYXRlZC5cclxuICAgIHZhciB0aW1lc3RhbXAgPSBhc3NldC50aW1lc3RhbXAoKTtcclxuICAgIGlmICh0aW1lc3RhbXAgPT09IHRoaXMuX3RpbWVzdGFtcCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgYXNzZXQgZWxlbWVudC5cclxuICAgIHZhciBlbGVtZW50ID0gYXNzZXQuZWxlbWVudCgpO1xyXG5cclxuICAgIC8vIEdldCBhc3NldCBkaW1lbnNpb25zLlxyXG4gICAgdmFyIHdpZHRoID0gYXNzZXQud2lkdGgoKTtcclxuICAgIHZhciBoZWlnaHQgPSBhc3NldC5oZWlnaHQoKTtcclxuXHJcbiAgICBpZiAod2lkdGggIT09IHRoaXMuX3dpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5faGVpZ2h0KSB7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSB0ZXh0dXJlIGRpbWVuc2lvbnMgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHJlZnJlc2gsIGNyZWF0ZVxyXG4gICAgICAgIC8vIGEgbmV3IHRleHR1cmUgd2l0aCB0aGUgY29ycmVjdCBzaXplLlxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB0ZXh0dXJlIGRpbWVuc2lvbnMgd291bGQgZXhjZWVkIHRoZSBtYXhpbXVtIHRleHR1cmUgc2l6ZS5cclxuICAgICAgICB2YXIgbWF4U2l6ZSA9IHN0YWdlLm1heFRleHR1cmVTaXplKCk7XHJcbiAgICAgICAgaWYgKHdpZHRoID4gbWF4U2l6ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmUgd2lkdGggbGFyZ2VyIHRoYW4gbWF4IHNpemUgKCcgKyB3aWR0aCArICcgdnMuICcgKyBtYXhTaXplICsgJyknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhlaWdodCA+IG1heFNpemUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlIGhlaWdodCBsYXJnZXIgdGhhbiBtYXggc2l6ZSAoJyArIGhlaWdodCArICcgdnMuICcgKyBtYXhTaXplICsgJyknKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlbGV0ZSB0aGUgY3VycmVudCB0ZXh0dXJlIGlmIGl0IGV4aXN0cy5cclxuICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgQ2hyb21lIG9uIEFuZHJvaWQuIElmIGl0IGlzbid0IGRvbmUgdGhlIHRleHR1cmVzXHJcbiAgICAgICAgLy8gZG8gbm90IHJlbmRlciB3aGVuIHRoZSBzaXplIGNoYW5nZXMuXHJcbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUpIHtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSB0ZXh0dXJlIG11c3QgYmUgcHJlbXVsdGlwbGllZCBieSBhbHBoYSB0byBlbnN1cmUgY29ycmVjdCBibGVuZGluZyBvZlxyXG4gICAgICAgIC8vIHNlbWl0cmFuc3BhcmVudCB0ZXh0dXJlcy4gRm9yIGRldGFpbHMsIHNlZTpcclxuICAgICAgICAvLyBodHRwOi8vd3d3LnJlYWx0aW1lcmVuZGVyaW5nLmNvbS9ibG9nL2dwdXMtcHJlZmVyLXByZW11bHRpcGxpY2F0aW9uL1xyXG4gICAgICAgIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xyXG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdHJ1ZSk7XHJcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBlbGVtZW50KTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgdGV4dHVyZSBkaW1lbnNpb25zIHJlbWFpbiB0aGUgc2FtZSwgcmVwYWludCB0aGUgZXhpc3RpbmcgdGV4dHVyZS5cclxuICAgICAgICAvLyBSZXBhaW50aW5nIHdpdGggdGV4U3ViSW1hZ2UyRCBpcyB1c3VhbGx5IGZhc3RlciB0aGFuIHdpdGggdGV4SW1hZ2UyRCxcclxuICAgICAgICAvLyBleGNlcHQgaW4gdGhlIGNhc2Ugbm90ZWQgaW4gYnJvd3NlclF1aXJrcy5cclxuXHJcbiAgICAgICAgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XHJcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0cnVlKTtcclxuXHJcbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ICYmIGJyb3dzZXJRdWlya3MudmlkZW9Vc2VUZXhJbWFnZTJEKSB7XHJcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZWxlbWVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBlbGVtZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdlbmVyYXRlIG1pcG1hcCBpZiB0aGUgY29ycmVzcG9uZGluZyBzdGFnZSBvcHRpb24gaXMgc2V0IGFuZCB0aGUgdGV4dHVyZVxyXG4gICAgLy8gZGltZW5zaW9ucyBhcmUgcG93ZXJzIG9mIHR3by5cclxuICAgIGlmIChzdGFnZS5fZ2VuZXJhdGVNaXBtYXBzICYmIGlzcG90KHdpZHRoKSAmJiBpc3BvdChoZWlnaHQpKSB7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUl9NSVBNQVBfTElORUFSKTtcclxuICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2xhbXAgdGV4dHVyZSB0byBlZGdlcy5cclxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcblxyXG4gICAgLy8gVW5iaW5kIHRleHR1cmUuXHJcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGV4dHVyZSBkaW1lbnNpb25zIGFuZCB0aW1lc3RhbXAuXHJcbiAgICB0aGlzLl90aW1lc3RhbXAgPSB0aW1lc3RhbXA7XHJcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xyXG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxufTtcclxuXHJcblxyXG5XZWJHbFRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5fdGV4dHVyZSkge1xyXG4gICAgICAgIHRoaXMuX2dsLmRlbGV0ZVRleHR1cmUodGhpcy5fdGV4dHVyZSk7XHJcbiAgICB9XHJcbiAgICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XHJcbn07XHJcblxyXG5cclxuV2ViR2xTdGFnZS5UZXh0dXJlQ2xhc3MgPSBXZWJHbFN0YWdlLnByb3RvdHlwZS5UZXh0dXJlQ2xhc3MgPSBXZWJHbFRleHR1cmU7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJHbFN0YWdlO1xyXG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRyYW5zZm9ybSBhIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGludG8gYW4gYXN5bmNocm9ub3VzIG9uZS5cbmZ1bmN0aW9uIGFzeW5jKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBhc3luY2VkKGRvbmUpIHtcbiAgICB2YXIgZXJyLCByZXQ7XG4gICAgdHJ5IHtcbiAgICAgIHJldCA9IGZuKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBkb25lKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKG51bGwsIHJldCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIFJlY3RTcGVjfSBpbnRvIGFuIGVxdWl2YWxlbnQge0BsaW5rIFJlY3R9LlxuICpcbiAqIEEge0BsaW5rIFJlY3RTcGVjfSBpcyBhIGNvbnZlbmllbnQgdXNlciBBUEkgZm9ybWF0LCBwcm92aWRpbmcgZGVmYXVsdCB2YWx1ZXNcbiAqIGFuZCB0aGUgZmxleGliaWxpdHkgb2Ygc3BlY2lmeWluZyBhYnNvbHV0ZSwgcmVsYXRpdmUgb3IgbWl4ZWQgZGltZW5zaW9ucy5cbiAqXG4gKiBBIHtAbGluayBSZWN0fSBpcyBhIG1vcmUgY29udmVuaWVudCBmb3JtYXQgZm9yIHRoZSByZW5kZXJpbmcgcGlwZWxpbmUuIEl0IGlzXG4gKiBhbHdheXMgZXhwcmVzc2VkIGluIG5vcm1hbGl6ZWQgY29vcmRpbmF0ZXMsIGFuZCBhbGwgaXRzIHByb3BlcnRpZXMgYXJlXG4gKiBndWFyYW50ZWVkIHRvIGJlIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsV2lkdGggVGhlIHRvdGFsIHdpZHRoIG9mIHRoZSByZW5kZXJpbmcgYXJlYSBpbiBwaXhlbHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdG90YWxIZWlnaHQgVGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgcmVuZGVyaW5nIGFyZWEgaW4gcGl4ZWxzLlxuICogQHBhcmFtIHtSZWN0U3BlY30gc3BlYyBUaGUgaW5wdXQgc3BlYywgZGVmYXVsdGluZyB0byB0aGUgZnVsbCByZW5kZXJpbmcgYXJlYVxuICogICAgIGlmIG51bGwgb3IgdW5kZWZpbmVkLlxuICogQHBhcmFtIHtSZWN0fSByZXN1bHQgVGhlIG91dHB1dCBzcGVjLiBJZiB0aGUgYXJndW1lbnQgaXMgcHJlc2VudCwgaXQgaXNcbiAqICAgICBmaWxsZWQgaW4gYW5kIHJldHVybmVkOyBvdGhlcndpc2UsIGEgZnJlc2ggb2JqZWN0IGlzIHJldHVybmVkLlxuICovXG5mdW5jdGlvbiBjYWxjUmVjdCh0b3RhbFdpZHRoLCB0b3RhbEhlaWdodCwgc3BlYywgcmVzdWx0KSB7XG5cbiAgcmVzdWx0ID0gcmVzdWx0IHx8IHt9O1xuXG4gIHZhciB3aWR0aDtcbiAgaWYgKHNwZWMgIT0gbnVsbCAmJiBzcGVjLmFic29sdXRlV2lkdGggIT0gbnVsbCkge1xuICAgIHdpZHRoID0gc3BlYy5hYnNvbHV0ZVdpZHRoIC8gdG90YWxXaWR0aDtcbiAgfSBlbHNlIGlmIChzcGVjICE9IG51bGwgJiYgc3BlYy5yZWxhdGl2ZVdpZHRoICE9IG51bGwpIHtcbiAgICB3aWR0aCA9IHNwZWMucmVsYXRpdmVXaWR0aDtcbiAgfSBlbHNlIHtcbiAgICB3aWR0aCA9IDE7XG4gIH1cblxuICB2YXIgaGVpZ2h0O1xuICBpZiAoc3BlYyAmJiBzcGVjLmFic29sdXRlSGVpZ2h0ICE9IG51bGwpIHtcbiAgICBoZWlnaHQgPSBzcGVjLmFic29sdXRlSGVpZ2h0IC8gdG90YWxIZWlnaHQ7XG4gIH0gZWxzZSBpZiAoc3BlYyAhPSBudWxsICYmIHNwZWMucmVsYXRpdmVIZWlnaHQgIT0gbnVsbCkge1xuICAgIGhlaWdodCA9IHNwZWMucmVsYXRpdmVIZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgaGVpZ2h0ID0gMTtcbiAgfVxuXG4gIHZhciB4O1xuICBpZiAoc3BlYyAhPSBudWxsICYmIHNwZWMuYWJzb2x1dGVYICE9IG51bGwpIHtcbiAgICB4ID0gc3BlYy5hYnNvbHV0ZVggLyB0b3RhbFdpZHRoO1xuICB9IGVsc2UgaWYgKHNwZWMgIT0gbnVsbCAmJiBzcGVjLnJlbGF0aXZlWCAhPSBudWxsKSB7XG4gICAgeCA9IHNwZWMucmVsYXRpdmVYO1xuICB9IGVsc2Uge1xuICAgIHggPSAwO1xuICB9XG5cbiAgdmFyIHk7XG4gIGlmIChzcGVjICE9IG51bGwgJiYgc3BlYy5hYnNvbHV0ZVkgIT0gbnVsbCkge1xuICAgIHkgPSBzcGVjLmFic29sdXRlWSAvIHRvdGFsSGVpZ2h0O1xuICB9IGVsc2UgaWYgKHNwZWMgIT0gbnVsbCAmJiBzcGVjLnJlbGF0aXZlWSAhPSBudWxsKSB7XG4gICAgeSA9IHNwZWMucmVsYXRpdmVZO1xuICB9IGVsc2Uge1xuICAgIHkgPSAwO1xuICB9XG5cbiAgcmVzdWx0LnggPSB4O1xuICByZXN1bHQueSA9IHk7XG4gIHJlc3VsdC53aWR0aCA9IHdpZHRoO1xuICByZXN1bHQuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FsY1JlY3Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBvbmNlID0gcmVxdWlyZSgnLi9vbmNlJyk7XG5cbi8vIEEgY2FuY2VsYWJsZSBmdW5jdGlvbiBpcyBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gKGkuZS4sIG9uZSB3aG9zZSBsYXN0XG4vLyBhcmd1bWVudCBpcyBhIGNhbGxiYWNrIHJlY2VpdmluZyBhbiBlcnJvciBwbHVzIHplcm8gb3IgbW9yZSByZXR1cm4gdmFsdWVzKVxuLy8gdGhhdCAoc3luY2hyb25vdXNseSkgcmV0dXJucyBhIGNhbmNlbCgpIGZ1bmN0aW9uLiBDYWxsaW5nIGNhbmNlbCgpIHNob3VsZFxuLy8gYWJvcnQgdGhlIGFzeW5jaHJvbm91cyBvcGVyYXRpb24gYW5kIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGggdGhlIGFyZ3VtZW50c1xuLy8gdGhhdCB3ZXJlIHBhc3NlZCBpbnRvIGNhbmNlbCgpLiBDYWxsaW5nIGNhbmNlbCgpIHR3aWNlLCBhcyB3aXRoIGNhbGxiYWNrcyxcbi8vIGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIHNhZmUuXG5cbi8vIFdyYXAgYSBub24tY2FuY2VsbGFibGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9uIGludG8gYSBjYW5jZWxhYmxlIG9uZS5cbi8vXG4vLyBDYWxsaW5nIGNhbmNlbCgpIG9uIHRoZSByZXR1cm5lZCBmdW5jdGlvbiB3aWxsIG5vdCBpbnRlcnJ1cHQgdGhlIGV4ZWN1dGlvblxuLy8gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uOyBpdCB3aWxsIG1lcmVseSBpZ25vcmUgaXRzIHJldHVybiB2YWx1ZS5cbi8vXG4vLyBVc3VhbGx5LCBpbnN0ZWFkIG9mIHdyYXBwaW5nIHlvdXIgZnVuY3Rpb24sIHlvdSB3YW50IHRvIGltcGxlbWVudCBjYW5jZWwoKVxuLy8geW91cnNlbGYgaW4gb3JkZXIgdG8gaGF2ZSBzb21lIGFib3J0IGxvZ2ljLiBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gcHJvdmlkZXMgYVxuLy8gc3RyYWlnaGZvcndhcmQgc29sdXRpb24gZm9yIGNhc2VzIGluIHdoaWNoIG5vIGN1c3RvbSBhYm9ydCBsb2dpYyBpcyByZXF1aXJlZC5cbmZ1bmN0aW9uIGNhbmNlbGl6ZShmbikge1xuICByZXR1cm4gZnVuY3Rpb24gY2FuY2VsaXplZCgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FuY2VsaXplZDogZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICB2YXIgZG9uZSA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9IG9uY2UoYXJnc1thcmdzLmxlbmd0aCAtIDFdKTtcblxuICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcblxuICAgIHJldHVybiBjYW5jZWw7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FuY2VsaXplO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9vcCA9IHJlcXVpcmUoJy4vbm9vcCcpO1xuXG4vLyBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGl0cyBhcmd1bWVudHMgKHdoaWNoIHNob3VsZCBiZSBjYW5jZWxhYmxlcylcbi8vIGluIHNlcXVlbmNlLCBzbyB0aGF0IGVhY2ggb2YgdGhlbSBwYXNzZXMgaXRzIHJldHVybiB2YWx1ZXMgdG8gdGhlIG5leHQuXG4vLyBFeGVjdXRpb24gaXMgYWJvcnRlZCBpZiBvbmUgb2YgdGhlIGZ1bmN0aW9ucyByZXR1cm5zIGFuIGVycm9yOyBpbiB0aGF0IGNhc2Vcbi8vIHRoZSBsYXN0IGZ1bmN0aW9uIGluIHRoZSBzZXF1ZW5jZSBpcyBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuXG4vLyBTZWUgdXRpbC9jYW5jZWxpemUuanMgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIHdoYXQgY2FuY2VsYWJsZXMgYXJlLlxuZnVuY3Rpb24gY2hhaW4oKSB7XG5cbiAgLy8gVGhlIGxpc3Qgb2YgZnVuY3Rpb25zIHRvIGNoYWluIHRvZ2V0aGVyLlxuICB2YXIgYXJnTGlzdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWQoKSB7XG5cbiAgICAvLyBMaXN0IG9mIHJlbWFpbmluZyBmdW5jdGlvbnMgdG8gYmUgZXhlY3V0ZWQuXG4gICAgLy8gTWFrZSBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIGxpc3Qgc28gd2UgY2FuIG11dGF0ZSB0aGUgZm9ybWVyIHdoaWxlXG4gICAgLy8gcHJlc2VydmluZyB0aGUgbGF0dGVyIGludGFjdCBmb3IgZnV0dXJlIGludm9jYXRpb25zIG9mIHRoZSBjaGFpbi5cbiAgICB2YXIgZm5MaXN0ID0gYXJnTGlzdC5zbGljZSgwKTtcblxuICAgIC8vIEN1cnJlbnRseSBleGVjdXRpbmcgZnVuY3Rpb24uXG4gICAgdmFyIGZuID0gbnVsbDtcblxuICAgIC8vIENhbmNlbCBtZXRob2QgZm9yIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIGZ1bmN0aW9uLlxuICAgIHZhciBjZm4gPSBudWxsO1xuXG4gICAgLy8gQXJndW1lbnRzIGZvciB0aGUgZmlyc3QgZnVuY3Rpb24uXG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCBhcmd1bWVudHMubGVuZ3RoIC0gMSkgOiBbXTtcblxuICAgIC8vIENhbGxiYWNrIGZvciB0aGUgY2hhaW4uXG4gICAgdmFyIGRvbmUgPSBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSA6IG5vb3A7XG5cbiAgICAvLyBFeGVjdXRlIHRoZSBuZXh0IGZ1bmN0aW9uIGluIHRoZSBjaGFpbi5cbiAgICAvLyBSZWNlaXZlcyB0aGUgZXJyb3IgYW5kIHJldHVybiB2YWx1ZXMgZnJvbSB0aGUgcHJldmlvdXMgZnVuY3Rpb24uXG4gICAgZnVuY3Rpb24gZXhlYygpIHtcblxuICAgICAgLy8gRXh0cmFjdCBlcnJvciBmcm9tIGFyZ3VtZW50cy5cbiAgICAgIHZhciBlcnIgPSBhcmd1bWVudHNbMF07XG5cbiAgICAgIC8vIEFib3J0IGNoYWluIG9uIGVycm9yLlxuICAgICAgaWYgKGVycikge1xuICAgICAgICBmbiA9IGNmbiA9IG51bGw7XG4gICAgICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUZXJtaW5hdGUgaWYgdGhlcmUgYXJlIG5vIGZ1bmN0aW9ucyBsZWZ0IGluIHRoZSBjaGFpbi5cbiAgICAgIGlmICghZm5MaXN0Lmxlbmd0aCkge1xuICAgICAgICBmbiA9IGNmbiA9IG51bGw7XG4gICAgICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGZ1bmN0aW9uIGluIHRoZSBjaGFpbi5cbiAgICAgIGZuID0gZm5MaXN0LnNoaWZ0KCk7XG4gICAgICB2YXIgX2ZuID0gZm47XG5cbiAgICAgIC8vIEV4dHJhY3QgYXJndW1lbnRzIHRvIHBhc3MgaW50byB0aGUgbmV4dCBmdW5jdGlvbi5cbiAgICAgIHZhciByZXQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgICAvLyBDYWxsIG5leHQgZnVuY3Rpb24gd2l0aCBwcmV2aW91cyByZXR1cm4gdmFsdWUgYW5kIGNhbGwgYmFjayBleGVjLlxuICAgICAgcmV0LnB1c2goZXhlYyk7XG4gICAgICB2YXIgX2NmbiA9IGZuLmFwcGx5KG51bGwsIHJldCk7IC8vIGZuKG51bGwsIHJldC4uLiwgZXhlYylcblxuICAgICAgLy8gRGV0ZWN0IHdoZW4gZm4gaGFzIGNvbXBsZXRlZCBzeW5jaHJvbm91c2x5IGFuZCBkbyBub3QgY2xvYmJlciB0aGVcbiAgICAgIC8vIGludGVybmFsIHN0YXRlIGluIHRoYXQgY2FzZS4gWW91J3JlIG5vdCBleHBlY3RlZCB0byB1bmRlcnN0YW5kIHRoaXMuXG4gICAgICBpZiAoX2ZuICE9PSBmbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbWVtYmVyIHRoZSBjYW5jZWwgbWV0aG9kIGZvciB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBmdW5jdGlvbi5cbiAgICAgIC8vIERldGVjdCBjaGFpbmluZyBvbiBub24tY2FuY2VsbGFibGUgZnVuY3Rpb24uXG4gICAgICBpZiAodHlwZW9mIF9jZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGFpbjogY2hhaW5pbmcgb24gbm9uLWNhbmNlbGxhYmxlIGZ1bmN0aW9uJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZm4gPSBfY2ZuO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gQ2FuY2VsIGNoYWluIGV4ZWN1dGlvbi5cbiAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICBpZiAoY2ZuKSB7XG4gICAgICAgIGNmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0YXJ0IGNoYWluIGV4ZWN1dGlvbi5cbiAgICAvLyBXZSBjYWxsIGV4ZWMgYXMgaWYgbGlua2luZyBmcm9tIGEgcHJldmlvdXMgZnVuY3Rpb24gaW4gdGhlIGNoYWluLFxuICAgIC8vIGV4Y2VwdCB0aGF0IHRoZSBlcnJvciBpcyBhbHdheXMgbnVsbC4gQXMgYSBjb25zZXF1ZW5jZSwgY2hhaW5pbmcgb24gYW5cbiAgICAvLyBlbXB0eSBsaXN0IHlpZWxkcyB0aGUgaWRlbnRpdHkgZnVuY3Rpb24uXG4gICAgYXJncy51bnNoaWZ0KG51bGwpO1xuICAgIGV4ZWMuYXBwbHkobnVsbCwgYXJncyk7IC8vIGV4ZWMobnVsbCwgYXJncy4uLilcblxuICAgIHJldHVybiBjYW5jZWw7XG5cbiAgfTtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoYWluO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYW1wOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gU2V0cyBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcyB0byB1bmRlZmluZWQuIFRoaXMgbWF5IGJlIGNhbGxlZCBieVxuLy8gZGVzdHJ1Y3RvcnMgdG8gYXZvaWQgcmV0YWluaW5nIHJlZmVyZW5jZXMgYW5kIGhlbHAgZGV0ZWN0IGluY29ycmVjdCB1c2Ugb2Zcbi8vIGRlc3Ryb3llZCBpbnN0YW5jZXMuXG5mdW5jdGlvbiBjbGVhck93blByb3BlcnRpZXMob2JqKSB7XG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgb2JqW3Byb3BdID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsZWFyT3duUHJvcGVydGllcztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY21wKHgsIHkpIHtcbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh4ID4geSkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNtcDsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICAqIENvbXBvc2UgbXVsdGlwbGUgZnVuY3Rpb25zXG4gICpcbiAgKiBgY29tcG9zZShmLCBnKWAgcmV0dXJucyBgZnVuY3Rpb24oeCkgeyByZXR1cm4gZihnKHgpKTsgfWBcbiAgKlxuICAqIEBtZW1iZXJvZiB1dGlsXG4gICogQHBhcmFtIHtGdW5jdGlvbltdfSBmdW5jdGlvbnMgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlXG4gICogQHJldHVybiB7RnVuY3Rpb259XG4gICovXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICB2YXIgZm5MaXN0ID0gYXJndW1lbnRzO1xuICByZXR1cm4gZnVuY3Rpb24gY29tcG9zZWQoaW5pdGlhbEFyZykge1xuICAgIHZhciByZXQgPSBpbml0aWFsQXJnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm5MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZm4gPSBmbkxpc3RbaV07XG4gICAgICByZXQgPSBmbi5jYWxsKG51bGwsIHJldCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcG9zZTsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29udmVydCBmb3ZcbiAqXG4gKiBGb3IgZXhhbXBsZSwgdG8gY29udmVydCBmcm9tIGhmb3YgdG8gdmZvdiBvbmUgd291bGQgY2FsbCBcbiAqIGBjb252ZXJ0KGhmb3YsIHdpZHRoLCBoZWlnaHQpYFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3ZcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tRGltZW5zaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdG9EaW1lbnNpb25cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBtZW1iZXJvZiB1dGlsLmNvbnZlcnRGb3ZcbiAqL1xuZnVuY3Rpb24gY29udmVydChmb3YsIGZyb21EaW1lbnNpb24sIHRvRGltZW5zaW9uKSB7XG4gIHJldHVybiAyICogTWF0aC5hdGFuKHRvRGltZW5zaW9uICogTWF0aC50YW4oZm92IC8gMikgLyBmcm9tRGltZW5zaW9uKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZm92XG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbURpbWVuc2lvblxuICogQHBhcmFtIHtudW1iZXJ9IHRvRGltZW5zaW9uXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAbWVtYmVyb2YgdXRpbC5jb252ZXJ0Rm92XG4gKi9cbmZ1bmN0aW9uIGh0b3YoZm92LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiBjb252ZXJ0KGZvdiwgd2lkdGgsIGhlaWdodCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGZvdlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21EaW1lbnNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0RpbWVuc2lvblxuICogQHJldHVybiB7bnVtYmVyfVxuICogQG1lbWJlcm9mIHV0aWwuY29udmVydEZvdlxuICovXG5mdW5jdGlvbiBodG9kKGZvdiwgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gY29udmVydChmb3YsIHdpZHRoLCBNYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3ZcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tRGltZW5zaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdG9EaW1lbnNpb25cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBtZW1iZXJvZiB1dGlsLmNvbnZlcnRGb3ZcbiAqL1xuZnVuY3Rpb24gdnRvaChmb3YsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIGNvbnZlcnQoZm92LCBoZWlnaHQsIHdpZHRoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZm92XG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbURpbWVuc2lvblxuICogQHBhcmFtIHtudW1iZXJ9IHRvRGltZW5zaW9uXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAbWVtYmVyb2YgdXRpbC5jb252ZXJ0Rm92XG4gKi9cbmZ1bmN0aW9uIHZ0b2QoZm92LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiBjb252ZXJ0KGZvdiwgaGVpZ2h0LCBNYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3ZcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tRGltZW5zaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdG9EaW1lbnNpb25cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBtZW1iZXJvZiB1dGlsLmNvbnZlcnRGb3ZcbiAqL1xuZnVuY3Rpb24gZHRvaChmb3YsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIGNvbnZlcnQoZm92LCBNYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCksIHdpZHRoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZm92XG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbURpbWVuc2lvblxuICogQHBhcmFtIHtudW1iZXJ9IHRvRGltZW5zaW9uXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAbWVtYmVyb2YgdXRpbC5jb252ZXJ0Rm92XG4gKi9cbmZ1bmN0aW9uIGR0b3YoZm92LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiBjb252ZXJ0KGZvdiwgTWF0aC5zcXJ0KHdpZHRoICogd2lkdGggKyBoZWlnaHQgKiBoZWlnaHQpLCBoZWlnaHQpO1xufVxuXG4vKipcbiAqIEBuYW1lc3BhY2UgdXRpbC5jb252ZXJ0Rm92XG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb252ZXJ0OiBjb252ZXJ0LFxuICBodG92OiBodG92LFxuICBodG9kOiBodG9kLFxuICB2dG9oOiB2dG9oLFxuICB2dG9kOiB2dG9kLFxuICBkdG9oOiBkdG9oLFxuICBkdG92OiBkdG92XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBDb252ZXJ0IGEgbnVtYmVyIHRvIGEgc3RyaW5nIGluIGRlY2ltYWwgbm90YXRpb24uXG5mdW5jdGlvbiBkZWNpbWFsKHgpIHtcbiAgLy8gRG91YmxlLXByZWNpc2lvbiBmbG9hdHMgaGF2ZSAxNSBzaWduaWZpY2FudCBkZWNpbWFsIGRpZ2l0cy5cbiAgcmV0dXJuIHgudG9QcmVjaXNpb24oMTUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY2ltYWw7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBkZWZhdWx0cyhvYmosIGRlZmF1bHRzT2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBkZWZhdWx0c09iaikge1xuICAgIGlmICghKGtleSBpbiBvYmopKSB7XG4gICAgICBvYmpba2V5XSA9IGRlZmF1bHRzT2JqW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBkZWZlcihmbiwgYXJncykge1xuICBmdW5jdGlvbiBkZWZlcnJlZCgpIHtcbiAgICBpZiAoYXJncyAmJiBhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbigpO1xuICAgIH1cbiAgfVxuICBzZXRUaW1lb3V0KGRlZmVycmVkLCAwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWZlcjsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWdcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGVnVG9SYWQoZGVnKSB7XG4gIHJldHVybiBkZWcgKiBNYXRoLlBJIC8gMTgwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZ1RvUmFkOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gUGVyZm9ybSBhIGNhbmNlbGFibGUgZGVsYXkuXG4vLyBTZWUgdXRpbC9jYW5jZWxpemUuanMgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIHdoYXQgY2FuY2VsYWJsZXMgYXJlLlxuZnVuY3Rpb24gZGVsYXkobXMsIGRvbmUpIHtcblxuICAvLyBXb3JrIGFyb3VuZCBJRTggYnVnIHdoZXJlYnkgYSBzZXRUaW1lb3V0IGNhbGxiYWNrIG1heSBzdGlsbCBiZSBjYWxsZWRcbiAgLy8gYWZ0ZXIgdGhlIGNvcnJlc3BvbmRpbmcgY2xlYXJUaW1lb3V0IGlzIGludm9rZWQuXG4gIHZhciB0aW1lciA9IG51bGw7XG5cbiAgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgIGlmICh0aW1lciAhPSBudWxsKSB7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgICBkb25lKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXIgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICB0aW1lciA9IHNldFRpbWVvdXQoZmluaXNoLCBtcyk7XG5cbiAgcmV0dXJuIGNhbmNlbDtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlbGF5O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIHByZWZpeFByb3BlcnR5KHByb3BlcnR5KSB7XG5cbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuICB2YXIgcHJlZml4TGlzdCA9IFsnTW96JywgJ1dlYmtpdCcsICdLaHRtbCcsICdPJywgJ21zJ107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeCA9IHByZWZpeExpc3RbaV07XG4gICAgdmFyIGNhcGl0YWxpemVkUHJvcGVydHkgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG4gICAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBwcmVmaXggKyBjYXBpdGFsaXplZFByb3BlcnR5O1xuXG4gICAgaWYgKHByZWZpeGVkUHJvcGVydHkgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZFByb3BlcnR5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wZXJ0eTtcblxufVxuXG5cbmZ1bmN0aW9uIGdldFdpdGhWZW5kb3JQcmVmaXgocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBwcmVmaXhQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm9wZXJ0eVdpdGhWZW5kb3JQcmVmaXgoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LnN0eWxlW3ByZWZpeGVkUHJvcGVydHldO1xuICB9O1xuXG59XG5cblxuZnVuY3Rpb24gc2V0V2l0aFZlbmRvclByZWZpeChwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IHByZWZpeFByb3BlcnR5KHByb3BlcnR5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3BlcnR5V2l0aFZlbmRvclByZWZpeChlbGVtZW50LCB2YWwpIHtcbiAgICByZXR1cm4gKGVsZW1lbnQuc3R5bGVbcHJlZml4ZWRQcm9wZXJ0eV0gPSB2YWwpO1xuICB9O1xufVxuXG5cbnZhciBzZXRUcmFuc2Zvcm0gPSBzZXRXaXRoVmVuZG9yUHJlZml4KCd0cmFuc2Zvcm0nKTtcbnZhciBzZXRUcmFuc2Zvcm1PcmlnaW4gPSBzZXRXaXRoVmVuZG9yUHJlZml4KCd0cmFuc2Zvcm1PcmlnaW4nKTtcblxuXG5mdW5jdGlvbiBzZXROdWxsVHJhbnNmb3JtKGVsZW1lbnQpIHtcbiAgc2V0VHJhbnNmb3JtKGVsZW1lbnQsICd0cmFuc2xhdGVaKDApJyk7XG59XG5cblxuZnVuY3Rpb24gc2V0TnVsbFRyYW5zZm9ybU9yaWdpbihlbGVtZW50KSB7XG4gIHNldFRyYW5zZm9ybU9yaWdpbihlbGVtZW50LCAnMCAwIDAnKTtcbn1cblxuXG5mdW5jdGlvbiBzZXRBYnNvbHV0ZShlbGVtZW50KSB7XG4gIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xufVxuXG5cbmZ1bmN0aW9uIHNldFBpeGVsUG9zaXRpb24oZWxlbWVudCwgeCwgeSkge1xuICBlbGVtZW50LnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgZWxlbWVudC5zdHlsZS50b3AgPSB5ICsgJ3B4Jztcbn1cblxuXG5mdW5jdGlvbiBzZXRQaXhlbFNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCkge1xuICBlbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG59XG5cblxuZnVuY3Rpb24gc2V0TnVsbFNpemUoZWxlbWVudCkge1xuICBlbGVtZW50LnN0eWxlLndpZHRoID0gZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAwO1xufVxuXG5cbmZ1bmN0aW9uIHNldEZ1bGxTaXplKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5zdHlsZS53aWR0aCA9IGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xufVxuXG5cbmZ1bmN0aW9uIHNldE92ZXJmbG93SGlkZGVuKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xufVxuXG5cbmZ1bmN0aW9uIHNldE92ZXJmbG93VmlzaWJsZShlbGVtZW50KSB7XG4gIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAndmlzaWJsZSc7XG59XG5cblxuZnVuY3Rpb24gc2V0Tm9Qb2ludGVyRXZlbnRzKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xufVxuXG5cbmZ1bmN0aW9uIHNldEJsb2NraW5nKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnIzAwMCc7XG4gIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgZWxlbWVudC5zdHlsZS5maWx0ZXIgPSAnYWxwaGEob3BhY2l0eT0wKSc7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHByZWZpeFByb3BlcnR5OiBwcmVmaXhQcm9wZXJ0eSxcbiAgZ2V0V2l0aFZlbmRvclByZWZpeDogZ2V0V2l0aFZlbmRvclByZWZpeCxcbiAgc2V0V2l0aFZlbmRvclByZWZpeDogc2V0V2l0aFZlbmRvclByZWZpeCxcbiAgc2V0VHJhbnNmb3JtOiBzZXRUcmFuc2Zvcm0sXG4gIHNldFRyYW5zZm9ybU9yaWdpbjogc2V0VHJhbnNmb3JtT3JpZ2luLFxuICBzZXROdWxsVHJhbnNmb3JtOiBzZXROdWxsVHJhbnNmb3JtLFxuICBzZXROdWxsVHJhbnNmb3JtT3JpZ2luOiBzZXROdWxsVHJhbnNmb3JtT3JpZ2luLFxuICBzZXRBYnNvbHV0ZTogc2V0QWJzb2x1dGUsXG4gIHNldFBpeGVsUG9zaXRpb246IHNldFBpeGVsUG9zaXRpb24sXG4gIHNldFBpeGVsU2l6ZTogc2V0UGl4ZWxTaXplLFxuICBzZXROdWxsU2l6ZTogc2V0TnVsbFNpemUsXG4gIHNldEZ1bGxTaXplOiBzZXRGdWxsU2l6ZSxcbiAgc2V0T3ZlcmZsb3dIaWRkZW46IHNldE92ZXJmbG93SGlkZGVuLFxuICBzZXRPdmVyZmxvd1Zpc2libGU6IHNldE92ZXJmbG93VmlzaWJsZSxcbiAgc2V0Tm9Qb2ludGVyRXZlbnRzOiBzZXROb1BvaW50ZXJFdmVudHMsXG4gIHNldEJsb2NraW5nOiBzZXRCbG9ja2luZ1xufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZXh0ZW5kKG9iaiwgc291cmNlT2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2VPYmopIHtcbiAgICBvYmpba2V5XSA9IHNvdXJjZU9ialtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIGdsb2JhbCBvYmplY3QuXG52YXIgZ2xvYmFsT2JqZWN0ID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG4gIHJldHVybiBudWxsO1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxPYmplY3Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIEplbmtpbnMgb25lLWF0LWEtdGltZSBoYXNoXG4vLyBodHRwOi8vd3d3LmJ1cnRsZWJ1cnRsZS5uZXQvYm9iL2hhc2gvZG9vYnMuaHRtbFxuLy8gSW5wdXQ6IGFuIGFycmF5IG9mIGludGVnZXJzXG4vLyBPdXRwdXQ6IGFuIGludGVnZXJcblxuZnVuY3Rpb24gaGFzaCgpIHtcbiAgdmFyIGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrID0gYXJndW1lbnRzW2ldO1xuICAgIGggKz0gaztcbiAgICBoICs9IGsgPDwgMTA7XG4gICAgaCBePSBrID4+IDY7XG4gIH1cbiAgaCArPSBoIDw8IDM7XG4gIGggXj0gaCA+PiAxMTtcbiAgaCArPSBoIDw8IDE1O1xuICByZXR1cm4gaCA+PSAwID8gaCA6IC1oO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2g7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNYWtlIGN0b3IgYSBzdWJjbGFzcyBvZiBzdXBlckN0b3IuXG4vLyBEbyBub3QgZGVwZW5kIG9uIEVTNSBPYmplY3QuY3JlYXRlIHNlbWFudGljcyBiZWNhdXNlIG9mIG9sZGVyIGJyb3dzZXJzLlxuZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbigpIHt9O1xuICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5oZXJpdHM7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBSZXR1cm5zIHdoZXRoZXIgbiBpcyBhIHBvd2VyIG9mIHR3by5cbmZ1bmN0aW9uIGlzcG90KG4pIHtcbiAgcmV0dXJuIChuICYgKG4gLSAxKSkgPT0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc3BvdDsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxvIG9wZXJhdGlvblxuICpcbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge051bWJlcn0gZGl2aWRlbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXZpc29yXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBWYWx1ZSBpbiByYW5nZSBgWzAsZGl2aXNvcltgXG4gKi9cbmZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gIHJldHVybiAoK2EgJSAoYiA9ICtiKSArIGIpICUgYjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb2Q7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxubW9kdWxlLmV4cG9ydHMgPSBub29wOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0Tm93KCkge1xuICBpZiAodHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiBwZXJmb3JtYW5jZS5ub3cpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gZGF0ZU5vdygpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROb3coKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb25jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHZhciB2YWx1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VkKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgdmFsdWUgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb25jZTsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0UGl4ZWxSYXRpbyA9IDE7XG5cbmZ1bmN0aW9uIHBpeGVsUmF0aW8oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykge1xuICAgICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzY3JlZW4gPSB3aW5kb3cuc2NyZWVuO1xuICAgICAgaWYgKHNjcmVlbiAmJiBzY3JlZW4uZGV2aWNlWERQSSAmJiBzY3JlZW4ubG9naWNhbFhEUEkpIHtcbiAgICAgICAgcmV0dXJuIHNjcmVlbi5kZXZpY2VYRFBJIC8gc2NyZWVuLmxvZ2ljYWxYRFBJO1xuICAgICAgfSBlbHNlIGlmIChzY3JlZW4gJiYgc2NyZWVuLnN5c3RlbVhEUEkgJiYgc2NyZWVuLmxvZ2ljYWxYRFBJKSB7XG4gICAgICAgIHJldHVybiBzY3JlZW4uc3lzdGVtWERQSSAvIHNjcmVlbi5sb2dpY2FsWERQSTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRQaXhlbFJhdGlvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpeGVsUmF0aW87XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzZXRUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2RvbScpLnNldFRyYW5zZm9ybTtcbnZhciBkZWNpbWFsID0gcmVxdWlyZSgnLi9kZWNpbWFsJyk7XG5cbmZ1bmN0aW9uIHBvc2l0aW9uQWJzb2x1dGVseShlbGVtZW50LCB4LCB5LCBleHRyYVRyYW5zZm9ybXMpIHtcbiAgZXh0cmFUcmFuc2Zvcm1zID0gZXh0cmFUcmFuc2Zvcm1zIHx8ICcnO1xuICAvLyBBIHRyYW5zbGF0ZVooMCkgdHJhbnNmb3JtIGltcHJvdmVzIHBlcmZvcm1hbmNlIG9uIENocm9tZSBieSBjcmVhdGluZyBhXG4gIC8vIG5ldyBsYXllciBmb3IgdGhlIGVsZW1lbnQsIHdoaWNoIHByZXZlbnRzIHVubmVjZXNzYXJ5IHJlcGFpbnRzLlxuICB2YXIgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVgoJyArIGRlY2ltYWwoeCkgKyAncHgpIHRyYW5zbGF0ZVkoJyArIGRlY2ltYWwoeSkgKyAncHgpIHRyYW5zbGF0ZVooMCkgJyArIGV4dHJhVHJhbnNmb3JtcztcbiAgc2V0VHJhbnNmb3JtKGVsZW1lbnQsIHRyYW5zZm9ybSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcG9zaXRpb25BYnNvbHV0ZWx5O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHJhZFRvRGVnKHJhZCkge1xuICByZXR1cm4gcmFkICogMTgwIC8gTWF0aC5QSTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByYWRUb0RlZzsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHJlYWwoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmIGlzRmluaXRlKHgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWw7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9vcCA9IHJlcXVpcmUoJy4vbm9vcCcpO1xuXG4vLyBSZXR1cm4gYSBjYW5jZWxhYmxlIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgZm4gaW4gYSBsb29wIHVudGlsIGl0IHJldHVybnNcbi8vIHN1Y2Nlc3NmdWxseS5cbmZ1bmN0aW9uIHJldHJ5KGZuKSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJldHJpZWQoKSB7XG5cbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKSA6IFtdO1xuICAgIHZhciBkb25lID0gYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0gOiBub29wO1xuXG4gICAgdmFyIGNmbiA9IG51bGw7XG4gICAgdmFyIGNhbmNlbGVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmICghZXJyIHx8IGNhbmNlbGVkKSB7XG4gICAgICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNmbiA9IGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFyZ3MucHVzaChleGVjKTtcbiAgICBleGVjKHRydWUpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgIGNmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgfTtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJldHJ5O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm93ID0gcmVxdWlyZSgnLi9ub3cnKTtcblxuZnVuY3Rpb24gdHdlZW4oZHVyYXRpb24sIHVwZGF0ZSwgZG9uZSkge1xuICB2YXIgY2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgdmFyIHN0YXJ0VGltZSA9IG5vdygpO1xuXG4gIGZ1bmN0aW9uIHJ1blVwZGF0ZSgpIHtcbiAgICBpZihjYW5jZWxsZWQpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHR3ZWVuVmFsID0gKG5vdygpIC0gc3RhcnRUaW1lKS9kdXJhdGlvbjtcbiAgICBpZih0d2VlblZhbCA8IDEpIHtcbiAgICAgIHVwZGF0ZSh0d2VlblZhbCk7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuVXBkYXRlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB1cGRhdGUoMSk7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKDApO1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuVXBkYXRlKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgZG9uZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHdlZW47IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiB0eXBlKHgpIHtcbiAgdmFyIHR5cCA9IHR5cGVvZiB4O1xuICBpZiAodHlwID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHR5cDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDQ7XG52YXIgdmVjNCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLnZlYzQ7XG52YXIgcGl4ZWxSYXRpbyA9IHJlcXVpcmUoJy4uL3V0aWwvcGl4ZWxSYXRpbycpO1xudmFyIHJlYWwgPSByZXF1aXJlKCcuLi91dGlsL3JlYWwnKTtcbnZhciBjbGFtcCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhbXAnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vLyBEZWZhdWx0IHZpZXdwb3J0IGRpbWVuc2lvbnMuXG4vLyBTdGFydCB3aXRoIHplcm8gdG8gZW5zdXJlIHRoYXQgdGhvc2UgdmFsdWVzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cbnZhciBkZWZhdWx0V2lkdGggPSAwO1xudmFyIGRlZmF1bHRIZWlnaHQgPSAwO1xuXG4vLyBEZWZhdWx0IHZpZXcgcGFyYW1ldGVycy5cbnZhciBkZWZhdWx0WCA9IDAuNTtcbnZhciBkZWZhdWx0WSA9IDAuNTtcbnZhciBkZWZhdWx0Wm9vbSA9IDE7XG5cbi8vIENvbnN0YW50IHZhbHVlcyB1c2VkIHRvIHNpbXBsaWZ5IHRoZSBmcnVzdHVtIGN1bGxpbmcgbG9naWMuXG4vLyBwbGFuZUF4ZXNbaV0gaW5kaWNhdGVzIHRoZSBjb29yZGluYXRlIHZhbHVlIHRoYXQgZGVmaW5lcyBhIGZydXN0dW0gcGxhbmUuXG4vLyBwbGFuZUNtcFtpXSBpbmRpY2F0ZXMgaG93IHBvaW50IGFuZCBwbGFuZSBjb29yZGluYXRlcyBzaG91bGQgYmUgY29tcGFyZWRcbi8vIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBwb2ludCBpcyBvbiB0aGUgb3V0ZXIgc2lkZSBvZiB0aGUgcGxhbmUuXG52YXIgcGxhbmVBeGVzID0gW1xuICAxLCAvLyB0b3BcbiAgMCwgLy8gcmlnaHRcbiAgMSwgLy8gYm90dG9tXG4gIDAgIC8vIGxlZnRcbl07XG52YXIgcGxhbmVDbXAgPSBbXG4gIC0xLCAvLyB0b3BcbiAgLTEsIC8vIHJpZ2h0XG4gICAxLCAvLyBib3R0b21cbiAgIDEgIC8vIGxlZnRcbl07XG5cbi8vIEEgem9vbSBvZiBleGFjdGx5IDAgYnJlYWtzIHNvbWUgY29tcHV0YXRpb25zLCBzbyB3ZSBmb3JjZSBhIG1pbmltdW0gcG9zaXRpdmVcbi8vIHZhbHVlLiBXZSB1c2UgNiBkZWNpbWFsIHBsYWNlcyBmb3IgdGhlIGVwc2lsb24gdmFsdWUgdG8gYXZvaWQgYnJva2VuXG4vLyByZW5kZXJpbmcgZHVlIHRvIGxvc3Mgb2YgcHJlY2lzaW9uIGluIGZsb2F0aW5nIHBvaW50IGNvbXB1dGF0aW9ucy5cbnZhciB6b29tTGltaXRFcHNpbG9uID0gMC4wMDAwMDE7XG5cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEZsYXRWaWV3UGFyYW1zXG4gKlxuICogQSBjYW1lcmEgY29uZmlndXJhdGlvbiBmb3IgYSB7QGxpbmsgRmxhdFZpZXd9LlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUgb2YgdGhlIGltYWdlIHBvaW50IGRpc3BsYXllZFxuICogICAgIGF0IHRoZSB2aWV3cG9ydCBjZW50ZXIsIGluIHRoZSBbMCwgMV0gcmFuZ2UuXG4gKiAgICAgV2hlbiBgeCA9PT0gMC41YCwgdGhlIGltYWdlIGlzIGNlbnRlcmVkIGhvcml6b250YWxseS5cbiAqICAgICBXaGVuIGB4ID09PSAwYCwgdGhlIGxlZnQgZWRnZSBvZiB0aGUgaW1hZ2UgaXMgYXQgdGhlIHZpZXdwb3J0IGNlbnRlci5cbiAqICAgICBXaGVuIGB4ID09PSAxYCwgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGltYWdlIGlzIGF0IHRoZSB2aWV3cG9ydCBjZW50ZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZSBvZiB0aGUgaW1hZ2UgcG9pbnQgZGlzcGxheWVkIGF0XG4gKiAgICAgdGhlIHZpZXdwb3J0IGNlbnRlciwgaW4gdGhlIFswLCAxXSByYW5nZS5cbiAqICAgICBXaGVuIGB5ID09PSAwLjVgLCB0aGUgaW1hZ2UgaXMgY2VudGVyZWQgdmVydGljYWxseS5cbiAqICAgICBXaGVuIGB5ID09PSAwYCwgdGhlIHRvcCBlZGdlIG9mIHRoZSBpbWFnZSBpcyBhdCB0aGUgdmlld3BvcnQgY2VudGVyLlxuICogICAgIFdoZW4gYHkgPT09IDFgLCB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIGltYWdlIGlzIGF0IHRoZSB2aWV3cG9ydCBjZW50ZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gem9vbSBUaGUgaG9yaXpvbnRhbCB6b29tLCBpbiB0aGUgWzAsIOKInikgcmFuZ2UuXG4gKiAgICAgV2hlbiBgem9vbSA9PT0gMWAsIHRoZSB2aWV3cG9ydCBpcyBhcyB3aWRlIGFzIHRoZSBpbWFnZS5cbiAqICAgICBXaGVuIGB6b29tIDwgMWAsIHRoZSBpbWFnZSBpcyB6b29tZWQgaW4uXG4gKiAgICAgV2hlbiBgem9vbSA+IDFgLCB0aGUgaW1hZ2UgaXMgem9vbWVkIG91dC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtZWRpYUFzcGVjdFJhdGlvIFRoZSBpbWFnZSBhc3BlY3QgcmF0aW8uXG4gKiAgICAgV2hlbiBgbWVkaWFBc3BlY3RSYXRpbyA9PT0gMWAsIHRoZSBpbWFnZSB3aWR0aCBlcXVhbHMgaXRzIGhlaWdodC5cbiAqICAgICBXaGVuIGBtZWRpYUFzcGVjdFJhdGlvIDwgMWAsIHRoZSBpbWFnZSB3aWR0aCBpcyBsZXNzIHRoYW4gaXRzIGhlaWdodC5cbiAqICAgICBXaGVuIGBtZWRpYUFzcGVjdFJhdGlvID4gMWAsIHRoZSBpbWFnZSBoZWlnaHQgaXMgbGVzcyB0aGFuIGl0cyB3aWR0aC5cbiAqL1xuXG5cbi8qKlxuICogQGludGVyZmFjZSBGbGF0Vmlld0Nvb3Jkc1xuICpcbiAqIFRoZSBwb3NpdGlvbiBvZiBhIHBvaW50IGluIGEgZmxhdCBpbWFnZS5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLCBpbiB0aGUgWzAsIDFdIHJhbmdlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUsIGluIHRoZSBbMCwgMV0gcmFuZ2UuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gRmxhdFZpZXdMaW1pdGVyXG4gKlxuICogVmlldyBsaW1pdGVyIGZvciBhIHtAbGluayBGbGF0Vmlld30uXG4gKlxuICogQSB2aWV3IGxpbWl0ZXIgaXMgYSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEge0BsaW5rIEZsYXRWaWV3UGFyYW1zfSBvYmplY3QsXG4gKiBvcHRpb25hbGx5IG1vZGlmaWVzIGl0IGluIHBsYWNlLCBhbmQgcmV0dXJucyBpdC4gSXQgY2FuIGJlIHVzZWQgdG8gZW5mb3JjZVxuICogY29uc3RyYWludHMgb24gdGhlIHZpZXcgcGFyYW1ldGVycy5cbiAqXG4gKiBTZWUge0BsaW5rIEZsYXRWaWV3LmxpbWl0fSBmb3IgY29tbW9ubHkgdXNlZCBsaW1pdGVycy4gVGhleSBtYXkgYmUgY29tcG9zZWRcbiAqIHRvZ2V0aGVyIG9yIHdpdGggdXNlci1kZWZpbmVkIGxpbWl0ZXJzIHdpdGgge0BsaW5rIHV0aWwuY29tcG9zZX0uXG4gKlxuICogQHBhcmFtIHtGbGF0Vmlld1BhcmFtc30gcGFyYW1zXG4gKiBAcmV0dXJuIHtGbGF0Vmlld1BhcmFtc31cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzIEZsYXRWaWV3XG4gKiBAaW1wbGVtZW50cyBWaWV3XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB7QGxpbmsgVmlld30gaW1wbGVtZW50aW5nIGFuIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBmb3IgZmxhdCBpbWFnZXMuXG4gKlxuICogQHBhcmFtIHtGbGF0Vmlld1BhcmFtc30gcGFyYW1zIFRoZSBpbml0aWFsIHZpZXcgcGFyYW1ldGVycy4gVGhlXG4gKiAgICAgYG1lZGlhQXNwZWN0UmF0aW9gIHBhcmFtZXRlciBtdXN0IGFsd2F5cyBiZSBzZXQuIFRoZSBvdGhlciBwYXJhbWV0ZXJzXG4gKiAgICAgZGVmYXVsdCB0byBge3g6IDAuNSwgeTogMC41LCB6OiAxIH1gIGlmIHVuc3BlY2lmaWVkLlxuICogQHBhcmFtIHtGbGF0Vmlld0xpbWl0ZXI9fSBsaW1pdGVyIFRoZSB2aWV3IGxpbWl0ZXIuIElmIHVuc3BlY2lmaWVkLCBubyB2aWV3XG4gKiAgICAgbGltaXRpbmcgaXMgYXBwbGllZC4gU2VlIHtAbGluayBGbGF0Vmlldy5saW1pdH0gZm9yIGNvbW1vbmx5IHVzZWRcbiAqICAgICBsaW1pdGVycy5cbiAqL1xuZnVuY3Rpb24gRmxhdFZpZXcocGFyYW1zLCBsaW1pdGVyKSB7XG4gIC8vIFJlcXVpcmUgYW4gYXNwZWN0IHJhdGlvIHRvIGJlIHNwZWNpZmllZC5cbiAgaWYgKCEocGFyYW1zICYmIHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvICE9IG51bGwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtZWRpYUFzcGVjdFJhdGlvIG11c3QgYmUgZGVmaW5lZCcpO1xuICB9XG5cbiAgLy8gVGhlIGluaXRpYWwgdmFsdWVzIGZvciB0aGUgdmlldyBwYXJhbWV0ZXJzLlxuICB0aGlzLl94ID0gcGFyYW1zICYmIHBhcmFtcy54ICE9IG51bGwgPyBwYXJhbXMueCA6IGRlZmF1bHRYO1xuICB0aGlzLl95ID0gcGFyYW1zICYmIHBhcmFtcy55ICE9IG51bGwgPyBwYXJhbXMueSA6IGRlZmF1bHRZO1xuICB0aGlzLl96b29tID0gcGFyYW1zICYmIHBhcmFtcy56b29tICE9IG51bGwgPyBwYXJhbXMuem9vbSA6IGRlZmF1bHRab29tO1xuICB0aGlzLl9tZWRpYUFzcGVjdFJhdGlvID0gcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW87XG4gIHRoaXMuX3dpZHRoID0gcGFyYW1zICYmIHBhcmFtcy53aWR0aCAhPSBudWxsID9cbiAgICBwYXJhbXMud2lkdGggOiBkZWZhdWx0V2lkdGg7XG4gIHRoaXMuX2hlaWdodCA9IHBhcmFtcyAmJiBwYXJhbXMuaGVpZ2h0ICE9IG51bGwgP1xuICAgIHBhcmFtcy5oZWlnaHQgOiBkZWZhdWx0SGVpZ2h0O1xuXG4gIC8vIFRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGUgdmlldyBsaW1pdGVyLlxuICB0aGlzLl9saW1pdGVyID0gbGltaXRlciB8fCBudWxsO1xuXG4gIC8vIFRoZSBsYXN0IGNhbGN1bGF0ZWQgcHJvamVjdGlvbiBtYXRyaXggYW5kIGl0cyBpbnZlcnNlLlxuICB0aGlzLl9wcm9qTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgdGhpcy5faW52UHJvak1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgLy8gVGhlIGxhc3QgY2FsY3VsYXRlZCB2aWV3IGZydXN0dW0uXG4gIHRoaXMuX2ZydXN0dW0gPSBbXG4gICAgMCwgLy8gdG9wXG4gICAgMCwgLy8gcmlnaHRcbiAgICAwLCAvLyBib3R0b21cbiAgICAwICAvLyBsZWZ0XG4gIF07XG5cbiAgLy8gV2hldGhlciB0aGUgcHJvamVjdGlvbiBtYXRyaWNlcyBhbmQgdmlldyBmcnVzdHVtIG5lZWQgdG8gYmUgdXBkYXRlZC5cbiAgdGhpcy5fcHJvamVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuXG4gIC8vIFRlbXBvcmFyeSB2YXJpYWJsZXMgdXNlZCBmb3IgY2FsY3VsYXRpb25zLlxuICB0aGlzLl9wYXJhbXMgPSB7fTtcbiAgdGhpcy5fdmVjID0gdmVjNC5jcmVhdGUoKTtcblxuICAvLyBGb3JjZSB2aWV3IGxpbWl0aW5nIG9uIGluaXRpYWwgcGFyYW1ldGVycy5cbiAgdGhpcy5fdXBkYXRlKCk7XG59XG5cbmV2ZW50RW1pdHRlcihGbGF0Vmlldyk7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB4IHBhcmFtZXRlci5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3g7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB5IHBhcmFtZXRlci5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3k7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB6b29tIHZhbHVlLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuem9vbSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fem9vbTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIG1lZGlhIGFzcGVjdCByYXRpby5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLm1lZGlhQXNwZWN0UmF0aW8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX21lZGlhQXNwZWN0UmF0aW87XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB2aWV3cG9ydCB3aWR0aC5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb3J0IGhlaWdodC5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faGVpZ2h0O1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdmlld3BvcnQgZGltZW5zaW9ucy4gSWYgYW4gYXJndW1lbnQgaXMgc3VwcGxpZWQsIGl0IGlzIGZpbGxlZCBpbiB3aXRoXG4gKiB0aGUgcmVzdWx0IGFuZCByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIGZyZXNoIG9iamVjdCBpcyBmaWxsZWQgaW4gYW5kIHJldHVybmVkLlxuICogQHBhcmFtIHtTaXplPX0gc2l6ZVxuICogQHJldHVybiB7U2l6ZX1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gIHNpemUgPSBzaXplIHx8IHt9O1xuICBzaXplLndpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHNpemUuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICByZXR1cm4gc2l6ZTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXcgcGFyYW1ldGVycy4gSWYgYW4gYXJndW1lbnQgaXMgc3VwcGxpZWQsIGl0IGlzIGZpbGxlZCBpbiB3aXRoIHRoZVxuICogcmVzdWx0IGFuZCByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIGZyZXNoIG9iamVjdCBpcyBmaWxsZWQgaW4gYW5kIHJldHVybmVkLlxuICogQHBhcmFtIHtGbGF0Vmlld1BhcmFtcz19IHBhcmFtc1xuICogQHJldHVybiB7RmxhdFZpZXdQYXJhbXN9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgcGFyYW1zLnggPSB0aGlzLl94O1xuICBwYXJhbXMueSA9IHRoaXMuX3k7XG4gIHBhcmFtcy56b29tID0gdGhpcy5fem9vbTtcbiAgcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW8gPSB0aGlzLl9tZWRpYUFzcGVjdFJhdGlvO1xuICByZXR1cm4gcGFyYW1zO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdmlldyBsaW1pdGVyLCBvciBudWxsIGlmIHVuc2V0LlxuICogQHJldHVybiB7P0ZsYXRWaWV3TGltaXRlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLmxpbWl0ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xpbWl0ZXI7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSB4IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5zZXRYID0gZnVuY3Rpb24oeCkge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMueCA9IHg7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgeSBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0geVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2V0WSA9IGZ1bmN0aW9uKHkpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnkgPSB5O1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHpvb20gdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gem9vbVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uKHpvb20pIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnpvb20gPSB6b29tO1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBBZGQgeE9mZnNldCB0byB0aGUgeCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0geE9mZnNldFxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUub2Zmc2V0WCA9IGZ1bmN0aW9uKHhPZmZzZXQpIHtcbiAgdGhpcy5zZXRYKHRoaXMuX3ggKyB4T2Zmc2V0KTtcbn07XG5cblxuLyoqXG4gKiBBZGQgeU9mZnNldCB0byB0aGUgeSBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0geU9mZnNldFxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUub2Zmc2V0WSA9IGZ1bmN0aW9uKHlPZmZzZXQpXG57XG4gIHRoaXMuc2V0WSh0aGlzLl95ICsgeU9mZnNldCk7XG59O1xuXG5cbi8qKlxuICogQWRkIHpvb21PZmZzZXQgdG8gdGhlIHpvb20gdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gem9vbU9mZnNldFxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUub2Zmc2V0Wm9vbSA9IGZ1bmN0aW9uKHpvb21PZmZzZXQpIHtcbiAgdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyB6b29tT2Zmc2V0KTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIG1lZGlhIGFzcGVjdCByYXRpby5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtZWRpYUFzcGVjdFJhdGlvXG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5zZXRNZWRpYUFzcGVjdFJhdGlvID0gZnVuY3Rpb24obWVkaWFBc3BlY3RSYXRpbykge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMubWVkaWFBc3BlY3RSYXRpbyA9IG1lZGlhQXNwZWN0UmF0aW87XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgdmlld3BvcnQgZGltZW5zaW9ucy5cbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgdGhpcy5fcGFyYW1zLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHZpZXcgcGFyYW1ldGVycy4gVW5zcGVjaWZpZWQgcGFyYW1ldGVycyBhcmUgbGVmdCB1bmNoYW5nZWQuXG4gKiBAcGFyYW0ge0ZsYXRWaWV3UGFyYW1ldGVyc30gcGFyYW1zXG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5zZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy54ID0gcGFyYW1zLng7XG4gIHRoaXMuX3BhcmFtcy55ID0gcGFyYW1zLnk7XG4gIHRoaXMuX3BhcmFtcy56b29tID0gcGFyYW1zLnpvb207XG4gIHRoaXMuX3BhcmFtcy5tZWRpYUFzcGVjdFJhdGlvID0gcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW87XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgdmlldyBsaW1pdGVyLlxuICogQHBhcmFtIHs/RmxhdFZpZXdMaW1pdGVyfSBsaW1pdGVyIFRoZSBuZXcgbGltaXRlciwgb3IgbnVsbCB0byB1bnNldC5cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnNldExpbWl0ZXIgPSBmdW5jdGlvbihsaW1pdGVyKSB7XG4gIHRoaXMuX2xpbWl0ZXIgPSBsaW1pdGVyIHx8IG51bGw7XG4gIHRoaXMuX3VwZGF0ZSgpO1xufTtcblxuXG5GbGF0Vmlldy5wcm90b3R5cGUuX3Jlc2V0UGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gIHBhcmFtcy54ID0gbnVsbDtcbiAgcGFyYW1zLnkgPSBudWxsO1xuICBwYXJhbXMuem9vbSA9IG51bGw7XG4gIHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvID0gbnVsbDtcbiAgcGFyYW1zLndpZHRoID0gbnVsbDtcbiAgcGFyYW1zLmhlaWdodCA9IG51bGw7XG59O1xuXG5cbkZsYXRWaWV3LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cbiAgLy8gQXZvaWQgb2JqZWN0IGFsbG9jYXRpb24gd2hlbiBubyBwYXJhbWV0ZXJzIGFyZSBzdXBwbGllZC5cbiAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgICBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gIH1cblxuICAvLyBTYXZlIG9sZCBwYXJhbWV0ZXJzIGZvciBsYXRlciBjb21wYXJpc29uLlxuICB2YXIgb2xkWCA9IHRoaXMuX3g7XG4gIHZhciBvbGRZID0gdGhpcy5feTtcbiAgdmFyIG9sZFpvb20gPSB0aGlzLl96b29tO1xuICB2YXIgb2xkTWVkaWFBc3BlY3RSYXRpbyA9IHRoaXMuX21lZGlhQXNwZWN0UmF0aW87XG4gIHZhciBvbGRXaWR0aCA9IHRoaXMuX3dpZHRoO1xuICB2YXIgb2xkSGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gIC8vIEZpbGwgaW4gb2JqZWN0IHdpdGggdGhlIG5ldyBzZXQgb2YgcGFyYW1ldGVycyB0byBwYXNzIGludG8gdGhlIGxpbWl0ZXIuXG4gIHBhcmFtcy54ID0gcGFyYW1zLnggIT0gbnVsbCA/IHBhcmFtcy54IDogb2xkWDtcbiAgcGFyYW1zLnkgPSBwYXJhbXMueSAhPSBudWxsID8gcGFyYW1zLnkgOiBvbGRZO1xuICBwYXJhbXMuem9vbSA9IHBhcmFtcy56b29tICE9IG51bGwgPyBwYXJhbXMuem9vbSA6IG9sZFpvb207XG4gIHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvID0gcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW8gIT0gbnVsbCA/XG4gICAgcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW8gOiBvbGRNZWRpYUFzcGVjdFJhdGlvO1xuICBwYXJhbXMud2lkdGggPSBwYXJhbXMud2lkdGggIT0gbnVsbCA/IHBhcmFtcy53aWR0aCA6IG9sZFdpZHRoO1xuICBwYXJhbXMuaGVpZ2h0ID0gcGFyYW1zLmhlaWdodCAhPSBudWxsID8gcGFyYW1zLmhlaWdodCA6IG9sZEhlaWdodDtcblxuICAvLyBBcHBseSB2aWV3IGxpbWl0aW5nIHdoZW4gZGVmaW5lZC5cbiAgaWYgKHRoaXMuX2xpbWl0ZXIpIHtcbiAgICBwYXJhbXMgPSB0aGlzLl9saW1pdGVyKHBhcmFtcyk7XG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHZpZXcgbGltaXRlcicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdyYWIgdGhlIGxpbWl0ZWQgcGFyYW1ldGVycy5cbiAgdmFyIG5ld1ggPSBwYXJhbXMueDtcbiAgdmFyIG5ld1kgPSBwYXJhbXMueTtcbiAgdmFyIG5ld1pvb20gPSBwYXJhbXMuem9vbTtcbiAgdmFyIG5ld01lZGlhQXNwZWN0UmF0aW8gPSBwYXJhbXMubWVkaWFBc3BlY3RSYXRpbztcbiAgdmFyIG5ld1dpZHRoID0gcGFyYW1zLndpZHRoO1xuICB2YXIgbmV3SGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcblxuICAvLyBDb25zaXN0ZW5jeSBjaGVjay5cbiAgaWYgKCFyZWFsKG5ld1gpIHx8ICFyZWFsKG5ld1kpIHx8ICFyZWFsKG5ld1pvb20pIHx8XG4gICAgICAhcmVhbChuZXdNZWRpYUFzcGVjdFJhdGlvKSB8fCAhcmVhbChuZXdXaWR0aCkgfHwgIXJlYWwobmV3SGVpZ2h0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFkIHZpZXcgLSBzdXNwZWN0IGEgYnJva2VuIGxpbWl0ZXInKTtcbiAgfVxuXG4gIC8vIENvbnN0cmFpbiB6b29tLlxuICBuZXdab29tID0gY2xhbXAobmV3Wm9vbSwgem9vbUxpbWl0RXBzaWxvbiwgSW5maW5pdHkpO1xuXG4gIC8vIFVwZGF0ZSBwYXJhbWV0ZXJzLlxuICB0aGlzLl94ID0gbmV3WDtcbiAgdGhpcy5feSA9IG5ld1k7XG4gIHRoaXMuX3pvb20gPSBuZXdab29tO1xuICB0aGlzLl9tZWRpYUFzcGVjdFJhdGlvID0gbmV3TWVkaWFBc3BlY3RSYXRpbztcbiAgdGhpcy5fd2lkdGggPSBuZXdXaWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gbmV3SGVpZ2h0O1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHBhcmFtZXRlcnMgY2hhbmdlZCBhbmQgZW1pdCB0aGUgY29ycmVzcG9uZGluZyBldmVudHMuXG4gIGlmIChuZXdYICE9PSBvbGRYIHx8IG5ld1kgIT09IG9sZFkgfHwgbmV3Wm9vbSAhPT0gb2xkWm9vbSB8fFxuICAgICAgbmV3TWVkaWFBc3BlY3RSYXRpbyAhPT0gb2xkTWVkaWFBc3BlY3RSYXRpbyB8fFxuICAgICAgbmV3V2lkdGggIT09IG9sZFdpZHRoIHx8IG5ld0hlaWdodCAhPT0gb2xkSGVpZ2h0KSB7XG4gICAgdGhpcy5fcHJvamVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gIH1cbiAgaWYgKG5ld1dpZHRoICE9PSBvbGRXaWR0aCB8fCBuZXdIZWlnaHQgIT09IG9sZEhlaWdodCkge1xuICAgIHRoaXMuZW1pdCgncmVzaXplJyk7XG4gIH1cblxufTtcblxuXG5GbGF0Vmlldy5wcm90b3R5cGUuX3pvb21YID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl96b29tO1xufTtcblxuXG5GbGF0Vmlldy5wcm90b3R5cGUuX3pvb21ZID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtZWRpYUFzcGVjdFJhdGlvID0gdGhpcy5fbWVkaWFBc3BlY3RSYXRpbztcbiAgdmFyIGFzcGVjdCA9IHRoaXMuX3dpZHRoIC8gdGhpcy5faGVpZ2h0O1xuICB2YXIgem9vbVggPSB0aGlzLl96b29tO1xuICB2YXIgem9vbVkgPSB6b29tWCAqIG1lZGlhQXNwZWN0UmF0aW8gLyBhc3BlY3Q7XG4gIGlmIChpc05hTih6b29tWSkpIHtcbiAgICB6b29tWSA9IHpvb21YO1xuICB9XG4gIHJldHVybiB6b29tWTtcbn07XG5cblxuRmxhdFZpZXcucHJvdG90eXBlLnVwZGF0ZVdpdGhDb250cm9sUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgdmFyIHNjYWxlID0gdGhpcy56b29tKCk7XG4gIHZhciB6b29tWCA9IHRoaXMuX3pvb21YKCk7XG4gIHZhciB6b29tWSA9IHRoaXMuX3pvb21ZKCk7XG5cbiAgLy8gVE9ETzogc2hvdWxkIHRoZSBzY2FsZSBiZSB0aGUgc2FtZSBmb3IgYm90aCBheGVzP1xuICB0aGlzLm9mZnNldFgocGFyYW1ldGVycy5heGlzU2NhbGVkWCAqIHpvb21YICsgcGFyYW1ldGVycy54ICogc2NhbGUpO1xuICB0aGlzLm9mZnNldFkocGFyYW1ldGVycy5heGlzU2NhbGVkWSAqIHpvb21ZICsgcGFyYW1ldGVycy55ICogc2NhbGUpO1xuICB0aGlzLm9mZnNldFpvb20ocGFyYW1ldGVycy56b29tICogc2NhbGUpO1xufTtcblxuXG5GbGF0Vmlldy5wcm90b3R5cGUuX3VwZGF0ZVByb2plY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByb2pNYXRyaXggPSB0aGlzLl9wcm9qTWF0cml4O1xuICB2YXIgaW52UHJvak1hdHJpeCA9IHRoaXMuX2ludlByb2pNYXRyaXg7XG4gIHZhciBmcnVzdHVtID0gdGhpcy5fZnJ1c3R1bTtcblxuICAvLyBSZWNhbGN1bGF0ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aGVuIHJlcXVpcmVkLlxuICBpZiAodGhpcy5fcHJvamVjdGlvbkNoYW5nZWQpIHtcbiAgICB2YXIgeCA9IHRoaXMuX3g7XG4gICAgdmFyIHkgPSB0aGlzLl95O1xuICAgIHZhciB6b29tWCA9IHRoaXMuX3pvb21YKCk7XG4gICAgdmFyIHpvb21ZID0gdGhpcy5fem9vbVkoKTtcblxuICAgIC8vIFJlY2FsY3VsYXRlIHZpZXcgZnJ1c3R1bS5cbiAgICB2YXIgdG9wICAgICA9IGZydXN0dW1bMF0gPSAoMC41IC0geSkgKyAwLjUgKiB6b29tWTtcbiAgICB2YXIgcmlnaHQgICA9IGZydXN0dW1bMV0gPSAoeCAtIDAuNSkgKyAwLjUgKiB6b29tWDtcbiAgICB2YXIgYm90dG9tICA9IGZydXN0dW1bMl0gPSAoMC41IC0geSkgLSAwLjUgKiB6b29tWTtcbiAgICB2YXIgbGVmdCAgICA9IGZydXN0dW1bM10gPSAoeCAtIDAuNSkgLSAwLjUgKiB6b29tWDtcblxuICAgIC8vIFJlY2FsY3VsYXRlIHByb2plY3Rpb24gbWF0cml4IGFuZCBpdHMgaW52ZXJzZS5cbiAgICBtYXQ0Lm9ydGhvKHByb2pNYXRyaXgsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgLTEsIDEpO1xuICAgIG1hdDQuaW52ZXJ0KGludlByb2pNYXRyaXgsIHByb2pNYXRyaXgpO1xuXG4gICAgdGhpcy5fcHJvamVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb2plY3Rpb24gbWF0cml4IGZvciB0aGUgY3VycmVudCB2aWV3LlxuICogQHJldHVybnMge21hdDR9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5wcm9qZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3VwZGF0ZVByb2plY3Rpb24oKTtcbiAgcmV0dXJuIHRoaXMuX3Byb2pNYXRyaXg7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBwcm9qZWN0aW9uIG1hdHJpeCBmb3IgdGhlIGN1cnJlbnQgdmlldy5cbiAqIEByZXR1cm5zIHttYXQ0fVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuaW52ZXJzZVByb2plY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdXBkYXRlUHJvamVjdGlvbigpO1xuICByZXR1cm4gdGhpcy5faW52UHJvak1hdHJpeDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciB0aGUgdmlldyBmcnVzdHVtIGludGVyc2VjdHMgdGhlIGdpdmVuIHJlY3RhbmdsZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG1heSByZXR1cm4gZmFsc2UgcG9zaXRpdmVzLCBidXQgbmV2ZXIgZmFsc2UgbmVnYXRpdmVzLlxuICogSXQgaXMgdXNlZCBmb3IgZnJ1c3R1bSBjdWxsaW5nLCBpLmUuLCBleGNsdWRpbmcgaW52aXNpYmxlIHRpbGVzIGZyb20gdGhlXG4gKiByZW5kZXJpbmcgcHJvY2Vzcy5cbiAqXG4gKiBAcGFyYW0ge3ZlYzNbXX0gcmVjdGFuZ2xlIFRoZSB2ZXJ0aWNlcyBvZiB0aGUgcmVjdGFuZ2xlLlxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHJlY3RhbmdsZSkge1xuICB0aGlzLl91cGRhdGVQcm9qZWN0aW9uKCk7XG5cbiAgdmFyIGZydXN0dW0gPSB0aGlzLl9mcnVzdHVtO1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHJlY3RhbmdsZSBpcyBvbiB0aGUgb3V0ZXIgc2lkZSBvZiBhbnkgb2YgdGhlIGZydXN0dW1cbiAgLy8gcGxhbmVzLiBUaGlzIGlzIGEgc3VmZmljaWVudCBjb25kaXRpb24sIHRob3VnaCBub3QgbmVjZXNzYXJ5LCBmb3IgdGhlXG4gIC8vIHJlY3RhbmdsZSB0byBiZSBjb21wbGV0ZWx5IG91dHNpZGUgdGhlIGZydW91dGVyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnJ1c3R1bS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW1pdCA9IGZydXN0dW1baV07XG4gICAgdmFyIGF4aXMgPSBwbGFuZUF4ZXNbaV07XG4gICAgdmFyIGNtcCA9IHBsYW5lQ21wW2ldO1xuICAgIHZhciBpbnNpZGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlY3RhbmdsZS5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHZlcnRleCA9IHJlY3RhbmdsZVtqXTtcbiAgICAgIGlmIChjbXAgPCAwICYmIHZlcnRleFtheGlzXSA8IGxpbWl0IHx8IGNtcCA+IDAgJiYgdmVydGV4W2F4aXNdID4gbGltaXQpIHtcbiAgICAgICAgaW5zaWRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaW5zaWRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIFNlbGVjdCB0aGUgbGV2ZWwgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIHZpZXcuXG4gKiBAcGFyYW0ge0xldmVsW119IGxldmVsTGlzdCB0aGUgbGlzdCBvZiBsZXZlbHMgZnJvbSB3aGljaCB0byBzZWxlY3QuXG4gKiBAcmV0dXJuIHtMZXZlbH0gdGhlIHNlbGVjdGVkIGxldmVsLlxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2VsZWN0TGV2ZWwgPSBmdW5jdGlvbihsZXZlbHMpIHtcblxuICAvLyBNdWx0aXBseSB0aGUgdmlld3BvcnQgd2lkdGggYnkgdGhlIGRldmljZSBwaXhlbCByYXRpbyB0byBnZXQgdGhlIHJlcXVpcmVkXG4gIC8vIGhvcml6b250YWwgcmVzb2x1dGlvbiBpbiBwaXhlbHMuXG4gIC8vXG4gIC8vIENhbGN1bGF0ZSB0aGUgZnJhY3Rpb24gb2YgdGhlIGltYWdlIHRoYXQgd291bGQgYmUgdmlzaWJsZSBhdCB0aGUgY3VycmVudFxuICAvLyB6b29tIHZhbHVlLiBUaGVuLCBmb3IgZWFjaCBsZXZlbCwgbXVsdGlwbHkgYnkgdGhlIGxldmVsIHdpZHRoIHRvIGdldCB0aGVcbiAgLy8gd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBwb3J0aW9uIHRoYXQgd291bGQgYmUgdmlzaWJsZS5cbiAgLy9cbiAgLy8gU2VhcmNoIGZvciB0aGUgc21hbGxlc3QgbGV2ZWwgdGhhdCBzYXRpZmllcyB0aGUgdGhlIHJlcXVpcmVkIHdpZHRoLFxuICAvLyBmYWxsaW5nIGJhY2sgb24gdGhlIGxhcmdlc3QgbGV2ZWwgaWYgbm9uZSBkby5cblxuICB2YXIgcmVxdWlyZWRQaXhlbHMgPSBwaXhlbFJhdGlvKCkgKiB0aGlzLndpZHRoKCk7XG4gIHZhciB6b29tRmFjdG9yID0gdGhpcy5fem9vbTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICBpZiAoem9vbUZhY3RvciAqIGxldmVsLndpZHRoKCkgPj0gcmVxdWlyZWRQaXhlbHMpIHtcbiAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGV2ZWxzW2xldmVscy5sZW5ndGggLSAxXTtcblxufTtcblxuXG4vKipcbiAqIENvbnZlcnQgdmlldyBjb29yZGluYXRlcyBpbnRvIHNjcmVlbiBjb29yZGluYXRlcy4gSWYgYSByZXN1bHQgYXJndW1lbnQgaXNcbiAqIHByb3ZpZGVkLCBpdCBpcyBmaWxsZWQgaW4gYW5kIHJldHVybmVkLiBPdGhlcndpc2UsIGEgZnJlc2ggb2JqZWN0IGlzIGZpbGxlZFxuICogaW4gYW5kIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7RmxhdFZpZXdDb29yZHN9IGNvb3JkcyBUaGUgdmlldyBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7Q29vcmRzPX0gcmVzdWx0IFRoZSByZXN1bHQgYXJndW1lbnQgZm9yIHRoZSBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtDb29yZHN9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5jb29yZGluYXRlc1RvU2NyZWVuID0gZnVuY3Rpb24oY29vcmRzLCByZXN1bHQpIHtcbiAgdmFyIHJheSA9IHRoaXMuX3ZlYztcblxuICBpZiAoIXJlc3VsdCkge1xuICAgIHJlc3VsdCA9IHt9O1xuICB9XG5cbiAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgLy8gVW5kZWZpbmVkIG9uIGEgbnVsbCB2aWV3cG9ydC5cbiAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICByZXN1bHQueCA9IG51bGw7XG4gICAgcmVzdWx0LnkgPSBudWxsO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gRXh0cmFjdCBjb29yZGluYXRlcyBmcm9tIGFyZ3VtZW50LCBmaWxsaW5nIGluIGRlZmF1bHQgdmFsdWVzLlxuICB2YXIgeCA9IGNvb3JkcyAmJiBjb29yZHMueCAhPSBudWxsID8gY29vcmRzLnggOiBkZWZhdWx0WDtcbiAgdmFyIHkgPSBjb29yZHMgJiYgY29vcmRzLnkgIT0gbnVsbCA/IGNvb3Jkcy55IDogZGVmYXVsdFk7XG5cbiAgLy8gUHJvamVjdCB2aWV3IHJheSBvbnRvIGNsaXAgc3BhY2UuXG4gIHZlYzQuc2V0KHJheSwgeCAtIDAuNSwgMC41IC0geSwgLTEsIDEpO1xuICB2ZWM0LnRyYW5zZm9ybU1hdDQocmF5LCByYXksIHRoaXMucHJvamVjdGlvbigpKTtcblxuICAvLyBDYWxjdWxhdGUgcGVyc3BlY3RpdmUgZGl2aWRlLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHJheVtpXSAvPSByYXlbM107XG4gIH1cblxuICAvLyBDb252ZXJ0IHRvIHZpZXdwb3J0IGNvb3JkaW5hdGVzIGFuZCByZXR1cm4uXG4gIHJlc3VsdC54ID0gd2lkdGggKiAocmF5WzBdICsgMSkgLyAyO1xuICByZXN1bHQueSA9IGhlaWdodCAqICgxIC0gcmF5WzFdKSAvIDI7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IHNjcmVlbiBjb29yZGluYXRlcyBpbnRvIHZpZXcgY29vcmRpbmF0ZXMuIElmIGEgcmVzdWx0IGFyZ3VtZW50IGlzXG4gKiBwcm92aWRlZCwgaXQgaXMgZmlsbGVkIGluIHdpdGggdGhlIHJlc3VsdCBhbmQgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBmcmVzaFxuICogb2JqZWN0IGlzIGZpbGxlZCBpbiBhbmQgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtDb29yZHN9IGNvb3JkcyBUaGUgc2NyZWVuIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtGbGF0Vmlld0Nvb3Jkcz19IHJlc3VsdCBUaGUgcmVzdWx0IGFyZ3VtZW50IGZvciB0aGUgdmlldyBjb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0ZsYXRWaWV3Q29vcmRzfVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2NyZWVuVG9Db29yZGluYXRlcyA9IGZ1bmN0aW9uKGNvb3JkcywgcmVzdWx0KSB7XG4gIHZhciByYXkgPSB0aGlzLl92ZWM7XG5cbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSB7fTtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gIC8vIENvbnZlcnQgdmlld3BvcnQgY29vcmRpbmF0ZXMgdG8gY2xpcCBzcGFjZS5cbiAgdmFyIHZlY3ggPSAyICogY29vcmRzLnggLyB3aWR0aCAtIDE7XG4gIHZhciB2ZWN5ID0gMSAtIDIgKiBjb29yZHMueSAvIGhlaWdodDtcbiAgdmVjNC5zZXQocmF5LCB2ZWN4LCB2ZWN5LCAxLCAxKTtcblxuICAvLyBQcm9qZWN0IGJhY2sgdG8gd29ybGQgc3BhY2UuXG4gIHZlYzQudHJhbnNmb3JtTWF0NChyYXksIHJheSwgdGhpcy5pbnZlcnNlUHJvamVjdGlvbigpKTtcblxuICAvLyBDb252ZXJ0IHRvIGZsYXQgY29vcmRpbmF0ZXMuXG4gIHJlc3VsdC54ID0gMC41ICsgcmF5WzBdO1xuICByZXN1bHQueSA9IDAuNSAtIHJheVsxXTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb25zIGZvciB2aWV3IGxpbWl0ZXJzLiBTZWUge0BsaW5rIEZsYXRWaWV3TGltaXRlcn0uXG4gKiBAbmFtZXNwYWNlXG4gKi9cbkZsYXRWaWV3LmxpbWl0ID0ge1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgeCBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0geCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB5IHZhbHVlLlxuICAgKiBAcmV0dXJuIHtGbGF0Vmlld0xpbWl0ZXJ9XG4gICAqL1xuICB4OiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFgocGFyYW1zKSB7XG4gICAgICBwYXJhbXMueCA9IGNsYW1wKHBhcmFtcy54LCBtaW4sIG1heCk7XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIHkgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHkgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0geSB2YWx1ZS5cbiAgICogQHJldHVybiB7RmxhdFZpZXdMaW1pdGVyfVxuICAgKi9cbiAgeTogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRZKHBhcmFtcykge1xuICAgICAgcGFyYW1zLnkgPSBjbGFtcChwYXJhbXMueSwgbWluLCBtYXgpO1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYW4gY29uc3RyYWlucyB0aGUgem9vbSBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gem9vbSB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB6b29tIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtGbGF0Vmlld0xpbWl0ZXJ9XG4gICAqL1xuICB6b29tOiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFpvb20ocGFyYW1zKSB7XG4gICAgICBwYXJhbXMuem9vbSA9IGNsYW1wKHBhcmFtcy56b29tLCBtaW4sIG1heCk7XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2aWV3IGxpbWl0ZXIgdGhhdCBwcmV2ZW50cyB6b29taW5nIGluIGJleW9uZCB0aGUgZ2l2ZW5cbiAgICogcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgVGhlIGltYWdlIHdpZHRoIGluIHBpeGVscy5cbiAgICogQHJldHVybiB7RmxhdFZpZXdMaW1pdGVyfVxuICAgKi9cbiAgcmVzb2x1dGlvbjogZnVuY3Rpb24oc2l6ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFJlc29sdXRpb24ocGFyYW1zKSB7XG4gICAgICBpZiAocGFyYW1zLndpZHRoIDw9IDAgfHwgcGFyYW1zLmhlaWdodCA8PSAwKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICB9XG4gICAgICB2YXIgd2lkdGggPSBwYXJhbXMud2lkdGg7XG4gICAgICB2YXIgbWluWm9vbSA9IHBpeGVsUmF0aW8oKSAqIHdpZHRoIC8gc2l6ZTtcbiAgICAgIHBhcmFtcy56b29tID0gY2xhbXAocGFyYW1zLnpvb20sIG1pblpvb20sIEluZmluaXR5KTtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIHZhbHVlcyBvZiB0aGUgeCBwYXJhbWV0ZXIgdGhhdFxuICAgKiBhcmUgaW5zaWRlIHRoZSB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSB4IHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHggdmFsdWUuXG4gICAqIEByZXR1cm4ge0ZsYXRWaWV3TGltaXRlcn1cbiAgICovXG4gIHZpc2libGVYOiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFZpc2libGVYKHBhcmFtcykge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB6b29tIHZhbHVlIHRoYXQgbWFrZXMgdGhlIHNwZWNpZmllZCByYW5nZSBmdWxseSB2aXNpYmxlLlxuICAgICAgdmFyIG1heFpvb20gPSBtYXggLSBtaW47XG5cbiAgICAgIC8vIENsYW1wIHpvb20gdG8gdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICBpZiAocGFyYW1zLnpvb20gPiBtYXhab29tKSB7XG4gICAgICAgIHBhcmFtcy56b29tID0gbWF4Wm9vbTtcbiAgICAgIH1cblxuICAgICAgLy8gQm91bmQgWCBzdWNoIHRoYXQgdGhlIGltYWdlIGlzIHZpc2libGUgdXAgdG8gdGhlIHJhbmdlIGVkZ2VzLlxuICAgICAgdmFyIG1pblggPSBtaW4gKyAwLjUgKiBwYXJhbXMuem9vbTtcbiAgICAgIHZhciBtYXhYID0gbWF4IC0gMC41ICogcGFyYW1zLnpvb207XG4gICAgICBwYXJhbXMueCA9IGNsYW1wKHBhcmFtcy54LCBtaW5YLCBtYXhYKTtcblxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgdmFsdWVzIG9mIHRoZSB5IHBhcmFtZXRlciB0aGF0XG4gICAqIGFyZSBpbnNpZGUgdGhlIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHkgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0geSB2YWx1ZS5cbiAgICogQHJldHVybiB7RmxhdFZpZXdMaW1pdGVyfVxuICAgKi9cbiAgdmlzaWJsZVk6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0VmlzaWJsZVkocGFyYW1zKSB7XG5cbiAgICAgIC8vIERvIG5vdGhpbmcgZm9yIGEgbnVsbCB2aWV3cG9ydC5cbiAgICAgIGlmIChwYXJhbXMud2lkdGggPD0gMCB8fCBwYXJhbXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBYIHRvIFkgY29udmVyc2lvbiBmYWN0b3IuXG4gICAgICB2YXIgdmlld3BvcnRBc3BlY3RSYXRpbyA9IHBhcmFtcy53aWR0aCAvIHBhcmFtcy5oZWlnaHQ7XG4gICAgICB2YXIgZmFjdG9yID0gdmlld3BvcnRBc3BlY3RSYXRpbyAvIHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIHpvb20gdmFsdWUgdGhhdCBtYWtlcyB0aGUgc3BlY2lmaWVkIHJhbmdlIGZ1bGx5IHZpc2libGUuXG4gICAgICB2YXIgbWF4Wm9vbSA9IChtYXggLSBtaW4pICogZmFjdG9yO1xuXG4gICAgICAvLyBDbGFtcCB6b29tIHRvIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAgaWYgKHBhcmFtcy56b29tID4gbWF4Wm9vbSkge1xuICAgICAgICBwYXJhbXMuem9vbSA9IG1heFpvb207XG4gICAgICB9XG5cbiAgICAgIC8vIEJvdW5kIFkgc3VjaCB0aGF0IHRoZSBpbWFnZSBpcyB2aXNpYmxlIHVwIHRvIHRoZSByYW5nZSBlZGdlcy5cbiAgICAgIHZhciBtaW5ZID0gbWluICsgMC41ICogcGFyYW1zLnpvb20gLyBmYWN0b3I7XG4gICAgICB2YXIgbWF4WSA9IG1heCAtIDAuNSAqIHBhcmFtcy56b29tIC8gZmFjdG9yO1xuICAgICAgcGFyYW1zLnkgPSBjbGFtcChwYXJhbXMueSwgbWluWSwgbWF4WSk7XG5cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgem9vbSBwYXJhbWV0ZXIgc3VjaCB0aGF0XG4gICAqIHpvb21pbmcgb3V0IGlzIHByZXZlbnRlZCBiZXlvbmQgdGhlIHBvaW50IGF0IHdoaWNoIHRoZSBpbWFnZSBpcyBmdWxseVxuICAgKiB2aXNpYmxlLiBVbmxlc3MgdGhlIGltYWdlIGFuZCB0aGUgdmlld3BvcnQgaGF2ZSB0aGUgc2FtZSBhc3BlY3QgcmF0aW8sXG4gICAqIHRoaXMgd2lsbCBjYXVzZSBiYW5kcyB0byBhcHBlYXIgYXJvdW5kIHRoZSBpbWFnZS5cbiAgICogQHJldHVybiB7RmxhdFZpZXdMaW1pdGVyfVxuICAgKi9cbiAgbGV0dGVyYm94OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRMZXR0ZXJib3gocGFyYW1zKSB7XG4gICAgICBpZihwYXJhbXMud2lkdGggPD0gMCB8fCBwYXJhbXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH1cbiAgICAgIHZhciB2aWV3cG9ydEFzcGVjdFJhdGlvID0gcGFyYW1zLndpZHRoIC8gcGFyYW1zLmhlaWdodDtcblxuICAgICAgdmFyIGZ1bGxXaWR0aFpvb20gPSAxLjA7XG4gICAgICB2YXIgZnVsbEhlaWdodFpvb20gPSB2aWV3cG9ydEFzcGVjdFJhdGlvIC8gcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW87XG5cbiAgICAgIC8vIElmIHRoZSBpbWFnZSBpcyB3aWRlciB0aGFuIHRoZSB2aWV3cG9ydCwgbGltaXQgdGhlIGhvcml6b250YWwgem9vbSB0b1xuICAgICAgLy8gdGhlIGltYWdlIHdpZHRoLlxuICAgICAgaWYgKHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvID49IHZpZXdwb3J0QXNwZWN0UmF0aW8pIHtcbiAgICAgICAgcGFyYW1zLnpvb20gPSBNYXRoLm1pbihwYXJhbXMuem9vbSwgZnVsbFdpZHRoWm9vbSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBpbWFnZSBpcyBuYXJyb3dlciB0aGFuIHRoZSB2aWV3cG9ydCwgbGltaXQgdGhlIHZlcnRpY2FsIHpvb20gdG9cbiAgICAgIC8vIHRoZSBpbWFnZSBoZWlnaHQuXG4gICAgICBpZiAocGFyYW1zLm1lZGlhQXNwZWN0UmF0aW8gPD0gdmlld3BvcnRBc3BlY3RSYXRpbykge1xuICAgICAgICBwYXJhbXMuem9vbSA9IE1hdGgubWluKHBhcmFtcy56b29tLCBmdWxsSGVpZ2h0Wm9vbSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBmdWxsIGltYWdlIHdpZHRoIGlzIHZpc2libGUsIGxpbWl0IHggdG8gdGhlIGNlbnRyYWwgcG9pbnQuXG4gICAgICAvLyBFbHNlLCBib3VuZCB4IHN1Y2ggdGhhdCBpbWFnZSBpcyB2aXNpYmxlIHVwIHRvIHRoZSBob3Jpem9udGFsIGVkZ2VzLlxuICAgICAgdmFyIG1pblgsIG1heFg7XG4gICAgICBpZiAocGFyYW1zLnpvb20gPiBmdWxsV2lkdGhab29tKSB7XG4gICAgICAgIG1pblggPSBtYXhYID0gMC41O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluWCA9IDAuMCArIDAuNSAqIHBhcmFtcy56b29tIC8gZnVsbFdpZHRoWm9vbTtcbiAgICAgICAgbWF4WCA9IDEuMCAtIDAuNSAqIHBhcmFtcy56b29tIC8gZnVsbFdpZHRoWm9vbTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGZ1bGwgaW1hZ2UgaGVpZ2h0IGlzIHZpc2libGUsIGxpbWl0IHkgdG8gdGhlIGNlbnRyYWwgcG9pbnQuXG4gICAgICAvLyBFbHNlLCBib3VuZCB5IHN1Y2ggdGhhdCBpbWFnZSBpcyB2aXNpYmxlIHVwIHRvIHRoZSB2ZXJ0aWNhbCBlZGdlcy5cbiAgICAgIHZhciBtaW5ZLCBtYXhZO1xuICAgICAgaWYgKHBhcmFtcy56b29tID4gZnVsbEhlaWdodFpvb20pIHtcbiAgICAgICAgbWluWSA9IG1heFkgPSAwLjU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5ZID0gMC4wICsgMC41ICogcGFyYW1zLnpvb20gLyBmdWxsSGVpZ2h0Wm9vbTtcbiAgICAgICAgbWF4WSA9IDEuMCAtIDAuNSAqIHBhcmFtcy56b29tIC8gZnVsbEhlaWdodFpvb207XG4gICAgICB9XG5cbiAgICAgIC8vIENsYW1wIHggYW5kIHkgaW50byB0aGUgY2FsY3VsYXRlZCBib3VuZHMuXG4gICAgICBwYXJhbXMueCA9IGNsYW1wKHBhcmFtcy54LCBtaW5YLCBtYXhYKTtcbiAgICAgIHBhcmFtcy55ID0gY2xhbXAocGFyYW1zLnksIG1pblksIG1heFkpO1xuXG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH1cblxufTtcblxuXG5GbGF0Vmlldy50eXBlID0gRmxhdFZpZXcucHJvdG90eXBlLnR5cGUgPSAnZmxhdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGbGF0VmlldztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xudmFyIHZlYzQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS52ZWM0O1xudmFyIHBpeGVsUmF0aW8gPSByZXF1aXJlKCcuLi91dGlsL3BpeGVsUmF0aW8nKTtcbnZhciBjb252ZXJ0Rm92ID0gcmVxdWlyZSgnLi4vdXRpbC9jb252ZXJ0Rm92Jyk7XG52YXIgbW9kID0gcmVxdWlyZSgnLi4vdXRpbC9tb2QnKTtcbnZhciByZWFsID0gcmVxdWlyZSgnLi4vdXRpbC9yZWFsJyk7XG52YXIgY2xhbXAgPSByZXF1aXJlKCcuLi91dGlsL2NsYW1wJyk7XG52YXIgZGVjaW1hbCA9IHJlcXVpcmUoJy4uL3V0aWwvZGVjaW1hbCcpO1xudmFyIGNvbXBvc2UgPSByZXF1aXJlKCcuLi91dGlsL2NvbXBvc2UnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vLyBEZWZhdWx0IHZpZXdwb3J0IGRpbWVuc2lvbnMuXG4vLyBTdGFydCB3aXRoIHplcm8gdG8gZW5zdXJlIHRoYXQgdGhvc2UgdmFsdWVzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cbnZhciBkZWZhdWx0V2lkdGggPSAwO1xudmFyIGRlZmF1bHRIZWlnaHQgPSAwO1xuXG4vLyBEZWZhdWx0IHZpZXcgcGFyYW1ldGVycy5cbnZhciBkZWZhdWx0WWF3ID0gMDtcbnZhciBkZWZhdWx0UGl0Y2ggPSAwO1xudmFyIGRlZmF1bHRSb2xsID0gMDtcbnZhciBkZWZhdWx0Rm92ID0gTWF0aC5QSS80O1xudmFyIGRlZmF1bHRQcm9qZWN0aW9uQ2VudGVyWCA9IDA7XG52YXIgZGVmYXVsdFByb2plY3Rpb25DZW50ZXJZID0gMDtcblxuLy8gQSBmb3Ygb2YgZXhhY3RseSAwIG9yIM+AIGJyZWFrcyBzb21lIGNvbXB1dGF0aW9ucywgc28gd2UgY29uc3RyYWluIGl0IHRvIHRoZVxuLy8gW2ZvdkxpbWl0RXBzaWxvbiwgz4AgLSBmb3ZMaW1pdEVwc2lsb25dIGludGVydmFsLiBXZSB1c2UgNiBkZWNpbWFsIHBsYWNlcyBmb3Jcbi8vIHRoZSBlcHNpbG9uIHZhbHVlIHRvIGF2b2lkIGJyb2tlbiByZW5kZXJpbmcgZHVlIHRvIGxvc3Mgb2YgcHJlY2lzaW9uIGluXG4vLyBmbG9hdGluZyBwb2ludCBjb21wdXRhdGlvbnMuXG52YXIgZm92TGltaXRFcHNpbG9uID0gMC4wMDAwMDE7XG5cblxuLyoqXG4gKiBAaW50ZXJmYWNlIFJlY3RpbGluZWFyVmlld1BhcmFtc1xuICpcbiAqIEEgY2FtZXJhIGNvbmZpZ3VyYXRpb24gZm9yIGEge0BsaW5rIFJlY3RpbGluZWFyVmlld30uXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHlhdyBUaGUgeWF3IGFuZ2xlLCBpbiB0aGUgWy3PgCwgz4BdIHJhbmdlLlxuICogICAgIFdoZW4gYHlhdyA8IDBgLCB0aGUgdmlldyByb3RhdGVzIHRvIHRoZSBsZWZ0LlxuICogICAgIFdoZW4gYHlhdyA+IDBgLCB0aGUgdmlldyByb3RhdGVzIHRvIHRoZSByaWdodC5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGl0Y2ggVGhlIHBpdGNoIGFuZ2xlLCBpbiB0aGUgWy3PgCwgz4BdIHJhbmdlLlxuICogICAgIFdoZW4gYHBpdGNoIDwgMGAsIHRoZSB2aWV3IHJvdGF0ZXMgZG93bndhcmRzLlxuICogICAgIFdoZW4gYHBpdGNoID4gMGAsIHRoZSB2aWV3IHJvdGF0ZXMgdXB3YXJkcy5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gcm9sbCBUaGUgcm9sbCBhbmdsZSwgaW4gdGhlIFstz4AsIM+AXSByYW5nZS5cbiAqICAgICBXaGVuIGByb2xsIDwgMGAsIHRoZSB2aWV3IHJvdGF0ZXMgY2xvY2t3aXNlLlxuICogICAgIFdoZW4gYHJvbGwgPiAwYCwgdGhlIHZpZXcgcm90YXRlcyBjb3VudGVyLWNsb2Nrd2lzZS5cbiAqXG4gKiBAcHJvcGVydHkge2Zvdn0gZm92IFRoZSB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3LCBpbiB0aGUgWzAsIM+AXSByYW5nZS5cbiAqL1xuXG5cbi8qKlxuICogQGludGVyZmFjZSBSZWN0aWxpbmVhclZpZXdDb29yZHNcbiAqXG4gKiBUaGUgcG9zaXRpb24gb2YgYSBwb2ludCBpbiBhIDM2MMKwIGltYWdlLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5YXcgVGhlIHlhdyBhbmdsZSwgaW4gdGhlIFstz4AsIM+AXSByYW5nZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaXRjaCBUaGUgcGl0Y2ggYW5nbGUsIGluIHRoZSBbLc+ALCDPgF0gcmFuZ2UuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gUmVjdGlsaW5lYXJWaWV3TGltaXRlclxuICpcbiAqIFZpZXcgbGltaXRlciBmb3IgYSB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3fS5cbiAqXG4gKiBBIHZpZXcgbGltaXRlciBpcyBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3UGFyYW1zfVxuICogb2JqZWN0LCBvcHRpb25hbGx5IG1vZGlmaWVzIGl0IGluIHBsYWNlLCBhbmQgcmV0dXJucyBpdC4gSXQgY2FuIGJlIHVzZWQgdG9cbiAqIGVuZm9yY2UgY29uc3RyYWludHMgb24gdGhlIHZpZXcgcGFyYW1ldGVycy5cbiAqXG4gKiBTZWUge0BsaW5rIFJlY3RpbGluZWFyVmlldy5saW1pdH0gZm9yIGNvbW1vbmx5IHVzZWQgbGltaXRlcnMuIFRoZXkgbWF5IGJlXG4gKiBjb21wb3NlZCB0b2dldGhlciBvciB3aXRoIHVzZXItZGVmaW5lZCBsaW1pdGVycyB3aXRoIHtAbGluayB1dGlsLmNvbXBvc2V9LlxuICpcbiAqIEBwYXJhbSB7UmVjdGlsaW5lYXJWaWV3UGFyYW1zfSBwYXJhbXNcbiAqIEByZXR1cm4ge1JlY3RpbGluZWFyVmlld1BhcmFtc31cbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBSZWN0aWxpbmVhclZpZXdcbiAqIEBpbXBsZW1lbnRzIFZpZXdcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHtAbGluayBWaWV3fSBpbXBsZW1lbnRpbmcgYSByZWN0aWxpbmVhciBwcm9qZWN0aW9uIGZvciAzNjDCsCBpbWFnZXMuXG4gKlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdQYXJhbXM9fSBwYXJhbXMgVGhlIGluaXRpYWwgdmlldyBwYXJhbWV0ZXJzLiBJZlxuICogICAgIHVuc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBge3lhdzogMCwgcGl0Y2g6IDAsIHJvbGw6IDAsIGZvdjogTWF0aC5QSS80IH1gLlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdMaW1pdGVyPX0gbGltaXRlciBUaGUgdmlldyBsaW1pdGVyLiBJZiB1bnNwZWNpZmllZCxcbiAqICAgICBubyB2aWV3IGxpbWl0aW5nIGlzIGFwcGxpZWQuIFNlZSB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3LmxpbWl0fSBmb3JcbiAqICAgICBjb21tb25seSB1c2VkIGxpbWl0ZXJzLlxuICovXG5mdW5jdGlvbiBSZWN0aWxpbmVhclZpZXcocGFyYW1zLCBsaW1pdGVyKSB7XG4gIC8vIFRoZSBpbml0aWFsIHZhbHVlcyBmb3IgdGhlIHZpZXcgcGFyYW1ldGVycy5cbiAgdGhpcy5feWF3ID0gcGFyYW1zICYmIHBhcmFtcy55YXcgIT0gbnVsbCA/IHBhcmFtcy55YXcgOiBkZWZhdWx0WWF3O1xuICB0aGlzLl9waXRjaCA9IHBhcmFtcyAmJiBwYXJhbXMucGl0Y2ggIT0gbnVsbCA/IHBhcmFtcy5waXRjaCA6IGRlZmF1bHRQaXRjaDtcbiAgdGhpcy5fcm9sbCA9IHBhcmFtcyAmJiBwYXJhbXMucm9sbCAhPSBudWxsID8gcGFyYW1zLnJvbGwgOiBkZWZhdWx0Um9sbDtcbiAgdGhpcy5fZm92ID0gcGFyYW1zICYmIHBhcmFtcy5mb3YgIT0gbnVsbCA/IHBhcmFtcy5mb3YgOiBkZWZhdWx0Rm92O1xuICB0aGlzLl93aWR0aCA9IHBhcmFtcyAmJiBwYXJhbXMud2lkdGggIT0gbnVsbCA/XG4gICAgcGFyYW1zLndpZHRoIDogZGVmYXVsdFdpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBwYXJhbXMgJiYgcGFyYW1zLmhlaWdodCAhPSBudWxsID9cbiAgICBwYXJhbXMuaGVpZ2h0IDogZGVmYXVsdEhlaWdodDtcbiAgdGhpcy5fcHJvamVjdGlvbkNlbnRlclggPSBwYXJhbXMgJiYgcGFyYW1zLnByb2plY3Rpb25DZW50ZXJYICE9IG51bGwgP1xuICAgIHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWCA6IGRlZmF1bHRQcm9qZWN0aW9uQ2VudGVyWDtcbiAgdGhpcy5fcHJvamVjdGlvbkNlbnRlclkgPSBwYXJhbXMgJiYgcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZICE9IG51bGwgP1xuICAgIHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWSA6IGRlZmF1bHRQcm9qZWN0aW9uQ2VudGVyWTtcblxuICAvLyBUaGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhlIHZpZXcgbGltaXRlci5cbiAgdGhpcy5fbGltaXRlciA9IGxpbWl0ZXIgfHwgbnVsbDtcblxuICAvLyBUaGUgbGFzdCBjYWxjdWxhdGVkIHByb2plY3Rpb24gbWF0cml4IGFuZCBpdHMgaW52ZXJzZS5cbiAgdGhpcy5fcHJvak1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gIHRoaXMuX2ludlByb2pNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gIC8vIFRoZSBsYXN0IGNhbGN1bGF0ZWQgdmlldyBmcnVzdHVtLlxuICB0aGlzLl9mcnVzdHVtID0gW1xuICAgIHZlYzQuY3JlYXRlKCksIC8vIGxlZnRcbiAgICB2ZWM0LmNyZWF0ZSgpLCAvLyByaWdodFxuICAgIHZlYzQuY3JlYXRlKCksIC8vIGJvdHRvbVxuICAgIHZlYzQuY3JlYXRlKCksIC8vIHRvcFxuICAgIHZlYzQuY3JlYXRlKCkgIC8vIGNhbWVyYVxuICBdO1xuXG4gIC8vIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gbWF0cmljZXMgYW5kIHRoZSB2aWV3IGZydXN0dW0gbmVlZCB0byBiZSB1cGRhdGVkLlxuICB0aGlzLl9wcm9qZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG5cbiAgLy8gVGVtcG9yYXJ5IHZhcmlhYmxlcyB1c2VkIGZvciBjYWxjdWxhdGlvbnMuXG4gIHRoaXMuX3BhcmFtcyA9IHt9O1xuICB0aGlzLl9mb3ZzID0ge307XG4gIHRoaXMuX3RtcFZlYyA9IHZlYzQuY3JlYXRlKCk7XG5cbiAgLy8gRm9yY2UgdmlldyBsaW1pdGluZyBvbiBpbml0aWFsIHBhcmFtZXRlcnMuXG4gIHRoaXMuX3VwZGF0ZSgpO1xufVxuXG5ldmVudEVtaXR0ZXIoUmVjdGlsaW5lYXJWaWV3KTtcblxuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB5YXcgYW5nbGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUueWF3ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl95YXc7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBwaXRjaCBhbmdsZS5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5waXRjaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcGl0Y2g7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSByb2xsIGFuZ2xlLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnJvbGwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3JvbGw7XG59O1xuXG5cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUucHJvamVjdGlvbkNlbnRlclggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Byb2plY3Rpb25DZW50ZXJYO1xufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnByb2plY3Rpb25DZW50ZXJZID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9wcm9qZWN0aW9uQ2VudGVyWTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGZvdiB2YWx1ZS5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5mb3YgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Zvdjtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb3J0IHdpZHRoLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb3J0IGhlaWdodC5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb3J0IGRpbWVuc2lvbnMuIElmIGFuIGFyZ3VtZW50IGlzIHN1cHBsaWVkLCBpdCBpcyBmaWxsZWQgaW4gd2l0aFxuICogdGhlIHJlc3VsdCBhbmQgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBmcmVzaCBvYmplY3QgaXMgZmlsbGVkIGluIGFuZCByZXR1cm5lZC5cbiAqIEBwYXJhbSB7U2l6ZT19IHNpemVcbiAqIEByZXR1cm4ge1NpemV9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgc2l6ZSA9IHNpemUgfHwge307XG4gIHNpemUud2lkdGggPSB0aGlzLl93aWR0aDtcbiAgc2l6ZS5oZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gIHJldHVybiBzaXplO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdmlldyBwYXJhbWV0ZXJzLiBJZiBhbiBhcmd1bWVudCBpcyBzdXBwbGllZCwgaXQgaXMgZmlsbGVkIGluIHdpdGggdGhlXG4gKiByZXN1bHQgYW5kIHJldHVybmVkLiBPdGhlcndpc2UsIGEgZnJlc2ggb2JqZWN0IGlzIGZpbGxlZCBpbiBhbmQgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1JlY3RpbGluZWFyVmlld1BhcmFtcz19IG9ialxuICogQHJldHVybiB7UmVjdGlsaW5lYXJWaWV3UGFyYW1zfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBwYXJhbXMueWF3ID0gdGhpcy5feWF3O1xuICBwYXJhbXMucGl0Y2ggPSB0aGlzLl9waXRjaDtcbiAgcGFyYW1zLnJvbGwgPSB0aGlzLl9yb2xsO1xuICBwYXJhbXMuZm92ID0gdGhpcy5fZm92O1xuICByZXR1cm4gcGFyYW1zO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdmlldyBsaW1pdGVyLCBvciBudWxsIGlmIHVuc2V0LlxuICogQHJldHVybiB7P1JlY3RpbGluZWFyVmlld0xpbWl0ZXJ9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUubGltaXRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGltaXRlcjtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHlhdyBhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5YXdcbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zZXRZYXcgPSBmdW5jdGlvbih5YXcpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnlhdyA9IHlhdztcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBwaXRjaCBhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXRjaFxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNldFBpdGNoID0gZnVuY3Rpb24ocGl0Y2gpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnBpdGNoID0gcGl0Y2g7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgcm9sbCBhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb2xsXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0Um9sbCA9IGZ1bmN0aW9uKHJvbGwpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnJvbGwgPSByb2xsO1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIGZvdiB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3ZcbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zZXRGb3YgPSBmdW5jdGlvbihmb3YpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLmZvdiA9IGZvdjtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0UHJvamVjdGlvbkNlbnRlclggPSBmdW5jdGlvbihwcm9qZWN0aW9uQ2VudGVyWCkge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMucHJvamVjdGlvbkNlbnRlclggPSBwcm9qZWN0aW9uQ2VudGVyWDtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0UHJvamVjdGlvbkNlbnRlclkgPSBmdW5jdGlvbihwcm9qZWN0aW9uQ2VudGVyWSkge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMucHJvamVjdGlvbkNlbnRlclkgPSBwcm9qZWN0aW9uQ2VudGVyWTtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cbi8qKlxuICogQWRkIHlhd09mZnNldCB0byB0aGUgY3VycmVudCB5YXcgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0geWF3T2Zmc2V0XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUub2Zmc2V0WWF3ID0gZnVuY3Rpb24oeWF3T2Zmc2V0KSB7XG4gIHRoaXMuc2V0WWF3KHRoaXMuX3lhdyArIHlhd09mZnNldCk7XG59O1xuXG5cbi8qKlxuICogQWRkIHBpdGNoT2Zmc2V0IHRvIHRoZSBjdXJyZW50IHBpdGNoIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpdGNoT2Zmc2V0XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUub2Zmc2V0UGl0Y2ggPSBmdW5jdGlvbihwaXRjaE9mZnNldCkge1xuICB0aGlzLnNldFBpdGNoKHRoaXMuX3BpdGNoICsgcGl0Y2hPZmZzZXQpO1xufTtcblxuXG4vKipcbiAqIEFkZCByb2xsT2Zmc2V0IHRvIHRoZSBjdXJyZW50IHJvbGwgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gcm9sbE9mZnNldFxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLm9mZnNldFJvbGwgPSBmdW5jdGlvbihyb2xsT2Zmc2V0KSB7XG4gIHRoaXMuc2V0Um9sbCh0aGlzLl9yb2xsICsgcm9sbE9mZnNldCk7XG59O1xuXG5cbi8qKlxuICogQWRkIGZvdk9mZnNldCB0byB0aGUgY3VycmVudCBmb3YgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gZm92T2Zmc2V0XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUub2Zmc2V0Rm92ID0gZnVuY3Rpb24oZm92T2Zmc2V0KSB7XG4gIHRoaXMuc2V0Rm92KHRoaXMuX2ZvdiArIGZvdk9mZnNldCk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSB2aWV3cG9ydCBkaW1lbnNpb25zLlxuICogQHBhcmFtIHtTaXplfSBzaXplXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgdGhpcy5fcGFyYW1zLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHZpZXcgcGFyYW1ldGVycy4gVW5zcGVjaWZpZWQgcGFyYW1ldGVycyBhcmUgbGVmdCB1bmNoYW5nZWQuXG4gKiBAcGFyYW0ge1JlY3RpbGluZWFyVmlld1BhcmFtZXRlcnN9IHBhcmFtc1xuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNldFBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnlhdyA9IHBhcmFtcy55YXc7XG4gIHRoaXMuX3BhcmFtcy5waXRjaCA9IHBhcmFtcy5waXRjaDtcbiAgdGhpcy5fcGFyYW1zLnJvbGwgPSBwYXJhbXMucm9sbDtcbiAgdGhpcy5fcGFyYW1zLmZvdiA9IHBhcmFtcy5mb3Y7XG4gIHRoaXMuX3BhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWCA9IHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWDtcbiAgdGhpcy5fcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZID0gcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZO1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHZpZXcgbGltaXRlci5cbiAqIEBwYXJhbSB7P1JlY3RpbGluZWFyVmlld0xpbWl0ZXJ9IGxpbWl0ZXIgVGhlIG5ldyBsaW1pdGVyLCBvciBudWxsIHRvIHVuc2V0LlxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNldExpbWl0ZXIgPSBmdW5jdGlvbihsaW1pdGVyKSB7XG4gIHRoaXMuX2xpbWl0ZXIgPSBsaW1pdGVyIHx8IG51bGw7XG4gIHRoaXMuX3VwZGF0ZSgpO1xufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLl9yZXNldFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyYW1zID0gdGhpcy5fcGFyYW1zO1xuICBwYXJhbXMueWF3ID0gbnVsbDtcbiAgcGFyYW1zLnBpdGNoID0gbnVsbDtcbiAgcGFyYW1zLnJvbGwgPSBudWxsO1xuICBwYXJhbXMuZm92ID0gbnVsbDtcbiAgcGFyYW1zLndpZHRoID0gbnVsbDtcbiAgcGFyYW1zLmhlaWdodCA9IG51bGw7XG59O1xuXG5cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXG4gIC8vIEF2b2lkIG9iamVjdCBhbGxvY2F0aW9uIHdoZW4gbm8gcGFyYW1ldGVycyBhcmUgc3VwcGxpZWQuXG4gIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gICAgcGFyYW1zID0gdGhpcy5fcGFyYW1zO1xuICB9XG5cbiAgLy8gU2F2ZSBvbGQgcGFyYW1ldGVycyBmb3IgbGF0ZXIgY29tcGFyaXNvbi5cbiAgdmFyIG9sZFlhdyA9IHRoaXMuX3lhdztcbiAgdmFyIG9sZFBpdGNoID0gdGhpcy5fcGl0Y2g7XG4gIHZhciBvbGRSb2xsID0gdGhpcy5fcm9sbDtcbiAgdmFyIG9sZEZvdiA9IHRoaXMuX2ZvdjtcbiAgdmFyIG9sZFByb2plY3Rpb25DZW50ZXJYID0gdGhpcy5fcHJvamVjdGlvbkNlbnRlclg7XG4gIHZhciBvbGRQcm9qZWN0aW9uQ2VudGVyWSA9IHRoaXMuX3Byb2plY3Rpb25DZW50ZXJZO1xuICB2YXIgb2xkV2lkdGggPSB0aGlzLl93aWR0aDtcbiAgdmFyIG9sZEhlaWdodCA9IHRoaXMuX2hlaWdodDtcblxuICAvLyBGaWxsIGluIG9iamVjdCB3aXRoIHRoZSBuZXcgc2V0IG9mIHBhcmFtZXRlcnMgdG8gcGFzcyBpbnRvIHRoZSBsaW1pdGVyLlxuICBwYXJhbXMueWF3ID0gcGFyYW1zLnlhdyAhPSBudWxsID8gcGFyYW1zLnlhdyA6IG9sZFlhdztcbiAgcGFyYW1zLnBpdGNoID0gcGFyYW1zLnBpdGNoICE9IG51bGwgPyBwYXJhbXMucGl0Y2ggOiBvbGRQaXRjaDtcbiAgcGFyYW1zLnJvbGwgPSBwYXJhbXMucm9sbCAhPSBudWxsID8gcGFyYW1zLnJvbGwgOiBvbGRSb2xsO1xuICBwYXJhbXMuZm92ID0gcGFyYW1zLmZvdiAhPSBudWxsID8gcGFyYW1zLmZvdiA6IG9sZEZvdjtcbiAgcGFyYW1zLndpZHRoID0gcGFyYW1zLndpZHRoICE9IG51bGwgPyBwYXJhbXMud2lkdGggOiBvbGRXaWR0aDtcbiAgcGFyYW1zLmhlaWdodCA9IHBhcmFtcy5oZWlnaHQgIT0gbnVsbCA/IHBhcmFtcy5oZWlnaHQgOiBvbGRIZWlnaHQ7XG4gIHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWCA9IHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWCAhPSBudWxsID9cbiAgICBwYXJhbXMucHJvamVjdGlvbkNlbnRlclggOiBvbGRQcm9qZWN0aW9uQ2VudGVyWDtcbiAgcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZID0gcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZICE9IG51bGwgP1xuICAgIHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWSA6IG9sZFByb2plY3Rpb25DZW50ZXJZO1xuXG4gIC8vIEFwcGx5IHZpZXcgbGltaXRpbmcgd2hlbiBkZWZpbmVkLlxuICBpZiAodGhpcy5fbGltaXRlcikge1xuICAgIHBhcmFtcyA9IHRoaXMuX2xpbWl0ZXIocGFyYW1zKTtcbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgdmlldyBsaW1pdGVyJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHBhcmFtZXRlcnMuXG4gIHBhcmFtcyA9IHRoaXMuX25vcm1hbGl6ZShwYXJhbXMpO1xuXG4gIC8vIEdyYWIgdGhlIGxpbWl0ZWQgcGFyYW1ldGVycy5cbiAgdmFyIG5ld1lhdyA9IHBhcmFtcy55YXc7XG4gIHZhciBuZXdQaXRjaCA9IHBhcmFtcy5waXRjaDtcbiAgdmFyIG5ld1JvbGwgPSBwYXJhbXMucm9sbDtcbiAgdmFyIG5ld0ZvdiA9IHBhcmFtcy5mb3Y7XG4gIHZhciBuZXdXaWR0aCA9IHBhcmFtcy53aWR0aDtcbiAgdmFyIG5ld0hlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG4gIHZhciBuZXdQcm9qZWN0aW9uQ2VudGVyWCA9IHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWDtcbiAgdmFyIG5ld1Byb2plY3Rpb25DZW50ZXJZID0gcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZO1xuXG4gIC8vIENvbnNpc3RlbmN5IGNoZWNrLlxuICBpZiAoIXJlYWwobmV3WWF3KSB8fCAhcmVhbChuZXdQaXRjaCkgfHwgIXJlYWwobmV3Um9sbCkgfHxcbiAgICAgICFyZWFsKG5ld0ZvdikgfHwgIXJlYWwobmV3V2lkdGgpIHx8ICFyZWFsKG5ld0hlaWdodCkgfHxcbiAgICAgICFyZWFsKG5ld1Byb2plY3Rpb25DZW50ZXJYKSB8fCAhcmVhbChuZXdQcm9qZWN0aW9uQ2VudGVyWSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCB2aWV3IC0gc3VzcGVjdCBhIGJyb2tlbiBsaW1pdGVyJyk7XG4gIH1cblxuICAvLyBVcGRhdGUgcGFyYW1ldGVycy5cbiAgdGhpcy5feWF3ID0gbmV3WWF3O1xuICB0aGlzLl9waXRjaCA9IG5ld1BpdGNoO1xuICB0aGlzLl9yb2xsID0gbmV3Um9sbDtcbiAgdGhpcy5fZm92ID0gbmV3Rm92O1xuICB0aGlzLl93aWR0aCA9IG5ld1dpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gIHRoaXMuX3Byb2plY3Rpb25DZW50ZXJYID0gbmV3UHJvamVjdGlvbkNlbnRlclg7XG4gIHRoaXMuX3Byb2plY3Rpb25DZW50ZXJZID0gbmV3UHJvamVjdGlvbkNlbnRlclk7XG5cbiAgLy8gQ2hlY2sgd2hldGhlciB0aGUgcGFyYW1ldGVycyBjaGFuZ2VkIGFuZCBlbWl0IHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50cy5cbiAgaWYgKG5ld1lhdyAhPT0gb2xkWWF3IHx8IG5ld1BpdGNoICE9PSBvbGRQaXRjaCB8fCBuZXdSb2xsICE9PSBvbGRSb2xsIHx8XG4gICAgICBuZXdGb3YgIT09IG9sZEZvdiB8fCBuZXdXaWR0aCAhPT0gb2xkV2lkdGggfHwgbmV3SGVpZ2h0ICE9PSBvbGRIZWlnaHQgfHxcbiAgICAgIG5ld1Byb2plY3Rpb25DZW50ZXJYICE9PSBvbGRQcm9qZWN0aW9uQ2VudGVyWCB8fFxuICAgICAgbmV3UHJvamVjdGlvbkNlbnRlclkgIT09IG9sZFByb2plY3Rpb25DZW50ZXJZKSB7XG4gICAgdGhpcy5fcHJvamVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gIH1cbiAgaWYgKG5ld1dpZHRoICE9PSBvbGRXaWR0aCB8fCBuZXdIZWlnaHQgIT09IG9sZEhlaWdodCkge1xuICAgIHRoaXMuZW1pdCgncmVzaXplJyk7XG4gIH1cblxufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLl9ub3JtYWxpemUgPSBmdW5jdGlvbihwYXJhbXMpIHtcblxuICB0aGlzLl9ub3JtYWxpemVDb29yZGluYXRlcyhwYXJhbXMpO1xuXG4gIC8vIE1ha2Ugc3VyZSB0aGF0IG5laXRoZXIgdGhlIGhvcml6b250YWwgbm9yIHRoZSB2ZXJ0aWNhbCBmaWVsZHMgb2Ygdmlld1xuICAvLyBleGNlZWQgz4AgLSBmb3ZMaW1pdEVwc2lsb24uXG4gIHZhciBoZm92UGkgPSBjb252ZXJ0Rm92Lmh0b3YoTWF0aC5QSSwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgdmFyIG1heEZvdiA9IGlzTmFOKGhmb3ZQaSkgPyBNYXRoLlBJIDogTWF0aC5taW4oTWF0aC5QSSwgaGZvdlBpKTtcbiAgcGFyYW1zLmZvdiA9IGNsYW1wKHBhcmFtcy5mb3YsIGZvdkxpbWl0RXBzaWxvbiwgbWF4Rm92IC0gZm92TGltaXRFcHNpbG9uKTtcblxuICByZXR1cm4gcGFyYW1zO1xufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLl9ub3JtYWxpemVDb29yZGluYXRlcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAvLyBDb25zdHJhaW4geWF3LCBwaXRjaCBhbmQgcm9sbCB0byB0aGUgWy3PgCwgz4BdIGludGVydmFsLlxuICBpZiAoJ3lhdycgaW4gcGFyYW1zKSB7XG4gICAgcGFyYW1zLnlhdyA9IG1vZChwYXJhbXMueWF3IC0gTWF0aC5QSSwgLTIqTWF0aC5QSSkgKyBNYXRoLlBJO1xuICB9XG4gIGlmICgncGl0Y2gnIGluIHBhcmFtcykge1xuICAgIHBhcmFtcy5waXRjaCA9IG1vZChwYXJhbXMucGl0Y2ggLSBNYXRoLlBJLCAtMipNYXRoLlBJKSArIE1hdGguUEk7XG4gIH1cbiAgaWYgKCdyb2xsJyBpbiBwYXJhbXMpIHtcbiAgICBwYXJhbXMucm9sbCA9IG1vZChwYXJhbXMucm9sbCAtIE1hdGguUEksIC0yKk1hdGguUEkpICsgTWF0aC5QSTtcbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufTtcblxuXG4vKipcbiAqIE5vcm1hbGl6ZSB2aWV3IGNvb3JkaW5hdGVzIHNvIHRoYXQgdGhleSBhcmUgdGhlIGNsb3Nlc3QgdG8gdGhlIGN1cnJlbnQgdmlldy5cbiAqIFVzZWZ1bCBmb3IgdHdlZW5pbmcgdGhlIHZpZXcgdGhyb3VnaCB0aGUgc2hvcnRlc3QgcGF0aC4gSWYgYSByZXN1bHQgYXJndW1lbnRcbiAqIGlzIHN1cHBsaWVkLCBpdCBpcyBmaWxsZWQgaW4gd2l0aCB0aGUgcmVzdWx0IGFuZCByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIGZyZXNoXG4gKiBvYmplY3QgaXMgZmlsbGVkIGluIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge1JlY3RpbGluZWFyVmlld0Nvb3Jkc30gY29vcmRzIFRoZSB2aWV3IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdDb29yZHN9IHJlc3VsdCBUaGUgcmVzdWx0IGFyZ3VtZW50IGZvciB0aGUgbm9ybWFsaXplZFxuICogICAgIHZpZXcgY29vcmRpbmF0ZXMuXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUubm9ybWFsaXplVG9DbG9zZXN0ID0gZnVuY3Rpb24oY29vcmRzLCByZXN1bHQpIHtcblxuICB2YXIgdmlld1lhdyA9IHRoaXMuX3lhdztcbiAgdmFyIHZpZXdQaXRjaCA9IHRoaXMuX3BpdGNoO1xuXG4gIHZhciBjb29yZFlhdyA9IGNvb3Jkcy55YXc7XG4gIHZhciBjb29yZFBpdGNoID0gY29vcmRzLnBpdGNoO1xuXG4gIC8vIENoZWNrIGlmIHRoZSB5YXcgaXMgY2xvc2VyIGFmdGVyIHN1YnRyYWN0aW5nIG9yIGFkZGluZyBhIGZ1bGwgY2lyY2xlLlxuICB2YXIgcHJldllhdyA9IGNvb3JkWWF3IC0gMipNYXRoLlBJO1xuICB2YXIgbmV4dFlhdyA9IGNvb3JkWWF3ICsgMipNYXRoLlBJO1xuICBpZiAoTWF0aC5hYnMocHJldllhdyAtIHZpZXdZYXcpIDwgTWF0aC5hYnMoY29vcmRZYXcgLSB2aWV3WWF3KSkge1xuICAgIGNvb3JkWWF3ID0gcHJldllhdztcbiAgfVxuICBlbHNlIGlmIChNYXRoLmFicyhuZXh0WWF3IC0gdmlld1lhdykgPCBNYXRoLmFicyhjb29yZFlhdyAtIHZpZXdZYXcpKSB7XG4gICAgY29vcmRZYXcgPSBuZXh0WWF3O1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIHBpdGNoIGlzIGNsb3NlciBhZnRlciBzdWJ0cmFjdGluZyBvciBhZGRpbmcgYSBmdWxsIGNpcmNsZS5cbiAgdmFyIHByZXZQaXRjaCA9IGNvb3JkUGl0Y2ggLSAyKk1hdGguUEk7XG4gIHZhciBuZXh0UGl0Y2ggPSBjb29yZFBpdGNoICsgMipNYXRoLlBJO1xuICBpZiAoTWF0aC5hYnMocHJldlBpdGNoIC0gdmlld1BpdGNoKSA8IE1hdGguYWJzKGNvb3JkUGl0Y2ggLSB2aWV3UGl0Y2gpKSB7XG4gICAgY29vcmRQaXRjaCA9IHByZXZQaXRjaDtcbiAgfVxuICBlbHNlIGlmIChNYXRoLmFicyhwcmV2UGl0Y2ggLSB2aWV3UGl0Y2gpIDwgTWF0aC5hYnMoY29vcmRQaXRjaCAtIHZpZXdQaXRjaCkpIHtcbiAgICBjb29yZFBpdGNoID0gbmV4dFBpdGNoO1xuICB9XG5cbiAgcmVzdWx0ID0gcmVzdWx0IHx8IHt9O1xuICByZXN1bHQueWF3ID0gY29vcmRZYXc7XG4gIHJlc3VsdC5waXRjaCA9IGNvb3JkUGl0Y2g7XG4gIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblxuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS51cGRhdGVXaXRoQ29udHJvbFBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XG4gIC8vIGF4aXNTY2FsZWRYIGFuZCBheGlzU2NhbGVkWSBhcmUgc2NhbGVkIGFjY29yZGluZyB0byB0aGVpciBvd24gYXhpc1xuICAvLyB4IGFuZCB5IGFyZSBzY2FsZWQgYnkgdGhlIHNhbWUgdmFsdWVcblxuICAvLyBJZiB0aGUgdmlld3BvcnQgZGltZW5zaW9ucyBhcmUgemVybywgYXNzdW1lIGEgc3F1YXJlIHZpZXdwb3J0XG4gIC8vIHdoZW4gY29udmVydGluZyBmcm9tIGhmb3YgdG8gdmZvdi5cbiAgdmFyIHZmb3YgPSB0aGlzLl9mb3Y7XG4gIHZhciBoZm92ID0gY29udmVydEZvdi52dG9oKHZmb3YsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICBpZiAoaXNOYU4oaGZvdikpIHtcbiAgICBoZm92ID0gdmZvdjtcbiAgfVxuXG4gIC8vIFRPRE86IHJldmlzaXQgdGhpcyBhZnRlciB3ZSByZXRoaW5rIHRoZSBjb250cm9sIHBhcmFtZXRlcnMuXG4gIHRoaXMub2Zmc2V0WWF3KHBhcmFtZXRlcnMuYXhpc1NjYWxlZFggKiBoZm92ICsgcGFyYW1ldGVycy54ICogMiAqIGhmb3YgKyBwYXJhbWV0ZXJzLnlhdyk7XG4gIHRoaXMub2Zmc2V0UGl0Y2gocGFyYW1ldGVycy5heGlzU2NhbGVkWSAqIHZmb3YgKyBwYXJhbWV0ZXJzLnkgKiAyICogaGZvdiArIHBhcmFtZXRlcnMucGl0Y2gpO1xuICB0aGlzLm9mZnNldFJvbGwoLXBhcmFtZXRlcnMucm9sbCk7XG4gIHRoaXMub2Zmc2V0Rm92KHBhcmFtZXRlcnMuem9vbSAqIHZmb3YpO1xufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLl91cGRhdGVQcm9qZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwcm9qTWF0cml4ID0gdGhpcy5fcHJvak1hdHJpeDtcbiAgdmFyIGludlByb2pNYXRyaXggPSB0aGlzLl9pbnZQcm9qTWF0cml4O1xuICB2YXIgZnJ1c3R1bSA9IHRoaXMuX2ZydXN0dW07XG5cbiAgaWYgKHRoaXMuX3Byb2plY3Rpb25DaGFuZ2VkKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcblxuICAgIHZhciB2Zm92ID0gdGhpcy5fZm92O1xuICAgIHZhciBoZm92ID0gY29udmVydEZvdi52dG9oKHZmb3YsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciBhc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcblxuICAgIHZhciBwcm9qZWN0aW9uQ2VudGVyWCA9IHRoaXMuX3Byb2plY3Rpb25DZW50ZXJYO1xuICAgIHZhciBwcm9qZWN0aW9uQ2VudGVyWSA9IHRoaXMuX3Byb2plY3Rpb25DZW50ZXJZO1xuXG4gICAgaWYgKHByb2plY3Rpb25DZW50ZXJYICE9PSAwIHx8IHByb2plY3Rpb25DZW50ZXJZICE9PSAwKSB7XG4gICAgICB2YXIgb2Zmc2V0QW5nbGVYID0gTWF0aC5hdGFuKHByb2plY3Rpb25DZW50ZXJYICogMiAqIE1hdGgudGFuKGhmb3YvMikpO1xuICAgICAgdmFyIG9mZnNldEFuZ2xlWSA9IE1hdGguYXRhbihwcm9qZWN0aW9uQ2VudGVyWSAqIDIgKiBNYXRoLnRhbih2Zm92LzIpKTtcbiAgICAgIHZhciBmb3ZzID0gdGhpcy5fZm92cztcbiAgICAgIGZvdnMubGVmdERlZ3JlZXMgPSAoaGZvdi8yICsgb2Zmc2V0QW5nbGVYKSAqIDE4MC9NYXRoLlBJO1xuICAgICAgZm92cy5yaWdodERlZ3JlZXMgPSAoaGZvdi8yIC0gb2Zmc2V0QW5nbGVYKSAqIDE4MC9NYXRoLlBJO1xuICAgICAgZm92cy51cERlZ3JlZXMgPSAodmZvdi8yICsgb2Zmc2V0QW5nbGVZKSAqIDE4MC9NYXRoLlBJO1xuICAgICAgZm92cy5kb3duRGVncmVlcyA9ICh2Zm92LzIgLSBvZmZzZXRBbmdsZVkpICogMTgwL01hdGguUEk7XG4gICAgICBtYXQ0LnBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KHByb2pNYXRyaXgsIGZvdnMsIC0xLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0NC5wZXJzcGVjdGl2ZShwcm9qTWF0cml4LCB2Zm92LCBhc3BlY3QsIC0xLCAxKTtcbiAgICB9XG5cbiAgICBtYXQ0LnJvdGF0ZVoocHJvak1hdHJpeCwgcHJvak1hdHJpeCwgdGhpcy5fcm9sbCk7XG4gICAgbWF0NC5yb3RhdGVYKHByb2pNYXRyaXgsIHByb2pNYXRyaXgsIHRoaXMuX3BpdGNoKTtcbiAgICBtYXQ0LnJvdGF0ZVkocHJvak1hdHJpeCwgcHJvak1hdHJpeCwgdGhpcy5feWF3KTtcblxuICAgIG1hdDQuaW52ZXJ0KGludlByb2pNYXRyaXgsIHByb2pNYXRyaXgpO1xuXG4gICAgdGhpcy5fbWF0cml4VG9GcnVzdHVtKHByb2pNYXRyaXgsIGZydXN0dW0pO1xuXG4gICAgdGhpcy5fcHJvamVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLl9tYXRyaXhUb0ZydXN0dW0gPSBmdW5jdGlvbihwLCBmKSB7XG4gIC8vIEV4dHJhY3QgZnJ1c3R1bSBwbGFuZXMgZnJvbSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAgLy8gaHR0cDovL3d3dzguY3MudW11LnNlL2t1cnNlci81RFYwNTEvSFQxMi9sYWIvcGxhbmVfZXh0cmFjdGlvbi5wZGZcbiAgdmVjNC5zZXQoZlswXSwgcFszXSArIHBbMF0sIHBbN10gKyBwWzRdLCBwWzExXSArIHBbOF0sICAwKTsgLy8gbGVmdFxuICB2ZWM0LnNldChmWzFdLCBwWzNdIC0gcFswXSwgcFs3XSAtIHBbNF0sIHBbMTFdIC0gcFs4XSwgIDApOyAvLyByaWdodFxuICB2ZWM0LnNldChmWzJdLCBwWzNdICsgcFsxXSwgcFs3XSArIHBbNV0sIHBbMTFdICsgcFs5XSwgIDApOyAvLyB0b3BcbiAgdmVjNC5zZXQoZlszXSwgcFszXSAtIHBbMV0sIHBbN10gLSBwWzVdLCBwWzExXSAtIHBbOV0sICAwKTsgLy8gYm90dG9tXG4gIHZlYzQuc2V0KGZbNF0sIHBbM10gKyBwWzJdLCBwWzddICsgcFs2XSwgcFsxMV0gKyBwWzEwXSwgMCk7IC8vIGNhbWVyYVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb2plY3Rpb24gbWF0cml4IGZvciB0aGUgY3VycmVudCB2aWV3LlxuICogQHJldHVybnMge21hdDR9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUucHJvamVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl91cGRhdGVQcm9qZWN0aW9uKCk7XG4gIHJldHVybiB0aGlzLl9wcm9qTWF0cml4O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2UgcHJvamVjdGlvbiBtYXRyaXggZm9yIHRoZSBjdXJyZW50IHZpZXcuXG4gKiBAcmV0dXJucyB7bWF0NH1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5pbnZlcnNlUHJvamVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl91cGRhdGVQcm9qZWN0aW9uKCk7XG4gIHJldHVybiB0aGlzLl9pbnZQcm9qTWF0cml4O1xufTtcblxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHRoZSB2aWV3IGZydXN0dW0gaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbWF5IHJldHVybiBmYWxzZSBwb3NpdGl2ZXMsIGJ1dCBuZXZlciBmYWxzZSBuZWdhdGl2ZXMuXG4gKiBJdCBpcyB1c2VkIGZvciBmcnVzdHVtIGN1bGxpbmcsIGkuZS4sIGV4Y2x1ZGluZyBpbnZpc2libGUgdGlsZXMgZnJvbSB0aGVcbiAqIHJlbmRlcmluZyBwcm9jZXNzLlxuICpcbiAqIEBwYXJhbSB7dmVjMltdfSByZWN0YW5nbGUgVGhlIHZlcnRpY2VzIG9mIHRoZSByZWN0YW5nbGUuXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHJlY3RhbmdsZSkge1xuICB0aGlzLl91cGRhdGVQcm9qZWN0aW9uKCk7XG5cbiAgdmFyIGZydXN0dW0gPSB0aGlzLl9mcnVzdHVtO1xuICB2YXIgdmVydGV4ID0gdGhpcy5fdG1wVmVjO1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHJlY3RhbmdsZSBpcyBvbiB0aGUgb3V0ZXIgc2lkZSBvZiBhbnkgb2YgdGhlIGZydXN0dW1cbiAgLy8gcGxhbmVzLiBUaGlzIGlzIGEgc3VmZmljaWVudCBjb25kaXRpb24sIHRob3VnaCBub3QgbmVjZXNzYXJ5LCBmb3IgdGhlXG4gIC8vIHJlY3RhbmdsZSB0byBiZSBjb21wbGV0ZWx5IG91dHNpZGUgdGhlIGZydXN0dW0uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnJ1c3R1bS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbGFuZSA9IGZydXN0dW1baV07XG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVjdGFuZ2xlLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgY29ybmVyID0gcmVjdGFuZ2xlW2pdO1xuICAgICAgdmVjNC5zZXQodmVydGV4LCBjb3JuZXJbMF0sIGNvcm5lclsxXSwgY29ybmVyWzJdLCAwKTtcbiAgICAgIGlmICh2ZWM0LmRvdChwbGFuZSwgdmVydGV4KSA+PSAwKSB7XG4gICAgICAgIGluc2lkZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaW5zaWRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIFNlbGVjdCB0aGUgbGV2ZWwgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIHZpZXcuXG4gKiBAcGFyYW0ge0xldmVsW119IGxldmVsTGlzdCB0aGUgbGlzdCBvZiBsZXZlbHMgZnJvbSB3aGljaCB0byBzZWxlY3QuXG4gKiBAcmV0dXJuIHtMZXZlbH0gdGhlIHNlbGVjdGVkIGxldmVsLlxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNlbGVjdExldmVsID0gZnVuY3Rpb24obGV2ZWxMaXN0KSB7XG5cbiAgLy8gTXVsdGlwbHkgdGhlIHZpZXdwb3J0IHdpZHRoIGJ5IHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW8gdG8gZ2V0IHRoZSByZXF1aXJlZFxuICAvLyBob3Jpem9udGFsIHJlc29sdXRpb24gaW4gcGl4ZWxzLlxuICAvL1xuICAvLyBDYWxjdWxhdGUgdGhlIGZyYWN0aW9uIG9mIGEgY3ViZSBmYWNlIHRoYXQgd291bGQgYmUgdmlzaWJsZSBnaXZlbiB0aGVcbiAgLy8gY3VycmVudCB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3LiBUaGVuLCBmb3IgZWFjaCBsZXZlbCwgbXVsdGlwbHkgYnkgdGhlXG4gIC8vIGxldmVsIGhlaWdodCB0byBnZXQgdGhlIGhlaWdodCBpbiBwaXhlbHMgb2YgdGhlIHBvcnRpb24gdGhhdCB3b3VsZCBiZVxuICAvLyB2aXNpYmxlLlxuICAvL1xuICAvLyBTZWFyY2ggZm9yIHRoZSBzbWFsbGVzdCBsZXZlbCB0aGF0IHNhdGlmaWVzIHRoZSB0aGUgcmVxdWlyZWQgaGVpZ2h0LFxuICAvLyBmYWxsaW5nIGJhY2sgb24gdGhlIGxhcmdlc3QgbGV2ZWwgaWYgbm9uZSBkby5cblxuICB2YXIgcmVxdWlyZWRQaXhlbHMgPSBwaXhlbFJhdGlvKCkgKiB0aGlzLl9oZWlnaHQ7XG4gIHZhciBjb3ZlckZhY3RvciA9IE1hdGgudGFuKDAuNSAqIHRoaXMuX2Zvdik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGV2ZWwgPSBsZXZlbExpc3RbaV07XG4gICAgaWYgKGNvdmVyRmFjdG9yICogbGV2ZWwuaGVpZ2h0KCkgPj0gcmVxdWlyZWRQaXhlbHMpIHtcbiAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGV2ZWxMaXN0W2xldmVsTGlzdC5sZW5ndGggLSAxXTtcblxufTtcblxuXG4vKipcbiAqIENvbnZlcnQgdmlldyBwYXJhbWV0ZXJzIGludG8gc2NyZWVuIHBvc2l0aW9uLiBJZiBhIHJlc3VsdCBhcmd1bWVudCBpc1xuICogcHJvdmlkZWQsIGl0IGlzIGZpbGxlZCBpbiBhbmQgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBmcmVzaCBvYmplY3QgaXMgZmlsbGVkXG4gKiBpbiBhbmQgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdDb29yZHN9IGNvb3JkcyBUaGUgdmlldyBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7Q29vcmRzPX0gcmVzdWx0IFRoZSByZXN1bHQgYXJndW1lbnQgZm9yIHRoZSBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtDb29yZHN9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuY29vcmRpbmF0ZXNUb1NjcmVlbiA9IGZ1bmN0aW9uKGNvb3JkcywgcmVzdWx0KSB7XG4gIHZhciByYXkgPSB0aGlzLl90bXBWZWM7XG5cbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSB7fTtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gIC8vIFVuZGVmaW5lZCBvbiBhIG51bGwgdmlld3BvcnQuXG4gIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgcmVzdWx0LnggPSBudWxsO1xuICAgIHJlc3VsdC55ID0gbnVsbDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdmlldyByYXkgcG9pbnRpbmcgaW50byB0aGUgKHlhdywgcGl0Y2gpIGRpcmVjdGlvbi5cbiAgdmFyIHlhdyA9IGNvb3Jkcy55YXc7XG4gIHZhciBwaXRjaCA9IGNvb3Jkcy5waXRjaDtcbiAgdmFyIHggPSBNYXRoLnNpbih5YXcpICogTWF0aC5jb3MocGl0Y2gpO1xuICB2YXIgeSA9IC1NYXRoLnNpbihwaXRjaCk7XG4gIHZhciB6ID0gLU1hdGguY29zKHlhdykgKiBNYXRoLmNvcyhwaXRjaCk7XG4gIHZlYzQuc2V0KHJheSwgeCwgeSwgeiwgMSk7XG5cbiAgLy8gUHJvamVjdCB2aWV3IHJheSBvbnRvIGNsaXAgc3BhY2UuXG4gIHZlYzQudHJhbnNmb3JtTWF0NChyYXksIHJheSwgdGhpcy5wcm9qZWN0aW9uKCkpO1xuXG4gIC8vIHcgaW4gY2xpcCBzcGFjZSBlcXVhbHMgLXogaW4gY2FtZXJhIHNwYWNlLlxuICBpZiAocmF5WzNdID49IDApIHtcbiAgICAvLyBQb2ludCBpcyBpbiBmcm9udCBvZiBjYW1lcmEuXG4gICAgLy8gQ29udmVydCB0byB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICByZXN1bHQueCA9IHdpZHRoICogKHJheVswXSAvIHJheVszXSArIDEpIC8gMjtcbiAgICByZXN1bHQueSA9IGhlaWdodCAqICgxIC0gcmF5WzFdIC8gcmF5WzNdKSAvIDI7XG4gIH0gZWxzZSB7XG4gICAgLy8gUG9pbnQgaXMgYmVoaW5kIGNhbWVyYS5cbiAgICByZXN1bHQueCA9IG51bGw7XG4gICAgcmVzdWx0LnkgPSBudWxsO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IHNjcmVlbiBjb29yZGluYXRlcyBpbnRvIHZpZXcgY29vcmRpbmF0ZXMuIElmIGEgcmVzdWx0IGFyZ3VtZW50IGlzXG4gKiBwcm92aWRlZCwgaXQgaXMgZmlsbGVkIGluIHdpdGggdGhlIHJlc3VsdCBhbmQgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBmcmVzaFxuICogb2JqZWN0IGlzIGZpbGxlZCBpbiBhbmQgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtDb29yZHN9IGNvb3JkcyBUaGUgc2NyZWVuIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdDb29yZHM9fSByZXN1bHQgVGhlIHZpZXcgY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtSZWN0aWxpbmVhclZpZXdDb29yZHN9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2NyZWVuVG9Db29yZGluYXRlcyA9IGZ1bmN0aW9uKGNvb3JkcywgcmVzdWx0KSB7XG4gIHZhciByYXkgPSB0aGlzLl90bXBWZWM7XG5cbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSB7fTtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gIC8vIENvbnZlcnQgdmlld3BvcnQgY29vcmRpbmF0ZXMgdG8gY2xpcCBzcGFjZS5cbiAgdmFyIHZlY3ggPSAyICogY29vcmRzLnggLyB3aWR0aCAtIDE7XG4gIHZhciB2ZWN5ID0gMSAtIDIgKiBjb29yZHMueSAvIGhlaWdodDtcbiAgdmVjNC5zZXQocmF5LCB2ZWN4LCB2ZWN5LCAxLCAxKTtcblxuICAvLyBQcm9qZWN0IGJhY2sgdG8gd29ybGQgc3BhY2UuXG4gIHZlYzQudHJhbnNmb3JtTWF0NChyYXksIHJheSwgdGhpcy5pbnZlcnNlUHJvamVjdGlvbigpKTtcblxuICAvLyBDb252ZXJ0IHRvIHNwaGVyaWNhbCBjb29yZGluYXRlcy5cbiAgdmFyIHIgPSBNYXRoLnNxcnQocmF5WzBdICogcmF5WzBdICsgcmF5WzFdICogcmF5WzFdICsgcmF5WzJdICogcmF5WzJdKTtcbiAgcmVzdWx0LnlhdyA9IE1hdGguYXRhbjIocmF5WzBdLCAtcmF5WzJdKTtcbiAgcmVzdWx0LnBpdGNoID0gTWF0aC5hY29zKHJheVsxXSAvIHIpIC0gTWF0aC5QSS8yO1xuXG4gIHRoaXMuX25vcm1hbGl6ZUNvb3JkaW5hdGVzKHJlc3VsdCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHBlcnNwZWN0aXZlIHRyYW5zZm9ybSByZXF1aXJlZCB0byBwb3NpdGlvbiBhbiBlbGVtZW50IHdpdGhcbiAqIHBlcnNwZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7UmVjdGlsaW5lYXJWaWV3Q29vcmRzfSBjb29yZHMgVGhlIHZpZXcgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgc3BoZXJlIGVtYmVkZGluZyB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBleHRyYVRyYW5zZm9ybXMgRXh0cmEgdHJhbnNmb3JtYXRpb25zIHRvIGJlIGFwcGxpZWQgYWZ0ZXJcbiAqICAgICB0aGUgZWxlbWVudCBpcyBwb3NpdGlvbmVkLiBUaGlzIG1heSBiZSB1c2VkIHRvIHJvdGF0ZSB0aGUgZWxlbWVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIENTUyAzRCB0cmFuc2Zvcm0gdG8gYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudC5cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5jb29yZGluYXRlc1RvUGVyc3BlY3RpdmVUcmFuc2Zvcm0gPSBmdW5jdGlvbihcbiAgICBjb29yZHMsIHJhZGl1cywgZXh0cmFUcmFuc2Zvcm1zKSB7XG4gIGV4dHJhVHJhbnNmb3JtcyA9IGV4dHJhVHJhbnNmb3JtcyB8fCBcIlwiO1xuXG4gIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICB2YXIgZm92ID0gdGhpcy5fZm92O1xuICB2YXIgcGVyc3BlY3RpdmUgPSAwLjUgKiBoZWlnaHQgLyBNYXRoLnRhbihmb3YgLyAyKTtcblxuICB2YXIgdHJhbnNmb3JtID0gJyc7XG5cbiAgLy8gQ2VudGVyIGhvdHNwb3QgaW4gc2NyZWVuLlxuICB0cmFuc2Zvcm0gKz0gJ3RyYW5zbGF0ZVgoJyArIGRlY2ltYWwod2lkdGgvMikgKyAncHgpICc7XG4gIHRyYW5zZm9ybSArPSAndHJhbnNsYXRlWSgnICsgZGVjaW1hbChoZWlnaHQvMikgKyAncHgpICc7XG4gIHRyYW5zZm9ybSArPSAndHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpICc7XG5cbiAgLy8gU2V0IHRoZSBwZXJzcGVjdGl2ZSBkZXB0aC5cbiAgdHJhbnNmb3JtICs9ICdwZXJzcGVjdGl2ZSgnICsgZGVjaW1hbChwZXJzcGVjdGl2ZSkgKyAncHgpICc7XG4gIHRyYW5zZm9ybSArPSAndHJhbnNsYXRlWignICsgZGVjaW1hbChwZXJzcGVjdGl2ZSkgKyAncHgpICc7XG5cbiAgLy8gU2V0IHRoZSBjYW1lcmEgcm90YXRpb24uXG4gIHRyYW5zZm9ybSArPSAncm90YXRlWignICsgZGVjaW1hbCgtdGhpcy5fcm9sbCkgKyAncmFkKSAnO1xuICB0cmFuc2Zvcm0gKz0gJ3JvdGF0ZVgoJyArIGRlY2ltYWwoLXRoaXMuX3BpdGNoKSArICdyYWQpICc7XG4gIHRyYW5zZm9ybSArPSAncm90YXRlWSgnICsgZGVjaW1hbCh0aGlzLl95YXcpICsgJ3JhZCkgJztcblxuICAvLyBTZXQgdGhlIGhvdHNwb3Qgcm90YXRpb24uXG4gIHRyYW5zZm9ybSArPSAncm90YXRlWSgnICsgZGVjaW1hbCgtY29vcmRzLnlhdykgKyAncmFkKSAnO1xuICB0cmFuc2Zvcm0gKz0gJ3JvdGF0ZVgoJyArIGRlY2ltYWwoY29vcmRzLnBpdGNoKSArICdyYWQpICc7XG5cbiAgLy8gTW92ZSBiYWNrIHRvIHNwaGVyZS5cbiAgdHJhbnNmb3JtICs9ICd0cmFuc2xhdGVaKCcgKyBkZWNpbWFsKC1yYWRpdXMpICsgJ3B4KSAnO1xuXG4gIC8vIEFwcGx5IHRoZSBleHRyYSB0cmFuc2Zvcm1hdGlvbnNcbiAgdHJhbnNmb3JtICs9IGV4dHJhVHJhbnNmb3JtcyArICcgJztcblxuICByZXR1cm4gdHJhbnNmb3JtO1xufTtcblxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb25zIGZvciB2aWV3IGxpbWl0ZXJzLiBTZWUge0BsaW5rIFJlY3RpbGluZWFyVmlld0xpbWl0ZXJ9LlxuICogQG5hbWVzcGFjZVxuICovXG5SZWN0aWxpbmVhclZpZXcubGltaXQgPSB7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2aWV3IGxpbWl0ZXIgdGhhdCBjb25zdHJhaW5zIHRoZSB5YXcgYW5nbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0geWF3IHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHlhdyB2YWx1ZS5cbiAgICogQHJldHVybiB7UmVjdGlsaW5lYXJWaWV3TGltaXRlcn1cbiAgICovXG4gIHlhdzogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRZYXcocGFyYW1zKSB7XG4gICAgICBwYXJhbXMueWF3ID0gY2xhbXAocGFyYW1zLnlhdywgbWluLCBtYXgpO1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgcGl0Y2ggYW5nbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcGl0Y2ggdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gcGl0Y2ggdmFsdWUuXG4gICAqIEByZXR1cm4ge1JlY3RpbGluZWFyVmlld0xpbWl0ZXJ9XG4gICAqL1xuICBwaXRjaDogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRQaXRjaChwYXJhbXMpIHtcbiAgICAgIHBhcmFtcy5waXRjaCA9IGNsYW1wKHBhcmFtcy5waXRjaCwgbWluLCBtYXgpO1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgcm9sbCBhbmdsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSByb2xsIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHJvbGwgdmFsdWUuXG4gICAqIEByZXR1cm4ge1JlY3RpbGluZWFyVmlld0xpbWl0ZXJ9XG4gICAqL1xuICByb2xsOiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFJvbGwocGFyYW1zKSB7XG4gICAgICBwYXJhbXMucm9sbCA9IGNsYW1wKHBhcmFtcy5yb2xsLCBtaW4sIG1heCk7XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2aWV3IGxpbWl0ZXIgdGhhdCBjb25zdHJhaW5zIHRoZSBob3Jpem9udGFsIGZpZWxkIG9mIHZpZXcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gaG9yaXpvbnRhbCBmaWVsZCBvZiB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIGhvcml6b250YWwgZmllbGQgb2Ygdmlldy5cbiAgICogQHJldHVybiB7UmVjdGlsaW5lYXJWaWV3TGltaXRlcn1cbiAgICovXG4gIGhmb3Y6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0SGZvdihwYXJhbXMpIHtcbiAgICAgIHZhciB3aWR0aCA9IHBhcmFtcy53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBwYXJhbXMuaGVpZ2h0O1xuICAgICAgaWYgKHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwKSB7XG4gICAgICAgIHZhciB2bWluID0gY29udmVydEZvdi5odG92KG1pbiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHZhciB2bWF4ID0gY29udmVydEZvdi5odG92KG1heCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHBhcmFtcy5mb3YgPSBjbGFtcChwYXJhbXMuZm92LCB2bWluLCB2bWF4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIHZlcnRpY2FsIGZpZWxkIG9mIHZpZXcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gdmVydGljYWwgZmllbGQgb2Ygdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3LlxuICAgKiBAcmV0dXJuIHtSZWN0aWxpbmVhclZpZXdMaW1pdGVyfVxuICAgKi9cbiAgdmZvdjogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRWZm92KHBhcmFtcykge1xuICAgICAgcGFyYW1zLmZvdiA9IGNsYW1wKHBhcmFtcy5mb3YsIG1pbiwgbWF4KTtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IHByZXZlbnRzIHpvb21pbmcgaW4gYmV5b25kIHRoZSBnaXZlblxuICAgKiByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBUaGUgY3ViZSBmYWNlIHdpZHRoIGluIHBpeGVscyBvciwgZXF1aXZhbGVudGx5LCBvbmVcbiAgICogICAgIGZvdXJ0aCBvZiB0aGUgZXF1aXJlY3Rhbmd1bGFyIHdpZHRoIGluIHBpeGVscy5cbiAgICogQHJldHVybiB7UmVjdGlsaW5lYXJWaWV3TGltaXRlcn1cbiAgICovXG4gIHJlc29sdXRpb246IGZ1bmN0aW9uKHNpemUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRSZXNvbHV0aW9uKHBhcmFtcykge1xuICAgICAgdmFyIGhlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG4gICAgICBpZiAoaGVpZ2h0KSB7XG4gICAgICAgIHZhciByZXF1aXJlZFBpeGVscyA9IHBpeGVsUmF0aW8oKSAqIGhlaWdodDtcbiAgICAgICAgdmFyIG1pbkZvdiA9IDIgKiBNYXRoLmF0YW4ocmVxdWlyZWRQaXhlbHMgLyBzaXplKTtcbiAgICAgICAgcGFyYW1zLmZvdiA9IGNsYW1wKHBhcmFtcy5mb3YsIG1pbkZvdiwgSW5maW5pdHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgbGltaXRzIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBmaWVsZCBvZlxuICAgKiB2aWV3LCBwcmV2ZW50cyB6b29taW5nIGluIHBhc3QgdGhlIGltYWdlIHJlc29sdXRpb24sIGFuZCBsaW1pdHMgdGhlIHBpdGNoXG4gICAqIHJhbmdlIHRvIHByZXZlbnQgdGhlIGNhbWVyYSB3cmFwcGluZyBhcm91bmQgYXQgdGhlIHBvbGVzLiBUaGVzZSBhcmUgdGhlXG4gICAqIG1vc3QgY29tbW9uIHZpZXcgY29uc3RyYWludHMgZm9yIGEgMzYwwrAgcGFub3JhbWEuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhSZXNvbHV0aW9uIFRoZSBjdWJlIGZhY2Ugd2lkdGggaW4gcGl4ZWxzIG9yLFxuICAgKiAgICAgZXF1aXZhbGVudGx5LCBvbmUgZm91cnRoIG9mIHRoZSBlcXVpcmVjdGFuZ3VsYXIgd2lkdGggaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4VkZvdiBUaGUgbWF4aW11bSB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW21heEhGb3Y9bWF4VkZvdl0gVGhlIG1heGltdW0gaG9yaXpvbnRhbCBmaWVsZCBvZiB2aWV3LlxuICAgKiBAcmV0dXJuIHtSZWN0aWxpbmVhclZpZXdMaW1pdGVyfVxuICAgKi9cbiAgdHJhZGl0aW9uYWw6IGZ1bmN0aW9uKG1heFJlc29sdXRpb24sIG1heFZGb3YsIG1heEhGb3YpIHtcbiAgICBtYXhIRm92ID0gbWF4SEZvdiAhPSBudWxsID8gbWF4SEZvdiA6IG1heFZGb3Y7XG5cbiAgICByZXR1cm4gY29tcG9zZShcbiAgICAgIFJlY3RpbGluZWFyVmlldy5saW1pdC5yZXNvbHV0aW9uKG1heFJlc29sdXRpb24pLFxuICAgICAgUmVjdGlsaW5lYXJWaWV3LmxpbWl0LnZmb3YoMCwgbWF4VkZvdiksXG4gICAgICBSZWN0aWxpbmVhclZpZXcubGltaXQuaGZvdigwLCBtYXhIRm92KSxcbiAgICAgIFJlY3RpbGluZWFyVmlldy5saW1pdC5waXRjaCgtTWF0aC5QSS8yLCBNYXRoLlBJLzIpKTtcbiAgfVxuXG59O1xuXG5cblJlY3RpbGluZWFyVmlldy50eXBlID0gUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS50eXBlID0gJ3JlY3RpbGluZWFyJztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RpbGluZWFyVmlldztcbiJdfQ==
